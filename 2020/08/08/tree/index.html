<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false,"avatar":"E:/My_Blog/themes/next/source/images/jaychou.jpg","url":null,"rounded":false,"rotated":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/search.xml"};
  </script>

  <meta name="description" content="14.leetcode刷题—-树数据结构：123456struct TreeNode &amp;#123;    int val;    TreeNode *left;    TreeNode *right;    TreeNode(int x) : val(x), left(NULL), right(NULL) &amp;#123;&amp;#125;&amp;#125;;">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode刷题---树">
<meta property="og:url" content="http://yoursite.com/2020/08/08/tree/index.html">
<meta property="og:site_name" content="jdw - blog">
<meta property="og:description" content="14.leetcode刷题—-树数据结构：123456struct TreeNode &amp;#123;    int val;    TreeNode *left;    TreeNode *right;    TreeNode(int x) : val(x), left(NULL), right(NULL) &amp;#123;&amp;#125;&amp;#125;;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/08/08/tree/screen-shot-2019-07-01-at-53836-pm.png">
<meta property="article:published_time" content="2020-08-08T02:57:45.000Z">
<meta property="article:modified_time" content="2020-09-01T09:33:27.319Z">
<meta property="article:author" content="JDW">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/08/08/tree/screen-shot-2019-07-01-at-53836-pm.png">

<link rel="canonical" href="http://yoursite.com/2020/08/08/tree/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leetcode刷题---树 | jdw - blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">jdw - blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">随笔</p>
      <a>
        <img class="custom-logo-image" src="[object Object]" alt="jdw - blog">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">15</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/08/tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JDW">
      <meta itemprop="description" content="记录进阶之路">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jdw - blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode刷题---树
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-08 10:57:45" itemprop="dateCreated datePublished" datetime="2020-08-08T10:57:45+08:00">2020-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-01 17:33:27" itemprop="dateModified" datetime="2020-09-01T17:33:27+08:00">2020-09-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="14-leetcode刷题—-树"><a href="#14-leetcode刷题—-树" class="headerlink" title="14.leetcode刷题—-树"></a>14.leetcode刷题—-树</h1><h2 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a>相关题目：</h2><h2 id="树的递归："><a href="#树的递归：" class="headerlink" title="树的递归："></a>树的递归：</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p>
<h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>我们首先要注意到深度的定义：<strong>根节点到最远叶子节点的最长路径上的节点数</strong>。</p>
<p>可知当前节点的深度等于 <code>以其左孩子为根节点的深度</code> 或 <code>以其右孩子为根节点的深度</code> 两者中最大值加1.</p>
</blockquote>
<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="literal">NULL</span>?<span class="number">0</span>:<span class="built_in">max</span>(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<p>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7] </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>返回 true 。</p>
<h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>当前节点平衡的条件：1.左子树为平衡二叉树，2.右子树为平衡二叉树，3.左右孩子高度之差的绝对值小于2.定义一个辅助函数，其功能为：如果以当前节点为根节点的树为平衡二叉树就返回这棵树的高度，否则返回-1.</p>
</blockquote>
<h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;<span class="comment">//返回节点的高度，若过当前节点不平衡就返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=helper(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right=helper(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">-1</span>||right==<span class="number">-1</span>||<span class="built_in">abs</span>(left-right)&gt;<span class="number">1</span>)<span class="comment">//如果左子树不平衡或者右子树不平衡或者左右子树高度之差大于1，返回-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root)!=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p>示例 :<br>给定二叉树</p>
<pre><code>      1
     / \
    2   3
   / \     
  4   5    
</code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p>
<h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p><code>一颗二叉树的直径长度的定义：任意两个结点路径长度中的最大值。</code></p>
<p>可知二叉树的直径长度为以根节点中转节点，其数值等于左右子树的高度之和。</p>
</blockquote>
<h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;<span class="comment">//返回以root为根节点的二叉树的高度</span></span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=helper(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right=helper(root-&gt;right);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,left+right);<span class="comment">//更新最大直径长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h3><h4 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
</code></pre><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
<h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>采用将sum递减的方法，如果当前节点为叶子节点且sum等于0，返回true</p>
<p>如果否则对其左右子树递归。</p>
</blockquote>
<h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">        sum-=root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right&amp;&amp;sum==<span class="number">0</span>)<span class="comment">//叶子节点且路径和等于sum</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left,sum)||hasPathSum(root-&gt;right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h3><h4 id="题目描述：；"><a href="#题目描述：；" class="headerlink" title="题目描述：；"></a>题目描述：；</h4><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \    / \
    7    2  5   1
</code></pre><p>返回:</p>
<blockquote>
<p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p>
</blockquote>
<h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>相当于dfs，只不过多了一个用vector记录路径的步骤。与上面的题目解法类似。</p>
</blockquote>
<h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root,<span class="keyword">int</span> sum,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        sum-=root-&gt;val;</span><br><span class="line">        v.push_back(root-&gt;val);<span class="comment">//记录路径</span></span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right)&#123;<span class="comment">//如果当前节点为叶子节点且路径和等于sum</span></span><br><span class="line">            ans.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root-&gt;left,sum,v);</span><br><span class="line">        helper(root-&gt;right,sum,v);</span><br><span class="line">        v.pop_back();<span class="comment">//当左右子树都已访问，将其记录消除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        helper(root,sum,v);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></h3><h4 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>
<p>找出路径和等于给定数值的路径总数。</p>
<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<p>示例：</p>
<p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p>
<pre><code>      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1
返回 3。和等于 8 的路径有:
1.  5 -&gt; 3
2.  5 -&gt; 2 -&gt; 1
3.  -3 -&gt; 11
</code></pre><h4 id="题目描述：-5"><a href="#题目描述：-5" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote>
<p>对每个节点都有两种情况（注意：<strong>路径方向必须是向下的（只能从父节点到子节点）</strong>）</p>
<ol>
<li>取该节点的值，且连续取其子树的节点的值</li>
<li>不取该节点的值，以其孩子为路径起点</li>
</ol>
<p>对于情况1来说，我们需要一个辅助函数来完成其连续取值的累加和工作</p>
<p>对于情况2来说，用原函数递归完成</p>
</blockquote>
<h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSumWithRoot</span><span class="params">(TreeNode* root,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=root-&gt;val==sum?<span class="number">1</span>:<span class="number">0</span>;<span class="comment">//如果当前节点的值等于目标值sum，count置为1，否则置为0</span></span><br><span class="line">        <span class="comment">//递归调用左右子树计算路径和</span></span><br><span class="line">        count+=pathSumWithRoot(root-&gt;left,sum-root-&gt;val);</span><br><span class="line">        count+=pathSumWithRoot(root-&gt;right,sum-root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空树返回0</span></span><br><span class="line">        <span class="keyword">return</span> pathSumWithRoot(root,sum)+<span class="comment">//以当前节点为路径起点（加上root-&gt;val）</span></span><br><span class="line">            pathSum(root-&gt;left,sum)+pathSum(root-&gt;right,sum);<span class="comment">//或以当前节点左右孩子为根节点（没有加上root-&gt;val）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h3><h4 id="题目描述：-6"><a href="#题目描述：-6" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> \   \</span><br><span class="line"> <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>进阶：</p>
<p>你可以运用递归和迭代两种方法解决这个问题吗？</p>
<h4 id="题解（递归）："><a href="#题解（递归）：" class="headerlink" title="题解（递归）："></a>题解（递归）：</h4><blockquote>
<p>如果以当前节点为根节点的二叉树为是镜像对称的。要满足以下条件：</p>
<ol>
<li>其左右子树的值相同，或者左右子树同时为空。</li>
<li>其左子树的左子树与其右子树的右子树是镜像兑成的。</li>
<li>其左子树的右子树与其右子树的左子树是镜像兑成的。</li>
</ol>
<p>（有点混淆）</p>
</blockquote>
<h4 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* r1,TreeNode* r2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!r1&amp;&amp;!r2)<span class="comment">//r1和r2都为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!r1||!r2)<span class="comment">//r1和r2不同</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(r1-&gt;val!=r2-&gt;val)<span class="comment">//r1和r2的值不对称 （不满足条件1）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//条件2和3</span></span><br><span class="line">        <span class="keyword">return</span> helper(r1-&gt;left,r2-&gt;right)&amp;&amp;helper(r1-&gt;right,r2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !root||helper(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="题解（迭代）：参考"><a href="#题解（迭代）：参考" class="headerlink" title="题解（迭代）：参考"></a>题解（迭代）：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/">参考</a></h4><blockquote>
<p>层次遍历，不过入队的方式有所不同，首先将根节点入队两次。然后每次从队列中提取两节点来比较，若两值相同，入队顺序：节点1的左子树、节点2的右子树、节点1的右子树、节点2的左子树。与上面的<strong>条件2</strong>：<code>其左子树的左子树与其右子树的右子树是镜像兑成的</code>和<strong>条件3：</strong><code>其左子树的右子树与其右子树的左子树是镜像兑成的</code>相同。</p>
</blockquote>
<h4 id="代码：-7"><a href="#代码：-7" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* u,TreeNode* v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(u);q.push(v);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="comment">//提取队列中的两个节点</span></span><br><span class="line">            u=q.front();q.pop();</span><br><span class="line">            v=q.front();q.pop();</span><br><span class="line">            <span class="comment">//队列中每两个相邻节点值的情况肯定相同</span></span><br><span class="line">            <span class="keyword">if</span>(!u&amp;&amp;!v)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((!u||!v)||(u-&gt;val!=v-&gt;val))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            q.push(u-&gt;left);<span class="comment">//u的左子树与v的右子树比较</span></span><br><span class="line">            q.push(v-&gt;right);</span><br><span class="line">            </span><br><span class="line">            q.push(u-&gt;right);<span class="comment">//u的右子树和v的左子树比较</span></span><br><span class="line">            q.push(v-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1110-删点成林"><a href="#1110-删点成林" class="headerlink" title="1110. 删点成林"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-nodes-and-return-forest/">1110. 删点成林</a></h3><h4 id="题目描述：-7"><a href="#题目描述：-7" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给出二叉树的根节点 root，树上每个节点都有一个不同的值。</p>
<p>如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。</p>
<p>返回森林中的每棵树。你可以按任意顺序组织答案。</p>
<p>示例：</p>
<p><img src="/2020/08/08/tree/screen-shot-2019-07-01-at-53836-pm.png" alt="screen-shot-2019-07-01-at-53836-pm"></p>
<blockquote>
<p>输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]<br>输出：[[1,2,null,4],[6],[7]]</p>
</blockquote>
<p>提示：</p>
<ul>
<li>树中的节点数最大为 1000。</li>
<li>每个节点都有一个介于 1 到 1000 之间的值，且各不相同。</li>
<li>to_delete.length &lt;= 1000</li>
<li>to_delete 包含一些从 1 到 1000、各不相同的值。</li>
<li>通过次数4,146提交次数6,907</li>
</ul>
<h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>采用自底向上的方法。从底层开始，先对其左右子树递归调用。如果当前节点的值在删除节点的集合中，（左右子树不在删除集合中）则将其左右孩子加入到森林forest并将其置为NULL。</p>
</blockquote>
<h4 id="代码：-8"><a href="#代码：-8" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode*&amp; root,<span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; forest,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&amp; deleteN)</span> </span>&#123;<span class="comment">//自底向上</span></span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对应左右子树递归调用</span></span><br><span class="line">        root-&gt;left=helper(root-&gt;left,forest,deleteN);</span><br><span class="line">        root-&gt;right=helper(root-&gt;right,forest,deleteN);</span><br><span class="line">        <span class="keyword">if</span>(deleteN.count(root-&gt;val))&#123;<span class="comment">//如果当前节点的值在删除节点中，只有这种情况才会将节点加入到森林</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)<span class="comment">//如果左子树不为空，则加入到森林</span></span><br><span class="line">                forest.push_back(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)<span class="comment">//如果右子树不为空，则加入到森林</span></span><br><span class="line">                forest.push_back(root-&gt;right);</span><br><span class="line">            root=<span class="literal">NULL</span>;<span class="comment">//将当前节点置空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">deleteN</span><span class="params">(to_delete.<span class="built_in">begin</span>(),to_delete.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; forest;</span><br><span class="line">        root=helper(root,forest,deleteN);</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            forest.push_back(root);</span><br><span class="line">        <span class="keyword">return</span> forest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="遍历："><a href="#遍历：" class="headerlink" title="遍历："></a>遍历：</h2><h3 id="层次遍历："><a href="#层次遍历：" class="headerlink" title="层次遍历："></a>层次遍历：</h3><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h3><h4 id="题目描述：-8"><a href="#题目描述：-8" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：<br>     3<br>    / \<br>  9  20<br>      /  \<br>    15   7<br>输出：[3, 14.5, 11]<br>解释：<br>第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</p>
</blockquote>
<h4 id="题解：-6"><a href="#题解：-6" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>典型的层次遍历模板。</p>
</blockquote>
<h4 id="代码：-9"><a href="#代码：-9" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span>=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;++i)&#123;</span><br><span class="line">                TreeNode* t=q.front();q.pop();</span><br><span class="line">                sum+=t-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(sum/<span class="built_in">size</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="前序遍历：；"><a href="#前序遍历：；" class="headerlink" title="前序遍历：；"></a>前序遍历：；</h3><h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h3><p>给定一个二叉树，返回它的 前序 遍历。</p>
<p> 示例:</p>
<blockquote>
<p>输入: [1,null,2,3]<br>   1<br>    \<br>     2<br>    /<br>   3 </p>
<p>输出: [1,2,3]</p>
<p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
</blockquote>
<h4 id="题解（递归）：-1"><a href="#题解（递归）：-1" class="headerlink" title="题解（递归）："></a>题解（递归）：</h4><blockquote>
<p>略</p>
</blockquote>
<h4 id="代码：-10"><a href="#代码：-10" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        preorder_route.push_back(root-&gt;val);</span><br><span class="line">        preorder(root-&gt;left,preorder_route);</span><br><span class="line">        preorder(root-&gt;right,preorder_route);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder_route;</span><br><span class="line">        preorder(root,preorder_route);</span><br><span class="line">        <span class="keyword">return</span> preorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="题解（迭代）："><a href="#题解（迭代）：" class="headerlink" title="题解（迭代）："></a>题解（迭代）：</h4><blockquote>
<p>用一个栈来模拟前序遍历时函数调用的过程。主要过程如下：我们每入栈一个节点就将其节点值加入到数组中，然后一直将其左边的节点入栈直到左边不存在节点。其后从取栈顶节点，取其右孩子，若不为空继续上述操作。这样重复执行直到栈空。</p>
</blockquote>
<h4 id="代码：-11"><a href="#代码：-11" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* t=root;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(t)&#123;</span><br><span class="line">                s.push(t);<span class="comment">//入栈时将节点值加入到队列中</span></span><br><span class="line">                preorder_route.push_back(t-&gt;val);</span><br><span class="line">                t=t-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            t=s.top();s.pop();t=t-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">while</span>(!s.empty()||t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder_route;</span><br><span class="line">        preorder(root,preorder_route);</span><br><span class="line">        <span class="keyword">return</span> preorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h3><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h3><h4 id="题目描述：-9"><a href="#题目描述：-9" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    <span class="string">\</span></span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    <span class="string">/</span></span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="string">输出:</span> [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h4 id="题解（递归）"><a href="#题解（递归）" class="headerlink" title="题解（递归）:"></a>题解（递归）:</h4><blockquote>
<p>略。</p>
</blockquote>
<h4 id="代码：-12"><a href="#代码：-12" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        inorder(root-&gt;left,inorder_route);</span><br><span class="line">        inorder_route.push_back(root-&gt;val);</span><br><span class="line">        inorder(root-&gt;right,inorder_route);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_route;</span><br><span class="line">        inorder(root,inorder_route);</span><br><span class="line">        <span class="keyword">return</span> inorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="题解（迭代）：-1"><a href="#题解（迭代）：-1" class="headerlink" title="题解（迭代）："></a>题解（迭代）：</h4><blockquote>
<p>和前序遍历的迭代代码类似，只是将节点值加入到数组的时机不同。</p>
</blockquote>
<h4 id="代码：-13"><a href="#代码：-13" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* t=root;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(t)&#123;</span><br><span class="line">                s.push(t);</span><br><span class="line">                t=t-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            t=s.top();s.pop();<span class="comment">//出栈时将节点值加入到数组</span></span><br><span class="line">            inorder_route.push_back(t-&gt;val);</span><br><span class="line">            t=t-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">while</span>(!s.empty()||t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_route;</span><br><span class="line">        inorder(root,inorder_route);</span><br><span class="line">        <span class="keyword">return</span> inorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历："><a href="#后序遍历：" class="headerlink" title="后序遍历："></a>后序遍历：</h3><h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h3><h4 id="题目描述：-10"><a href="#题目描述：-10" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，返回它的 后序 遍历。</p>
<p>示例:</p>
<blockquote>
<p>输入: [1,null,2,3]<br>   1<br>    \<br>     2<br>    /<br>   3 </p>
<p>输出: [3,2,1]<br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p>
</blockquote>
<h4 id="题解（递归）：-2"><a href="#题解（递归）：-2" class="headerlink" title="题解（递归）："></a>题解（递归）：</h4><blockquote>
<p>略。</p>
</blockquote>
<h4 id="代码：-14"><a href="#代码：-14" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        postorder(root-&gt;left,postorder_route);</span><br><span class="line">        postorder(root-&gt;right,postorder_route);</span><br><span class="line">        postorder_route.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder_route;</span><br><span class="line">        postorder(root,postorder_route);</span><br><span class="line">        <span class="keyword">return</span> postorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="题解（迭代）：-2"><a href="#题解（迭代）：-2" class="headerlink" title="题解（迭代）："></a>题解（迭代）：</h4><blockquote>
<p>同样用栈模拟遍历过程，先将根<code>I:</code>节点入栈，然后将其出栈，再入栈，同时紧跟一个NULL入栈，然后按照先右后左的顺序入栈。当我们从栈顶提取节点时，若栈顶元素为NULL则表示其下面的节点的左右子树已经遍历，将其值加入到数组中，否则，则表示该元素左右子树未遍历，需要重复进行<code>I</code>操作。</p>
</blockquote>
<h4 id="代码：-15"><a href="#代码：-15" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* t=root;</span><br><span class="line">        s.push(t);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            t=s.top();s.pop();</span><br><span class="line">            <span class="keyword">if</span>(t)&#123;<span class="comment">//当t的左右子树未入栈时，将t再次入栈，使其在栈中位于左右子树下面，并用NULL标记表示其左右子树都已经遍历过</span></span><br><span class="line">                s.push(t);</span><br><span class="line">                s.push(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">//因为栈是先进后出，要想先遍历左子树，左子树要后入栈</span></span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)s.push(t-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left)s.push(t-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//在NULL下面的节点，已经访问过其左右子树了</span></span><br><span class="line">                postorder_route.push_back(s.top()-&gt;val);</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder_route;</span><br><span class="line">        postorder(root,postorder_route);</span><br><span class="line">        <span class="keyword">return</span> postorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="根据遍历序列构造树："><a href="#根据遍历序列构造树：" class="headerlink" title="根据遍历序列构造树："></a>根据遍历序列构造树：</h3><blockquote>
<p>一共有三种组合：</p>
<ol>
<li>前序和中序</li>
<li>中序和后序</li>
<li>前序和后序</li>
</ol>
<p><strong>只有1和2可以唯一确定一颗二叉树，3不能<code>唯一</code>确定一颗二叉树</strong></p>
</blockquote>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><h4 id="题目描述：-11"><a href="#题目描述：-11" class="headerlink" title="题目描述："></a>题目描述：</h4><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<blockquote>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]</p>
</blockquote>
<p>返回如下的二叉树：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h4 id="题解：-7"><a href="#题解：-7" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>观察前序和中序遍历序列的关系。前序第一个为根节点的值，然后在中序找到这个值的位置，其左边的元素个数，就是左子树的节点个数，其右边的元素个数，就是右子树的节点个数。根据这个规律，可以用递归的方法实现。</p>
</blockquote>
<h4 id="代码：-16"><a href="#代码：-16" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,<span class="keyword">int</span> first1,<span class="keyword">int</span> last1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> first2,<span class="keyword">int</span> last2)</span> </span>&#123;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(preorder[first1]);</span><br><span class="line">        <span class="keyword">int</span> pos=first2;</span><br><span class="line">        <span class="keyword">while</span>(inorder[pos]!=preorder[first1])&#123;<span class="comment">//找到根节点的值在中序序列中的位置</span></span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftsize=pos-first2;<span class="comment">//计算左右子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> rightsize=last2-pos;</span><br><span class="line">        <span class="comment">//递归生成左右子树</span></span><br><span class="line">        <span class="keyword">if</span>(leftsize)root-&gt;left=helper(preorder,first1+<span class="number">1</span>,first1+leftsize,inorder,first2,pos<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rightsize)root-&gt;right=helper(preorder,first1+leftsize+<span class="number">1</span>,last1,inorder,pos+<span class="number">1</span>,last2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>,inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><h4 id="题目描述：-12"><a href="#题目描述：-12" class="headerlink" title="题目描述："></a>题目描述：</h4><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<blockquote>
<p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]</p>
</blockquote>
<p>返回如下的二叉树：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h4 id="题解：-8"><a href="#题解：-8" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>与上面前序和中序的想法类似。不具体介绍。</p>
</blockquote>
<h4 id="代码：-17"><a href="#代码：-17" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> first1,<span class="keyword">int</span> last1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder,<span class="keyword">int</span> first2,<span class="keyword">int</span> last2)</span> </span>&#123;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(postorder[last2]);</span><br><span class="line">        <span class="keyword">int</span> pos=first1;</span><br><span class="line">        <span class="keyword">while</span>(inorder[pos]!=postorder[last2])&#123;<span class="comment">//找出根节点在中序序列的位置</span></span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算左右子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> leftsize=pos-first1;</span><br><span class="line">        <span class="keyword">int</span> rightsize=last1-pos;</span><br><span class="line">        <span class="comment">//递归生成左右子树</span></span><br><span class="line">        <span class="keyword">if</span>(leftsize)root-&gt;left=helper(inorder,first1,pos<span class="number">-1</span>,postorder,first2,first2+leftsize<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rightsize)root-&gt;right=helper(inorder,pos+<span class="number">1</span>,last1,postorder,first2+leftsize,last2<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>,postorder,<span class="number">0</span>,postorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="889-根据前序和后序遍历构造二叉树"><a href="#889-根据前序和后序遍历构造二叉树" class="headerlink" title="889. 根据前序和后序遍历构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a></h3><h4 id="题目描述：-13"><a href="#题目描述：-13" class="headerlink" title="题目描述："></a>题目描述：</h4><p>返回与给定的前序和后序遍历匹配的任何二叉树。</p>
<p> pre 和 post 遍历中的值是不同的正整数。</p>
<p>示例：</p>
<blockquote>
<p>输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]<br>输出：[1,2,3,4,5,6,7]</p>
</blockquote>
<p>提示：</p>
<ul>
<li>1 &lt;= pre.length == post.length &lt;= 30</li>
<li>pre[] 和 post[] 都是 1, 2, …, pre.length 的排列</li>
<li>每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。</li>
</ul>
<h4 id="题解：-9"><a href="#题解：-9" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>与上面两题类似。不过这个特别一点，特别之处是找左右子树的节点个数不同。这里不是根据根节点来找，而是根据<strong>pre[first1+1]</strong>在后序遍历序列中的位置来确定。因为这个点是当前根节点的左孩子，其在左子树的后序遍历中是最后访问的，所以找出这个位置就相当于找出了左子树的节点个数，以及右子树的节点个数。需要注意的是：这里确定边界的方法有所不同。</p>
</blockquote>
<h4 id="代码：-18"><a href="#代码：-18" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre,<span class="keyword">int</span> first1,<span class="keyword">int</span> last1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post,<span class="keyword">int</span> first2,<span class="keyword">int</span> last2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前区间不存在节点</span></span><br><span class="line">        <span class="keyword">if</span>(first1&gt;last1||first2&gt;last2)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(pre[first1]);</span><br><span class="line">        <span class="comment">//当前区间只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(first1==last1)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">int</span> pos=first2;</span><br><span class="line">        <span class="keyword">while</span>(pre[first1+<span class="number">1</span>]!=post[pos])&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算左右子树节点个数</span></span><br><span class="line">        <span class="keyword">int</span> leftsize=pos-first2+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightsize=last2-pos<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//递归生成左右子树</span></span><br><span class="line">        root-&gt;left=helper(pre,first1+<span class="number">1</span>,first1+leftsize,post,first2,pos);</span><br><span class="line">        root-&gt;right=helper(pre,first1+leftsize+<span class="number">1</span>,last1,post,pos+<span class="number">1</span>,last2<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(pre,<span class="number">0</span>,pre.<span class="built_in">size</span>()<span class="number">-1</span>,post,<span class="number">0</span>,post.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/solution/kan-wo-jiu-gou-liao-san-chong-bian-li-fang-shi-gou/">总结</a></strong></p>
<h2 id="二叉搜索树："><a href="#二叉搜索树：" class="headerlink" title="二叉搜索树："></a>二叉搜索树：</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><blockquote>
<p>二叉搜索树的特点：对于树中的每个节点X，它的左子树中所有关键字值小于X的关键字值，而它的右子树中所有关键字值大于X的关键字值。</p>
<p>根据这个性质，<strong>对一个二叉树进行中序遍历，如果是单调递增的，则可以说明这个树是二叉搜索树</strong>。</p>
</blockquote>
<h3 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a></h3><h4 id="题目描述：-14"><a href="#题目描述：-14" class="headerlink" title="题目描述："></a>题目描述：</h4><p>二叉搜索树中的两个节点被错误地交换。</p>
<p>请在不改变其结构的情况下，恢复这棵树。</p>
<p>示例 1:</p>
<p>输入: [1,3,null,null,2]</p>
<blockquote>
<p>  1<br>  /<br> 3<br>  \<br>   2</p>
</blockquote>
<p>输出: [3,1,null,null,2]</p>
<blockquote>
<p>   3<br>  /<br> 1<br>  \<br>   2</p>
</blockquote>
<p><strong>进阶:</strong></p>
<ul>
<li>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。</li>
<li>你能想出一个只使用常数空间的解决方案吗？</li>
</ul>
<h4 id="题解1："><a href="#题解1：" class="headerlink" title="题解1："></a>题解1：</h4><blockquote>
<p>先中序遍历一遍获得中序遍历序列，然后再一次中序遍历，将树的节点一一赋值即可。时间复杂度O(N)，空间复杂度O(N).</p>
</blockquote>
<h4 id="代码：-19"><a href="#代码：-19" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_route;</span><br><span class="line">    <span class="comment">//获取中序遍历序列</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_inorder_route</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        get_inorder_route(root-&gt;left);</span><br><span class="line">        inorder_route.push_back(root-&gt;val);</span><br><span class="line">        get_inorder_route(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据中序遍历序列恢复BST</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Recover_BST</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp;pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Recover_BST(root-&gt;left,pos);</span><br><span class="line">        root-&gt;val=inorder_route[++pos];</span><br><span class="line">        Recover_BST(root-&gt;right,pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        get_inorder_route(root);</span><br><span class="line">        sort(inorder_route.<span class="built_in">begin</span>(),inorder_route.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">-1</span>;</span><br><span class="line">        Recover_BST(root,pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="题解2："><a href="#题解2：" class="headerlink" title="题解2："></a>题解2：</h4><h4 id="代码：-20"><a href="#代码：-20" class="headerlink" title="代码："></a>代码：</h4><h3 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h3><h4 id="题目描述：-15"><a href="#题目描述：-15" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p>
<p>示例 1:</p>
<p>输入: </p>
<blockquote>
<p>   1<br>   / \<br>  0   2</p>
<p> L = 1</p>
<p>R = 2</p>
<p>输出:   </p>
<p>1</p>
<p>   \</p>
<p>​      2</p>
</blockquote>
<h4 id="题解：-10"><a href="#题解：-10" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>运用bst的特性用递归解决。如果当前节点的值小于L，就返回其右子树，因为其右子树的值都比这个节点的值大，如果当前节点的值大于R，就返回其左子树，因为其左子树的值都比这个节点的值小。</p>
</blockquote>
<h4 id="代码：-21"><a href="#代码：-21" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&lt;L)<span class="comment">//在范围外的左侧</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root-&gt;right,L,R);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&gt;R)<span class="comment">//在范围外的右侧</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root-&gt;left,L,R);</span><br><span class="line">        <span class="comment">//在范围内</span></span><br><span class="line">        root-&gt;left=trimBST(root-&gt;left,L,R);</span><br><span class="line">        root-&gt;right=trimBST(root-&gt;right,L,R);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="字典树：208-实现-Trie-前缀树"><a href="#字典树：208-实现-Trie-前缀树" class="headerlink" title="字典树：208. 实现 Trie (前缀树)"></a>字典树：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h3><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><blockquote>
<p>又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。<br><strong>字典树与字典很相似,当你要查一个单词是不是在字典树中,首先看单词的第一个字母是不是在字典的第一层,如果不在,说明字典树里没有该单词,如果在就在该字母的孩子节点里找是不是有单词的第二个字母,没有说明没有该单词,有的话用同样的方法继续查找.字典树不仅可以用来储存字母,也可以储存数字等其它数据。</strong></p>
</blockquote>
<h4 id="题目描述：-16"><a href="#题目描述：-16" class="headerlink" title="题目描述："></a>题目描述：</h4><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p>
<p>示例:</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = <span class="built_in">new</span> Trie();</span><br><span class="line">trie.<span class="keyword">insert</span>(&quot;apple&quot;);</span><br><span class="line">trie.<span class="keyword">search</span>(&quot;apple&quot;);   // 返回 <span class="keyword">true</span></span><br><span class="line">trie.<span class="keyword">search</span>(&quot;app&quot;);     // 返回 <span class="keyword">false</span></span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 <span class="keyword">true</span></span><br><span class="line">trie.<span class="keyword">insert</span>(&quot;app&quot;);   </span><br><span class="line">trie.<span class="keyword">search</span>(&quot;app&quot;);     // 返回 <span class="keyword">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>你可以假设所有的输入都是由小写字母 a-z 构成的。</li>
<li>保证所有输入均为非空字符串。</li>
</ul>
<h4 id="代码：-22"><a href="#代码：-22" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isval;</span><br><span class="line">    TrieNode()&#123;</span><br><span class="line">        isval=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">            child[i]=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    TrieNode* root;</span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root=<span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        TrieNode* t=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">word</span>.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!t-&gt;child[<span class="keyword">word</span>[i]-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                t-&gt;child[<span class="keyword">word</span>[i]-<span class="string">&#x27;a&#x27;</span>]=<span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[<span class="keyword">word</span>[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        t-&gt;isval=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        TrieNode* t=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">word</span>.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!t)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[<span class="keyword">word</span>[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !t?<span class="literal">false</span>:t-&gt;isval;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* t=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prefix.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!t)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[prefix[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !t?<span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="基础练习："><a href="#基础练习：" class="headerlink" title="基础练习："></a>基础练习：</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h4><p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="题解：-11"><a href="#题解：-11" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>递归应用。</p>
</blockquote>
<h4 id="代码：-23"><a href="#代码：-23" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* right=invertTree(root-&gt;left);</span><br><span class="line">        root-&gt;left=invertTree(root-&gt;right);</span><br><span class="line">        root-&gt;right=right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><h4 id="题目描述：-17"><a href="#题目描述：-17" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree <span class="number">1</span>                     Tree <span class="number">2</span>                  </span><br><span class="line">          <span class="number">1</span>                         <span class="number">2</span>                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        <span class="number">3</span>   <span class="number">2</span>                     <span class="number">1</span>   <span class="number">3</span>                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      <span class="number">5</span>                             <span class="number">4</span>   <span class="number">7</span>                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     <span class="number">3</span></span><br><span class="line">	    / \</span><br><span class="line">	   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">	  / \   \ </span><br><span class="line">	 <span class="number">5</span>   <span class="number">4</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 合并必须从两个树的根节点开始。</p>
<h4 id="题解：-12"><a href="#题解：-12" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>同样是递归。每个位置一共有三种情况：</p>
<ol>
<li>r1和r2都为空：返回NULL</li>
<li>r1、r2一个空，一个不空，返回非空那个节点</li>
<li>r1和r2都不空：将r2节点的值加到r1节点1的值，然后返回r1</li>
</ol>
</blockquote>
<h4 id="代码：-24"><a href="#代码：-24" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//情况1、2</span></span><br><span class="line">        <span class="keyword">if</span>(!t1)</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(!t2)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">//情况3</span></span><br><span class="line">        t1-&gt;val+=t2-&gt;val;</span><br><span class="line">        t1-&gt;left=mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class="line">        t1-&gt;right=mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一个树的子树</a></h3><h4 id="题目描述：-18"><a href="#题目描述：-18" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<p>示例 1:<br>给定的树 s:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>给定的树 t：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">4</span> </span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p>
<h4 id="题解：-13"><a href="#题解：-13" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>辅助函数：判断分别以两个节点为根节点的两棵树是否相同。</p>
<p>主函数：如果当前值等于子树的根节点的值，调用辅助函数，否则继续递归调用。</p>
</blockquote>
<h4 id="代码：-25"><a href="#代码：-25" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//判断分别以s和t的两棵的树是否结构相同</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* s,TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s&amp;&amp;!t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!s||!t||s-&gt;val!=t-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isSameTree(s-&gt;left,t-&gt;left)&amp;&amp;isSameTree(s-&gt;right,t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前节点值等于子树根节点t的值，调用辅助函数</span></span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val==t-&gt;val)</span><br><span class="line">            <span class="keyword">if</span>(isSameTree(s,t))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对左右子树递归调用</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(s-&gt;left,t)||isSubtree(s-&gt;right,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h3><h4 id="题目描述：-19"><a href="#题目描述：-19" class="headerlink" title="题目描述："></a>题目描述：</h4><p>计算给定二叉树的所有左叶子之和。</p>
<p>示例：</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
</code></pre><h4 id="题解：-14"><a href="#题解：-14" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>采用一个变量lor来标记是否为左孩子。</p>
</blockquote>
<h4 id="代码：-26"><a href="#代码：-26" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">leftSum</span><span class="params">(TreeNode* root,<span class="keyword">int</span> lor,<span class="keyword">int</span>&amp; sum)</span> </span>&#123;<span class="comment">//先序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lor&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right)&#123;<span class="comment">//当前节点为左叶子节点</span></span><br><span class="line">            sum+=root-&gt;val;<span class="comment">//更新sum</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        leftSum(root-&gt;left,<span class="number">1</span>,sum);</span><br><span class="line">        leftSum(root-&gt;right,<span class="number">0</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        leftSum(root-&gt;left,<span class="number">1</span>,sum);</span><br><span class="line">        leftSum(root-&gt;right,<span class="number">0</span>,sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h3><h4 id="题目描述：-20"><a href="#题目描述：-20" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，在树的最后一行找到最左边的值。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="题解1：-1"><a href="#题解1：-1" class="headerlink" title="题解1："></a>题解1：</h4><blockquote>
<p>层次遍历，用一个变量记录二叉树每行的最左边的节点的值，每遍历一行更新一次。</p>
</blockquote>
<h4 id="代码：-27"><a href="#代码：-27" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span>=q.<span class="built_in">size</span>();</span><br><span class="line">            ans=q.front()-&gt;val;<span class="comment">//更新最左边节点的值</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">size</span>--)&#123;</span><br><span class="line">                TreeNode* t=q.front();q.pop();</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="题解2：-1"><a href="#题解2：-1" class="headerlink" title="题解2："></a>题解2：</h4><blockquote>
<p>上面的解法是从左到右的遍历每一行，我们可以反过来，从右到左的遍历每一行，那么最后一个节点的值就是答案了。</p>
</blockquote>
<h4 id="代码：-28"><a href="#代码：-28" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *t=root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(t);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            t=q.front();q.pop();</span><br><span class="line">            <span class="comment">//从右到左</span></span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="题解3："><a href="#题解3：" class="headerlink" title="题解3："></a>题解3：</h4><blockquote>
<p>上面两个解法都是bfs，其实也可以用dfs来解。我们用两个变量depth、maxdepth来记录当前节点的深度，maxdepth记录已经访问过节点的最大深度，ans记录最左节点的值。maxdepth要用<strong>引用传递</strong>。只有一种情况需要改变ans：当前节点深度大于maxdepth，此时同时修改ans和maxdepth。以上都是基于一个原理：<strong>当我们先序遍历一棵二叉树，最先改变maxdepth的肯定是下一层的最左节点</strong>。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> depth,<span class="keyword">int</span> &amp;maxdepth,<span class="keyword">int</span> &amp;ans)</span> </span>&#123;<span class="comment">//dfs或先序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(depth&gt;maxdepth)&#123;<span class="comment">//需要更改ans的情况</span></span><br><span class="line">            ans=root-&gt;val;</span><br><span class="line">            maxdepth=depth;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left,depth+<span class="number">1</span>,maxdepth,ans);</span><br><span class="line">        dfs(root-&gt;right,depth+<span class="number">1</span>,maxdepth,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxdepth=<span class="number">0</span>,ans=root-&gt;val;</span><br><span class="line">        dfs(root,<span class="number">0</span>,maxdepth,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h3><h4 id="题目描述：-21"><a href="#题目描述：-21" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<p>例如：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 原始二叉搜索树:</span><br><span class="line">              <span class="number">5</span></span><br><span class="line">            /   \</span><br><span class="line">           <span class="number">2</span>     <span class="number">13</span></span><br><span class="line"></span><br><span class="line">输出: 转换为累加树:</span><br><span class="line">             <span class="number">18</span></span><br><span class="line">            /   \</span><br><span class="line">          <span class="number">20</span>     <span class="number">13</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="题解：-15"><a href="#题解：-15" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>三种情况：</p>
<ol>
<li><p>当前节点为根节点：大于根节点的值，都在其右子树，所以需要先将右子树的所有节点的值累加，再加上自身的值就是累加树根节点的值。</p>
</li>
<li><p>当前节点为右节点：大于右节点的值，都在其右子树，所以需要先将右子树的所有节点的值累加，再加上自身的值就是累加树右节点的值。</p>
<p><strong>可见：1和2可以合并</strong></p>
</li>
<li><p>当前节点为左节点：可知大于左节点的节点在除了其左子树的任何位置，基于1和2的基础上，我们此时只需将其父节点的值加上即可。</p>
</li>
</ol>
<p>其实上面三种情况可以总结为一点：每个累加树节点的值等于除了其左子树外整颗树其他节点的累加和。要计算左节点的值，首先要计算夫节点的还有右节点节点的值，这提示我们要改变遍历树的顺序：<strong>右子树 → 根 → 左子树</strong>。</p>
</blockquote>
<h4 id="代码：-29"><a href="#代码：-29" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//sum记录的是包括除了当前节点左子树的所有节点的值的累加总和</span></span><br><span class="line">            convertBST(root-&gt;right);</span><br><span class="line">            sum+=root-&gt;val;</span><br><span class="line">            root-&gt;val=sum;</span><br><span class="line">            convertBST(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="进阶练习："><a href="#进阶练习：" class="headerlink" title="进阶练习："></a>进阶练习：</h2><h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><h4 id="题目描述：-22"><a href="#题目描述：-22" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</blockquote>
<p>示例 1:</p>
<blockquote>
<p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
</blockquote>
<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<h4 id="题解：-16"><a href="#题解：-16" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>N中情况：</p>
<ol>
<li>当我们在当前节点的左右子树分别找到两个节点p、q，则p、q的最近公共祖先则是当前节点。</li>
<li>如果仅在当前节点的左子树找到p或q，则p、q最近公共祖先则是当前节点的左孩子。</li>
<li>如果仅在当前节点的右子树找到p或q，则p、q最近公共祖先则是当前节点的右孩子。</li>
<li>如果当前节点的左右子树都找不p和q，证明p和q不在树里。</li>
</ol>
<p>注意：上面的操作都是要自底向上，否则无法满足“最近”这个条件。同时，如果p和q有一个在树里，一个不在树里，这个方法行不通，但是由于题目说明p和q均在树里，所以。。。</p>
</blockquote>
<h4 id="代码：-30"><a href="#代码：-30" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root||root==p||root==q)<span class="comment">//如果当前节点就是要找的两个节点之一或者当前节点为空</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自底向上，先查找子树</span></span><br><span class="line">        TreeNode *left=lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        TreeNode *right=lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!left)<span class="comment">//在右子树中找到p和q，又或者没找到</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(!right)<span class="comment">//在左子树中找到p和q，又或者没找到</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span>(left&amp;&amp;right)<span class="comment">//p和q分布在当前节点的左右子树</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h3><h4 id="题目描述：-23"><a href="#题目描述：-23" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote>
<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
</blockquote>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<p>给定的有序链表： [-10, -3, 0, 5, 9],</p>
<p>一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</p>
<pre><code>     0
    / \
  -3   9
  /   /
 -10  5
</code></pre><h4 id="题解1：-2"><a href="#题解1：-2" class="headerlink" title="题解1："></a>题解1：</h4><blockquote>
<p>将链表转为数组，然后递归生成。由于要求树是高度平衡的，所以每次都已区间的中间点作为当前树的根节点，这样就可以确保生成的树是高度平衡的。典型的用空间换时间。</p>
</blockquote>
<h4 id="代码：-31"><a href="#代码：-31" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v,<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(v[l]);</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        TreeNode *root=<span class="keyword">new</span> TreeNode(v[mid]);</span><br><span class="line">        root-&gt;left=helper(v,l,mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=helper(v,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(;head;head=head-&gt;next)</span><br><span class="line">            v.push_back(head-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> helper(v,<span class="number">0</span>,v.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="题解2：-2"><a href="#题解2：-2" class="headerlink" title="题解2："></a>题解2：</h4><blockquote>
<p>直接在链表上递归建树，不过由于链表不能随机定位，需要一步一步找出链表的中间节点，这也是这个方法的主要耗时步骤。其实方法类似于二分查查找1.</p>
</blockquote>
<h4 id="代码：-32"><a href="#代码：-32" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(ListNode* head,ListNode *tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==tail)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *fast,*slow;</span><br><span class="line">        slow=head;fast=head;</span><br><span class="line">        <span class="comment">//快慢指针找[head,tail)范围的中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=tail&amp;&amp;fast-&gt;next!=tail)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(slow-&gt;val);</span><br><span class="line">        <span class="comment">//递归生成左右子树</span></span><br><span class="line">        root-&gt;left=buildTree(head,slow);</span><br><span class="line">        root-&gt;right=buildTree(slow-&gt;next,tail);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(head,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="897-递增顺序查找树"><a href="#897-递增顺序查找树" class="headerlink" title="897. 递增顺序查找树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序查找树</a></h3><h4 id="题目描述：-24"><a href="#题目描述：-24" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个树，请你 <strong>按中序遍历</strong> 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">    <span class="number">3</span>    <span class="number">6</span></span><br><span class="line">   / \    \</span><br><span class="line">  <span class="number">2</span>   <span class="number">4</span>    <span class="number">8</span></span><br><span class="line"> /        / \ </span><br><span class="line"><span class="number">1</span>        <span class="number">7</span>   <span class="number">9</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span></span><br><span class="line">  \</span><br><span class="line">   <span class="number">2</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">3</span></span><br><span class="line">      \</span><br><span class="line">       <span class="number">4</span></span><br><span class="line">        \</span><br><span class="line">         <span class="number">5</span></span><br><span class="line">          \</span><br><span class="line">           <span class="number">6</span></span><br><span class="line">            \</span><br><span class="line">             <span class="number">7</span></span><br><span class="line">              \</span><br><span class="line">               <span class="number">8</span></span><br><span class="line">                \</span><br><span class="line">                 <span class="number">9</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="题解：-17"><a href="#题解：-17" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>先中序遍历得到序列，然后根据序列逐个节点建树。</p>
</blockquote>
<h4 id="代码：-33"><a href="#代码：-33" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        inorder(root-&gt;left,inorder_route);</span><br><span class="line">        inorder_route.push_back(root-&gt;val);</span><br><span class="line">        inorder(root-&gt;right,inorder_route);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_route;</span><br><span class="line">        inorder(root,inorder_route);</span><br><span class="line">        TreeNode *ans=<span class="keyword">new</span> TreeNode;</span><br><span class="line">        TreeNode *finalroot=ans;</span><br><span class="line">        <span class="comment">//逐个节点建树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder_route.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            ans-&gt;right=<span class="keyword">new</span> TreeNode(inorder_route[i]);</span><br><span class="line">            ans=ans-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalroot-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="653-两数之和-IV-输入-BST"><a href="#653-两数之和-IV-输入-BST" class="headerlink" title="653. 两数之和 IV - 输入 BST"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></h4><h4 id="题目描述：-25"><a href="#题目描述：-25" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p>
<p><strong>案例 1:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> </span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">3</span>   <span class="number">6</span></span><br><span class="line"> <span class="string">/</span> <span class="string">\</span>   <span class="string">\</span></span><br><span class="line"><span class="number">2</span>   <span class="number">4</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="string">Target</span> <span class="string">=</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="string">输出:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="题解：-18"><a href="#题解：-18" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>利用bst的性质，其中序遍历序列是升序的。然后问题转化成在升序序列中查找是否存在两个值之和等于目标值的问题了。双指针解决。</p>
</blockquote>
<h4 id="代码：-34"><a href="#代码：-34" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            inorder(root-&gt;left,inorder_route);</span><br><span class="line">            inorder_route.push_back(root-&gt;val);</span><br><span class="line">            inorder(root-&gt;right,inorder_route);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_route;</span><br><span class="line">        inorder(root,inorder_route);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=inorder_route.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//双指针部分</span></span><br><span class="line">            <span class="keyword">if</span>(inorder_route[l]+inorder_route[r]&lt;k)</span><br><span class="line">                ++l;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(inorder_route[l]+inorder_route[r]&gt;k)</span><br><span class="line">                --r;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3><h4 id="题目描述：-26"><a href="#题目描述：-26" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<ol>
<li><p>首先找到需要删除的节点</p>
</li>
<li><p>如果找到了，删除它。</p>
</li>
</ol>
<p>   说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<p><strong>示例:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">root</span> <span class="string">=</span> [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>]</span><br><span class="line"><span class="string">key</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">3</span>   <span class="number">6</span></span><br><span class="line"> <span class="string">/</span> <span class="string">\</span>   <span class="string">\</span></span><br><span class="line"><span class="number">2</span>   <span class="number">4</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="string">给定需要删除的节点值是</span> <span class="number">3</span><span class="string">，所以我们首先找到</span> <span class="number">3</span> <span class="string">这个节点，然后删除它。</span></span><br><span class="line"></span><br><span class="line"><span class="string">一个正确的答案是</span> [<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>]<span class="string">,</span> <span class="string">如下图所示。</span></span><br><span class="line"></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"> <span class="string">/</span>     <span class="string">\</span></span><br><span class="line"><span class="number">2</span>       <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="string">另一个正确答案是</span> [<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>]<span class="string">。</span></span><br><span class="line"></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">6</span></span><br><span class="line">   <span class="string">\</span>   <span class="string">\</span></span><br><span class="line">    <span class="number">4</span>   <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="题解：-19"><a href="#题解：-19" class="headerlink" title="题解："></a>题解：</h4><blockquote>
<p>以下n种情况：</p>
<p>   0.当前节点为空返回NULL。</p>
<ol>
<li><p>当前节点小于目标值，对右子树递归调用。</p>
</li>
<li><p>当前节点大于目标值，对左子树递归调用。</p>
</li>
</ol>
<ol>
<li><p>当前节点等于目标值：</p>
<p>3.1.当前节点为叶子节点，直接删除当前节点，返回NULL</p>
<p>3.2.当前节点左子树为空，右子树不空，直接用当前节点的右孩子代替当前节点位置，返回root-&gt;right</p>
<p>3.3.当前节点右子树为空，左子树不空，直接用当前节点的左孩子代替当前节点位置，</p>
<p>返回root-&gt;left</p>
</li>
</ol>
<p>   3.4.当前节点左右不空，有两种选择办法：    </p>
<p>   ​    3.4.1.从左子树中找到值最大节点的位置，与交换当前节点交换值，然后对左子树                递归删除</p>
<p>   ​    3.4.2.从右子树中找到值最小节点的位置，与交换当前节点交换值，然后对右子树                递归删除</p>
</blockquote>
<h4 id="代码：-35"><a href="#代码：-35" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="comment">//情况0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;key)<span class="comment">//情况1</span></span><br><span class="line">            root-&gt;right=deleteNode(root-&gt;right,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&gt;key)<span class="comment">//情况2</span></span><br><span class="line">            root-&gt;left=deleteNode(root-&gt;left,key);</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//情况3</span></span><br><span class="line">            <span class="comment">//情况3.1</span></span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)&#123;<span class="comment">//root为叶子节点</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                root=<span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况3.3</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;right)&#123;<span class="comment">//如果root-&gt;left非空</span></span><br><span class="line">                TreeNode* t=root-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况3.2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left)&#123;</span><br><span class="line">                TreeNode* t=root-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//情况3.4</span></span><br><span class="line">                <span class="comment">//找到右子树的值最小的节点</span></span><br><span class="line">                TreeNode* temp=root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span>(temp-&gt;left)temp=temp-&gt;left；</span><br><span class="line">                swap(root-&gt;val,temp-&gt;val); <span class="comment">// 交换值</span></span><br><span class="line">                root-&gt;right=deleteNode(root-&gt;right,key); <span class="comment">// 进入遍历，删除key</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/29/bit-operate/" rel="prev" title="leetcode刷题---位运算">
      <i class="fa fa-chevron-left"></i> leetcode刷题---位运算
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/02/gcc-g-gdb/" rel="next" title="gcc、g++、gdb常用参数">
      gcc、g++、gdb常用参数 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#14-leetcode%E5%88%B7%E9%A2%98%E2%80%94-%E6%A0%91"><span class="nav-number">1.</span> <span class="nav-text">14.leetcode刷题—-树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">数据结构：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">相关题目：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%EF%BC%9A"><span class="nav-number">1.3.</span> <span class="nav-text">树的递归：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">1.3.0.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.3.1.</span> <span class="nav-text">110. 平衡二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-1"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-1"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-1"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-number">1.3.2.</span> <span class="nav-text">543. 二叉树的直径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-2"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-2"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-2"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="nav-number">1.3.3.</span> <span class="nav-text">112. 路径总和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-3"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-3"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-3"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II"><span class="nav-number">1.3.4.</span> <span class="nav-text">113. 路径总和 II</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A%EF%BC%9B"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">题目描述：；</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-4"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-4"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III"><span class="nav-number">1.3.5.</span> <span class="nav-text">437. 路径总和 III</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-4"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-5"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-5"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.3.6.</span> <span class="nav-text">101. 对称二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-6"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89%EF%BC%9A"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">题解（递归）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-6"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">代码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%88%E8%BF%AD%E4%BB%A3%EF%BC%89%EF%BC%9A%E5%8F%82%E8%80%83"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">题解（迭代）：参考</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-7"><span class="nav-number">1.3.6.5.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1110-%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97"><span class="nav-number">1.3.7.</span> <span class="nav-text">1110. 删点成林</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-7"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-5"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-8"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">代码：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="nav-number">1.4.</span> <span class="nav-text">遍历：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="nav-number">1.4.1.</span> <span class="nav-text">层次遍历：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="nav-number">1.4.2.</span> <span class="nav-text">637. 二叉树的层平均值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-8"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-6"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-9"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A%EF%BC%9B"><span class="nav-number">1.4.3.</span> <span class="nav-text">前序遍历：；</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.4.4.</span> <span class="nav-text">144. 二叉树的前序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89%EF%BC%9A-1"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">题解（递归）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-10"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">代码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%88%E8%BF%AD%E4%BB%A3%EF%BC%89%EF%BC%9A"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">题解（迭代）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-11"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="nav-number">1.4.5.</span> <span class="nav-text">中序遍历：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.4.6.</span> <span class="nav-text">94. 二叉树的中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-9"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">题解（递归）:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-12"><span class="nav-number">1.4.6.3.</span> <span class="nav-text">代码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%88%E8%BF%AD%E4%BB%A3%EF%BC%89%EF%BC%9A-1"><span class="nav-number">1.4.6.4.</span> <span class="nav-text">题解（迭代）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-13"><span class="nav-number">1.4.6.5.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="nav-number">1.4.7.</span> <span class="nav-text">后序遍历：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.4.8.</span> <span class="nav-text">145. 二叉树的后序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-10"><span class="nav-number">1.4.8.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89%EF%BC%9A-2"><span class="nav-number">1.4.8.2.</span> <span class="nav-text">题解（递归）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-14"><span class="nav-number">1.4.8.3.</span> <span class="nav-text">代码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%88%E8%BF%AD%E4%BB%A3%EF%BC%89%EF%BC%9A-2"><span class="nav-number">1.4.8.4.</span> <span class="nav-text">题解（迭代）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-15"><span class="nav-number">1.4.8.5.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E6%A0%91%EF%BC%9A"><span class="nav-number">1.4.9.</span> <span class="nav-text">根据遍历序列构造树：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.4.10.</span> <span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-11"><span class="nav-number">1.4.10.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-7"><span class="nav-number">1.4.10.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-16"><span class="nav-number">1.4.10.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.4.11.</span> <span class="nav-text">106. 从中序与后序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-12"><span class="nav-number">1.4.11.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-8"><span class="nav-number">1.4.11.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-17"><span class="nav-number">1.4.11.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#889-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.4.12.</span> <span class="nav-text">889. 根据前序和后序遍历构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-13"><span class="nav-number">1.4.12.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-9"><span class="nav-number">1.4.12.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-18"><span class="nav-number">1.4.12.3.</span> <span class="nav-text">代码：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%9A"><span class="nav-number">1.5.</span> <span class="nav-text">二叉搜索树：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-number">1.5.1.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#99-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.5.2.</span> <span class="nav-text">99. 恢复二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-14"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A31%EF%BC%9A"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">题解1：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-19"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">代码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A32%EF%BC%9A"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">题解2：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-20"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.5.3.</span> <span class="nav-text">669. 修剪二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-15"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-10"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-21"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%9A208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="nav-number">1.5.4.</span> <span class="nav-text">字典树：208. 实现 Trie (前缀树)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-1"><span class="nav-number">1.5.5.</span> <span class="nav-text">定义：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-16"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-22"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">代码：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%EF%BC%9A"><span class="nav-number">1.6.</span> <span class="nav-text">基础练习：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.6.1.</span> <span class="nav-text">226. 翻转二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">题目描述:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-11"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-23"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.6.2.</span> <span class="nav-text">617. 合并二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-17"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-12"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-24"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="nav-number">1.6.3.</span> <span class="nav-text">572. 另一个树的子树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-18"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-13"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-25"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="nav-number">1.6.4.</span> <span class="nav-text">404. 左叶子之和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-19"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-14"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-26"><span class="nav-number">1.6.4.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="nav-number">1.6.5.</span> <span class="nav-text">513. 找树左下角的值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-20"><span class="nav-number">1.6.5.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A31%EF%BC%9A-1"><span class="nav-number">1.6.5.2.</span> <span class="nav-text">题解1：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-27"><span class="nav-number">1.6.5.3.</span> <span class="nav-text">代码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A32%EF%BC%9A-1"><span class="nav-number">1.6.5.4.</span> <span class="nav-text">题解2：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-28"><span class="nav-number">1.6.5.5.</span> <span class="nav-text">代码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A33%EF%BC%9A"><span class="nav-number">1.6.5.6.</span> <span class="nav-text">题解3：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="nav-number">1.6.6.</span> <span class="nav-text">538. 把二叉搜索树转换为累加树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-21"><span class="nav-number">1.6.6.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-15"><span class="nav-number">1.6.6.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-29"><span class="nav-number">1.6.6.3.</span> <span class="nav-text">代码：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E7%BB%83%E4%B9%A0%EF%BC%9A"><span class="nav-number">1.7.</span> <span class="nav-text">进阶练习：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">1.7.1.</span> <span class="nav-text">236. 二叉树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-22"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-16"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-30"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">1.7.2.</span> <span class="nav-text">109. 有序链表转换二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-23"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A31%EF%BC%9A-2"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">题解1：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-31"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">代码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A32%EF%BC%9A-2"><span class="nav-number">1.7.2.4.</span> <span class="nav-text">题解2：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-32"><span class="nav-number">1.7.2.5.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#897-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">1.7.3.</span> <span class="nav-text">897. 递增顺序查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-24"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-17"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-33"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">代码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#653-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-IV-%E8%BE%93%E5%85%A5-BST"><span class="nav-number">1.7.3.4.</span> <span class="nav-text">653. 两数之和 IV - 输入 BST</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-25"><span class="nav-number">1.7.3.5.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-18"><span class="nav-number">1.7.3.6.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-34"><span class="nav-number">1.7.3.7.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">1.7.4.</span> <span class="nav-text">450. 删除二叉搜索树中的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0%EF%BC%9A-26"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">题目描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3%EF%BC%9A-19"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">题解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A-35"><span class="nav-number">1.7.4.3.</span> <span class="nav-text">代码：</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">JDW</p>
  <div class="site-description" itemprop="description">记录进阶之路</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jiandawei" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jiandawei" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JDW</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
