<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《图解HTTP》——读后记</title>
      <link href="/2020/11/01/Graphical-HTTP/"/>
      <url>/2020/11/01/Graphical-HTTP/</url>
      
        <content type="html"><![CDATA[<h1 id="《图解HTTP》——读后记"><a href="#《图解HTTP》——读后记" class="headerlink" title="《图解HTTP》——读后记"></a>《图解HTTP》——读后记</h1><p>[TOC]</p><h2 id="一些基础名词："><a href="#一些基础名词：" class="headerlink" title="一些基础名词："></a>一些基础名词：</h2><h3 id="HTTP-HyperText-Transfer-Protocol-超文本传输协议-："><a href="#HTTP-HyperText-Transfer-Protocol-超文本传输协议-：" class="headerlink" title="HTTP(HyperText Transfer Protocol,超文本传输协议)："></a><strong>HTTP(HyperText Transfer Protocol,超文本传输协议)：</strong></h3><blockquote><p>http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。</p></blockquote><h3 id="HTTP版本及发展阶段："><a href="#HTTP版本及发展阶段：" class="headerlink" title="HTTP版本及发展阶段："></a><strong>HTTP版本及发展阶段：</strong></h3><ul><li>0.9：0.9协议是适用于各种数据信息的简洁快速协议，但是远不能满足日益发展的各种应用的需要。0.9协议就是一个交换信息的无序协议，<strong>仅仅限于文字</strong>。</li><li>1.0:  ，HTTP/1.0成为最重要的<strong>面向事务的应用层协议</strong>。该协议对<strong>每一次请求/响应建立并拆除一次连接</strong>。其特点是简单、易于管理，所以它符合了大家的需要，得到了广泛的应用。</li><li>1.1: 在1.0协议中，<strong>双方规定了连接方式和连接类型</strong>。 </li><li>2.0: HTTP2.0的前世是HTTP1.0和HTTP1.1。但由于网络基础设施更新缓慢，HTTP2.0需要一段时间后才能广泛应用。</li></ul><h3 id="与HTTP关系密切的协议：IP、TCP和DNS："><a href="#与HTTP关系密切的协议：IP、TCP和DNS：" class="headerlink" title="与HTTP关系密切的协议：IP、TCP和DNS："></a><strong>与HTTP关系密切的协议：IP、TCP和DNS：</strong></h3><ul><li>负责传输的IP协议</li><li>确保可靠性的TCP协议</li><li>负责域名解析的DNS服务</li></ul><h3 id="报文主体和实体主体："><a href="#报文主体和实体主体：" class="headerlink" title="报文主体和实体主体："></a><strong>报文主体和实体主体：</strong></h3><ul><li><p>报文：</p><p>是HTTP通信中的基本单位，由字节流组成，通过HTTP通信传输。</p></li><li><p>实体：</p><p>作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。</p></li></ul><p><code>HTTP报文主体用于传输请求或响应的实体主体。</code></p><p><code>通常，报文主体等同于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致两者有所不同。</code></p><h3 id="URI和URL："><a href="#URI和URL：" class="headerlink" title="URI和URL："></a><strong>URI和URL：</strong></h3><blockquote><p>URI(Uniform Resource Identifier，统一资源标识符)是某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。<strong>URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置）。可见URL是URI的子集。</strong>在充分理解的基础上，可以用URL来代替URI。</p></blockquote><p>URI格式：</p><blockquote><p>格式： http:<em>//user:pass@www.example.com:80/home/index.html?age=11#mask</em></p></blockquote><ul><li><p>http：协议方案名  </p></li><li><p>user:pass：登录信息（认证）</p></li><li><p>www.ample.com：服务器地址</p></li><li><p>80：端口号 </p></li><li><p>/hone/index.html：文件路径 </p></li><li><p>age=11：查询字符串</p></li><li><p>mask：片段标识符 </p></li></ul><ul><li><p>协议方案名： </p><p>http:、https:、ftp:等，在获取资源时要指定协议类型。</p></li><li><p>登录信息(认证)：</p><p>指定用户名和密码作为从服务器端获取资源时必要的登录信息，此项是可选的。</p></li><li><p>服务器地址：</p><p> 使用绝对URI必须指定待访问的服务器地址。</p></li><li><p>服务器端口号：</p><p>指定服务器连接的网络端口号，此项是可选的。</p></li><li><p>路径：</p><p>指定服务器上的文件路径来定位特定资源。格式为: /home/index.html </p></li><li><p>参数： </p><p>为应用程序提供访问资源所需的附加信息。 例如：ftp:<em>//127.27.27.27/pub/pic;type=d</em></p></li><li><p>查询字符串：</p><p> 针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数，此项是可选的。</p></li><li><p>片段标识符：</p><p>通常可标记出以获取资源中的子资源(文档内的某一个位置)，此项是可选的。</p></li></ul><h3 id="HTTP是不保存状态的协议："><a href="#HTTP是不保存状态的协议：" class="headerlink" title="HTTP是不保存状态的协议："></a><strong>HTTP是不保存状态的协议：</strong></h3><blockquote><p>为了简化协议以及降低协议通信成本，HTTP协议自身不对请求和响应之间的通信状态进行保存。</p></blockquote><h3 id="持久连接："><a href="#持久连接：" class="headerlink" title="持久连接："></a><strong>持久连接：</strong></h3><blockquote><p>HTTP的初始版本种，每进行一次HTTP通信就要断开一次TCP连接。为了减少TCP连接建立和断开的次数，有了<strong>持久连接</strong>的方法：只要任意一端没有明确提出断开连接，则保持TCP连接状态。</p></blockquote><h3 id="管线化："><a href="#管线化：" class="headerlink" title="管线化："></a><strong>管线化：</strong></h3><blockquote><p>持久连接使得管线化成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。<strong>管线化技术出现后，不用等待响应亦可发送下一个请求。</strong></p></blockquote><h3 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a><strong>Cookie：</strong></h3><blockquote><p>前面说到HTTP协议是无状态协议。而Cookie技术就是在有需要的地方来<strong>保存状态</strong>。</p><p>Cookie技术通在请求和响应报文中写入Cookie信息来控制客户端的状态。</p></blockquote><p>当第一次服务器发送请求时，发送以下请求报文（没有Cookie信息的状态）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/reader/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: hackr.jp</span><br><span class="line">*首部没有Cooki的相关信息</span><br></pre></td></tr></table></figure><p>服务器响应（服务器生成Cookie信息）：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line">Date Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache</span><br><span class="line">&lt;set-Cookie: sid=131325235325; path=/; expires=Wed, 10-Oct-12 07:12:20 GMT&gt;</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain; charset=UTF-8</span><br></pre></td></tr></table></figure><p>当客户端再次向相同的服务器发送请求（自动发送保存着Cookie信息）：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/reader/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: hackr.jp</span><br><span class="line"><span class="attribute">Cookie</span>: sid=131325235325</span><br></pre></td></tr></table></figure><h3 id="通信数据转发程序：代理、网关、隧道"><a href="#通信数据转发程序：代理、网关、隧道" class="headerlink" title="通信数据转发程序：代理、网关、隧道"></a>通信数据转发程序：代理、网关、隧道</h3><ul><li><p><strong>代理</strong>： </p><p>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。代理又分为<strong>缓存代理</strong>和<strong>透明代理</strong>。代理转发响应时，<strong>缓存代理</strong>会预先将资源的副本保存在代理服务器上。当代理接收到对相同资源的请求时，就可以不从服务器那里获取资源，而不是将之前缓存的资源作为响应返回。转发响应或请求时，不对报文做任何加工的代理类型被称为<strong>透明代理</strong>。</p></li><li><p><strong>网关</strong>：</p><p>网关是转发其他服务器通信数据的服务器，接收从客户端发送过来的请求时，它就像自己拥有资源的服务器一样对请求进行处理。</p></li><li><p><strong>隧道</strong>：</p><p>隧道是在客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。其目的就是确保客户端和服务器进行安全的通信。</p></li></ul><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文:"></a>HTTP报文:</h2><p><code>HTTP协议是用于客户端和服务器之间的通信。HTTP报文一般分为 HTTP请求报文 和 HTTP响应报文。</code></p><h3 id="HTTP报文结构："><a href="#HTTP报文结构：" class="headerlink" title="HTTP报文结构："></a>HTTP报文结构：</h3><blockquote><p>HTTP报文大致可以分为报文首部和报文主体两块。两者由最初出现的空行来划分。通常，不一定有报文主体。</p></blockquote><p><img src="/2020/11/01/Graphical-HTTP/Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20201101092026152.png" alt="image-20201101092026152" style="zoom:67%;"></p><h4 id="HTTP请求报文结构："><a href="#HTTP请求报文结构：" class="headerlink" title="HTTP请求报文结构："></a>HTTP请求报文结构：</h4><p><img src="/2020/11/01/Graphical-HTTP/HTTP请求报文结构.png" alt="HTTP请求报文结构"></p><p>（其中，请求行和请求头部是属于报文首部部分的）</p><p><img src="/2020/11/01/Graphical-HTTP/Users\lenovo\Desktop\20160921092902556.jpg" style="zoom: 67%;"></p><h4 id="HTTP响应报文结构："><a href="#HTTP响应报文结构：" class="headerlink" title="HTTP响应报文结构："></a>HTTP响应报文结构：</h4><p><img src="/2020/11/01/Graphical-HTTP/Users\lenovo\Desktop\20180828215835558.png" style="zoom: 67%;"></p><p><img src="/2020/11/01/Graphical-HTTP/HTTP报文结构.png" alt="HTTP报文结构"></p><h3 id="HTTP状态码："><a href="#HTTP状态码：" class="headerlink" title="HTTP状态码："></a>HTTP状态码：</h3><p><code>状态码告知从服务器端返回的请求结果。</code></p><h4 id="状态码汇总："><a href="#状态码汇总：" class="headerlink" title="状态码汇总："></a>状态码汇总：</h4><p><img src="/2020/11/01/Graphical-HTTP/状态码汇总.png" alt="状态码汇总"></p><h4 id="常用的状态码："><a href="#常用的状态码：" class="headerlink" title="常用的状态码："></a><strong>常用的状态码</strong>：</h4><blockquote><p>200 OK 服务器成功处理了请求（这个是我们见到最多的）</p><p>204 No Content 请求成功处理，没有实体的主体返回</p><p>206 Partial Content GET范围请求已成功处理</p><p>301/302 Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置</p><p>303 See Other 临时重定向，期望使用GET定向获取</p><p>304 Not Modified 发送的附带条件请求未满足</p><p>307 Temporary Redirect 临时重定向，POST不会变成GET</p><p>400 Bad Request 请求报文语法错误或参数错误</p><p>401 Unauthorized 需要通过HTTP认证，或认证失败</p><p>403 Forbidden 请求资源被拒绝</p><p>404 Not Found(页面丢失)未找到资源</p><p>500 Internal Server Error 服务器故障或Web应用故障</p><p>501 Internal Server Error服务器遇到一个错误，使其无法对请求提供服务</p><p>503 Service Unavailable 服务器超负载或停机维护</p></blockquote><ul><li><strong>1开头 （请求已被接受，需要继续处理）这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。</strong></li></ul><blockquote><p>100 （部分接受） 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。  </p><p> 101 （已了解） 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。 </p><p> 102 （已接收） 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p></blockquote><ul><li><h4 id="2开头-（请求成功）表示成功处理了请求的状态代码。"><a href="#2开头-（请求成功）表示成功处理了请求的状态代码。" class="headerlink" title="2开头 （请求成功）表示成功处理了请求的状态代码。"></a><strong>2开头 （请求成功）表示成功处理了请求的状态代码。</strong></h4></li></ul><blockquote><p>200  （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201  （已创建） 请求成功并且服务器创建了新的资源。<br>202  （已接受） 服务器已接受请求，但尚未处理。<br>203  （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204  （无内容） 服务器成功处理了请求，但没有返回任何内容。<br>205  （重置内容） 服务器成功处理了请求，但没有返回任何内容。</p><p>206  （部分内容） 服务器成功处理了部分 GET 请求。</p></blockquote><ul><li><strong>3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</strong></li></ul><blockquote><p>300  （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301  （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302  （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303  （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304  （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305  （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307  （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p></blockquote><ul><li><strong>4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</strong></li></ul><blockquote><p>400  （错误请求） 服务器不理解请求的语法。<br>401  （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403  （禁止） 服务器拒绝请求。<br>404  （未找到） 服务器找不到请求的网页。<br>405  （方法禁用） 禁用请求中指定的方法。<br>406  （不接受） 无法使用请求的内容特性响应请求的网页。<br>407  （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408  （请求超时） 服务器等候请求时发生超时。<br>409  （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410  （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。<br>411  （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412  （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413  （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414  （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415  （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416  （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417  （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p></blockquote><ul><li><strong>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</strong></li></ul><blockquote><p>500  （服务器内部错误） 服务器遇到错误，无法完成请求。<br>501  （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502  （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503  （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504  （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505  （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p></blockquote><h3 id="HTTP请求方法："><a href="#HTTP请求方法：" class="headerlink" title="HTTP请求方法："></a>HTTP请求方法：</h3><ul><li><p>GET：</p><blockquote><p><strong>GET方法用来请求已被URI识别的资源。</strong></p><font color="red">请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：</font></blockquote><p><strong>请求：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/test/demo_form.asp?name1=value1&amp;name2=value2</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: w3schools.com </span><br></pre></td></tr></table></figure><p><strong>响应：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回页面内容</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>POST:</p><blockquote><p><strong>POST方法用来传输实体的主体。</strong></p><font color="red">请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</font></blockquote><p><strong>请求：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/test/demo_form.asp</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: w3schools.com </span><br><span class="line">  #(空行CR+LF)</span><br><span class="line">name1=value1&amp;name2=value2  #(主体)</span><br></pre></td></tr></table></figure><p><strong>响应：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回/test/demo_form.asp接收数据的处理结果</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>PUT：</p><blockquote><p>PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求报文的主体种包含文件内容，然后保存到请求URI指定的位置。</p></blockquote><p><strong>请求：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/example.html</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: w3schools.com </span><br><span class="line"><span class="attribute">Content-Type</span>: text/html</span><br><span class="line"><span class="attribute">Content-Length</span>:  1560</span><br></pre></td></tr></table></figure><p><strong>响应：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">响应返回状态码204No Content</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>HEAD：</p><blockquote><p>HEAD方法和GET方法一样，只是不返回报文主体部分。<strong>用于确认URI的有效性及资源更新的日期时间等</strong>。</p></blockquote><p><strong>请求：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="string">/index.html</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: w3schools.com</span><br></pre></td></tr></table></figure><p><strong>响应：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回index.html有关的响应头部</span><br></pre></td></tr></table></figure></li></ul><ul><li>DELETE:</li></ul><blockquote><p>DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法按照请求URI删除指定的资源。</p></blockquote><p><strong>请求：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="string">/example。html</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: w3schools.com</span><br></pre></td></tr></table></figure><p><strong>响应：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">响应返回状态码204No Content（比如：该html文件已从该服务器删除）</span><br></pre></td></tr></table></figure><ul><li>OPTIONS：</li></ul><blockquote><p>OPTIONS方法用来查询针对请求URI指定的资源支持的方法。</p></blockquote><p><strong>请求：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS * HTPP/1.1</span><br><span class="line"><span class="attribute">Host</span>: w3schools.com </span><br></pre></td></tr></table></figure><p><strong>响应：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Allow</span>: GET,POST,HEAD,OPTIONS(返回服务器支持的方法)</span><br></pre></td></tr></table></figure><ul><li>CONNECT：</li></ul><blockquote><p>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS。</p></blockquote><p><strong>请求：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="string">w3schools.com:8080</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: w3schools.com</span><br></pre></td></tr></table></figure><p><strong>响应：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line">(之后进入网络隧道)</span><br></pre></td></tr></table></figure><ul><li>TRACE：</li></ul><blockquote><p>TRACE方法是让Web服务器将之前的请求通信环回给客户端。具体工作流程与tracert(windows)或trace(linux)大致类似。请求和响应报文略。</p></blockquote><h3 id="HTTP首部字段："><a href="#HTTP首部字段：" class="headerlink" title="HTTP首部字段："></a>HTTP首部字段：</h3><h4 id="通用首部字段："><a href="#通用首部字段：" class="headerlink" title="通用首部字段："></a><strong>通用首部字段：</strong></h4><p><img src="/2020/11/01/Graphical-HTTP/Users\lenovo\Desktop\通用首部字段.png" alt="通用首部字段"></p><h4 id="请求首部字段："><a href="#请求首部字段：" class="headerlink" title="请求首部字段："></a><strong>请求首部字段：</strong></h4><p><img src="/2020/11/01/Graphical-HTTP/请求首部字段.png" alt="请求首部字段"></p><h4 id="响应首部字段："><a href="#响应首部字段：" class="headerlink" title="响应首部字段："></a><strong>响应首部字段：</strong></h4><p><img src="/2020/11/01/Graphical-HTTP/响应首部字段.png" alt="响应首部字段"></p><h4 id="实体首部字段："><a href="#实体首部字段：" class="headerlink" title="实体首部字段："></a><strong>实体首部字段：</strong></h4><p><img src="/2020/11/01/Graphical-HTTP/实体首部字段.png" alt="实体首部字段"></p><h2 id="HTTPS："><a href="#HTTPS：" class="headerlink" title="HTTPS："></a><strong>HTTPS</strong>：</h2><p>待续……….</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective STL</title>
      <link href="/2020/10/26/Effective-STL/"/>
      <url>/2020/10/26/Effective-STL/</url>
      
        <content type="html"><![CDATA[<h1 id="Effective-STL"><a href="#Effective-STL" class="headerlink" title="Effective STL"></a>Effective STL</h1><h2 id="第1条：慎重选择容器类型"><a href="#第1条：慎重选择容器类型" class="headerlink" title="第1条：慎重选择容器类型"></a>第1条：慎重选择容器类型</h2><ul><li>标准STL序列容器：vector、string、deque、list</li><li>标准STL关联容器：set、multiset、map、multimap</li><li>非标准序列容器：slist（单向链表）、rope（“重型”string）</li><li>非标准关联容器：hash_set、hash_multiset、hash_map、hash_multimap</li><li>标准的非STL容器：数组、bitset、valarray、stack、queue、priority_queue</li></ul><h3 id="连续内存容器："><a href="#连续内存容器：" class="headerlink" title="连续内存容器："></a>连续内存容器：</h3><blockquote><p>(也称为基于数组的容器)，把它的元素存放在一块或多块内存中，每次新添或删除元素都需要将其他元素移动，这种移动影响效率和异常安全性。</p><p>例如vector、string、deque、rope都是连续内存容器。</p></blockquote><h3 id="基于节点的容器："><a href="#基于节点的容器：" class="headerlink" title="基于节点的容器："></a>基于节点的容器：</h3><blockquote><p>它在每一个动态分配的内存中只存一个元素。容器增删元素只会影响到指向节点的指针，并不影响节点的内容，不需要移动其他元素。</p><p>例如list、slist以及所有标准的关联容器都是基于节点的容器。</p></blockquote><h3 id="一些通常需要考虑的问题："><a href="#一些通常需要考虑的问题：" class="headerlink" title="一些通常需要考虑的问题："></a>一些通常需要考虑的问题：</h3><ul><li>是否需要在容器的任何位置擦插入元素</li></ul><p>如果需要，选择序列容器</p><ul><li>是否关心容器的元素是排序的</li></ul><p>如果需要，请勿选择哈希容器</p><ul><li>需要哪种迭代器</li></ul><p>随机访问迭代器就请选择vector、string和deque；…….</p><ul><li>是否需要和C兼容</li></ul><p>只能选择vector</p><ul><li>是否介意使用了引用计数技术</li></ul><p>如果介意，避免使用string</p><ul><li>对插入和删除操作，是否需要事务语义（即插入和删除操作失败后，是否需要回滚能力）</li></ul><p>如果需要，只能选择list（只有list提供了事务语义）</p><ul><li>是否要将迭代器、指针、引用变为无效的次数降到最小</li></ul><p>如果要，则请使用基于节点的容器</p><h2 id="第2条：不要试图编写独立于容器类型的代码"><a href="#第2条：不要试图编写独立于容器类型的代码" class="headerlink" title="第2条：不要试图编写独立于容器类型的代码"></a>第2条：不要试图编写独立于容器类型的代码</h2><blockquote><p>其实每个容器的就是为了不同的问题而设计的，如果我们编写的代码是独立于容器类型的话，这必将会牺牲许多容器特有的功能，使得容器工作效率大打折扣，得不偿失。</p></blockquote><h2 id="第3条：确保容器中的对象拷贝正确且高效"><a href="#第3条：确保容器中的对象拷贝正确且高效" class="headerlink" title="第3条：确保容器中的对象拷贝正确且高效"></a>第3条：确保容器中的对象拷贝正确且高效</h2><p><code>首先我们需要直到，容器中保存的对象并不是我们提供给容器的对象，而是这些对象的拷贝。</code></p><blockquote><p>一旦一个对象被保存到容器中，它经常会进一步被拷贝。例如插入删除操作以及一些算法，这些操作都需要通过对象移动（拷贝）来实现。其中拷贝动作是通过<strong>拷贝构造函数</strong>和<strong>拷贝赋值操作符</strong>完成的。</p></blockquote><h3 id="性能问题："><a href="#性能问题：" class="headerlink" title="性能问题："></a>性能问题：</h3><p>如果我们容器里装的是对象，且对象的拷贝操作很费时费力，此时我们的一些操作的效率将会大大降低。</p><h3 id="正确性问题："><a href="#正确性问题：" class="headerlink" title="正确性问题："></a>正确性问题：</h3><p>如果我们的容器装的是某个基类，而当我们插入一个派生类对象时，此时派生类对象特有的部分将会被舍弃，只保留基类的那部分，这种现象称为“剥离”。</p><blockquote><p>此时有一个简单的解决方法，就是把指针存入容器而不是对象。拷贝指针的速度很快，但是指针容器又有一些令人头疼的问题。所以，智能指针容器是个不错的选择！</p></blockquote><h2 id="第4条：调用empty而不是检查size-是否为0"><a href="#第4条：调用empty而不是检查size-是否为0" class="headerlink" title="第4条：调用empty而不是检查size()是否为0"></a>第4条：调用empty而不是检查size()是否为0</h2><p>理由很简单：empty对于所有的标准容器都是常数时间操作，而对于一些list实现，size需要线性时间。</p><h2 id="第5条：区间成员函数由于与之对应的单元素函数"><a href="#第5条：区间成员函数由于与之对应的单元素函数" class="headerlink" title="第5条：区间成员函数由于与之对应的单元素函数"></a>第5条：区间成员函数由于与之对应的单元素函数</h2><p>何谓区间成员函数？</p><blockquote><p>区间成员函数是指这样一类成员函数，它们像STL算法一样，使用两个迭代器参数来确定该成员操作所执行的区间。</p></blockquote><p>而本条款的主要目的是：</p><blockquote><p>倡导尽量用区间成员函数取代替写显式的循环。</p></blockquote><p>下面是四种常见的情况：</p><ul><li><strong>区间创建</strong>：所有的标准容器都提供了如下形式的构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container::container(InputIterator <span class="built_in">begin</span>, InputIterator <span class="built_in">end</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>区间插入</strong>：所有的标准序列容器都提供了如下形式的insert</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">container::insert</span><span class="params">(iterator <span class="built_in">position</span>, InputIterator <span class="built_in">begin</span>, InputIterator <span class="built_in">end</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>而关联容器利用比较函数来确定插入位置，从而省略掉一个position参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">container::insert</span><span class="params">(InputIterator <span class="built_in">begin</span>, InputIterator <span class="built_in">end</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>区间删除</strong>：所有的标准序列容器提供了如下形式的erase</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">container::erase</span><span class="params">(iterator <span class="built_in">begin</span>, iterator <span class="built_in">end</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>关联容器提供如下形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">container::erase</span><span class="params">(iterator <span class="built_in">begin</span>, iterator <span class="built_in">end</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>区间赋值</strong>：所有的标准容器都提供了如下形式的assign</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">container::assign</span><span class="params">(InputIterator <span class="built_in">begin</span>, InputIterator <span class="built_in">end</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="第6条：当心c-编译器最烦人的分析机制："><a href="#第6条：当心c-编译器最烦人的分析机制：" class="headerlink" title="第6条：当心c++编译器最烦人的分析机制："></a>第6条：当心c++编译器最烦人的分析机制：</h2><p>假设我们有一个存有整数的文件，想把这些整数复制到一个list中去。我们可能会写出以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">dataFile</span><span class="params">(<span class="string">&quot;ints.data&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">data</span><span class="params">(istream_iterator&lt;<span class="keyword">int</span>&gt;(dataFile), istream_iterator&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br></pre></td></tr></table></figure><p><strong>但是结果并不如你所愿！</strong></p><p>首先来介绍一些基础知识：</p><p>以下三种方式都完成了同样一件事情：声明一个带double参数并返回int的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> d)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> (d))</span></span>;<span class="comment">/*d两边的括号会被忽略*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> )</span></span>;   <span class="comment">/*参数名被省略*/</span></span><br></pre></td></tr></table></figure><p>以下三种方式又都完成了同样一件事情：声明一个函数g，它的参数是一个指向不带参数的函数的指针，该函数返回double：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">double</span> (*pf)())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">double</span> pf())</span></span>;<span class="comment">/*pf为隐式指针*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">double</span> ())</span></span>;  <span class="comment">/*省去参数名*/</span></span><br></pre></td></tr></table></figure><p>此时我们再来分析开头的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">dataFile</span><span class="params">(<span class="string">&quot;ints.data&quot;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">data</span><span class="params">(istream_iterator&lt;<span class="keyword">int</span>&gt;(dataFile), istream_iterator&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br></pre></td></tr></table></figure><p>这里只是声明了一个函数，其中istream_iterator<int>(dataFile)是一个变量就好像int f(double (d));    /<em>d两边的括号会被忽略</em>/；</int></p><p>istream_iterator<int>()是一个函数，返回类型是istream_iterator<int>()，不带参数。</int></int></p><h2 id="第7条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构之前将指针delete掉"><a href="#第7条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构之前将指针delete掉" class="headerlink" title="第7条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构之前将指针delete掉"></a>第7条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构之前将指针delete掉</h2><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Widget*&gt; vwp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOME_MAGIC_NUMBER; ++i)</span><br><span class="line">    vwp.push_back(<span class="keyword">new</span> Widget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当离开函数后，vwp中所有的元素都被析构，但是并没有delete掉new出来的对象。</p><p>而我们可以通过以下三种方法来delete掉new出来的对象：</p><ul><li><strong>在容器析构前用for循环对容器中的元素逐个delete</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Widget*&gt; vwp;</span><br><span class="line">    ........................................   <span class="comment">//同上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = vwp.<span class="built_in">begin</span>(); i != vwp.<span class="built_in">end</span>(); ++i)</span><br><span class="line">    <span class="keyword">delete</span> *i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果，在省略号代表的部分代码处出现异常抛出，同样会导致new出来的对象无法被delete掉</p><ul><li><strong>用for_each循环来代替显示for循环</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeletObject</span> :</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">const</span> T*, <span class="keyword">void</span>&gt;&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> T* ptr)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ........................................   <span class="comment">//同上</span></span><br><span class="line">for_each(vwp.<span class="built_in">begin</span>(), vwp.<span class="built_in">end</span>(), DeleteObject&lt;Widget&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样需要指明DeleteObject要删除的对象类型，通过以下方法来避免这种麻烦：只需将DeleteObject改变一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeletObject</span>&#123;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> T* ptr)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ........................................   <span class="comment">//同上</span></span><br><span class="line">for_each(vwp.<span class="built_in">begin</span>(), vwp.<span class="built_in">end</span>(), DeleteObject()); <span class="comment">//这样就不用指明对象类型了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用智能指针，可以避免种种麻烦</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> boost::<span class="built_in">shared_ptr</span>&lt;Widget&gt; SPW;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;SPW&gt; vwp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SOME_MAGIC_NUMBER; ++i)</span><br><span class="line">    vwp.push_back(SPW(<span class="keyword">new</span> Widget));</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><h2 id="第8条：切勿创建包含auto-ptr的容器对象"><a href="#第8条：切勿创建包含auto-ptr的容器对象" class="headerlink" title="第8条：切勿创建包含auto_ptr的容器对象"></a>第8条：切勿创建包含auto_ptr的容器对象</h2><blockquote><p>这一条不用说了，因为现在直接禁用了auto_ptr.</p></blockquote><p>至于原因可以说一下：</p><p>先看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;Widget&gt; <span class="title">pw1</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;<span class="comment">/*创建pw1指向一个Widget*/</span></span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;Widget&gt; <span class="title">pw2</span><span class="params">(pw1)</span></span>;<span class="comment">/*pw2指向pw1的Widget，pw1被置为NULL*/</span></span><br><span class="line"></span><br><span class="line">pw1 = pw2；   <span class="comment">/*pw1又指向pw2的Widget，pw2为NULL*/</span></span><br></pre></td></tr></table></figure><p>根据上面的例子，我们来分析一个环境，当我们需要使用到<strong>条款3</strong>所提及到的一些算法时，装有auto_ptr的容器就需要同拷贝来完成工作，这样一来，可能会造成容器中的多个auto_ptr被设置为NULL。</p><p><strong>总而言之：不要用auto_ptr!</strong></p><h2 id="第9条：慎重选择删除元素的方法"><a href="#第9条：慎重选择删除元素的方法" class="headerlink" title="第9条：慎重选择删除元素的方法"></a>第9条：慎重选择删除元素的方法</h2><blockquote><ul><li><p><strong>要删除容器中所有的特定值的所有对象：</strong><br>如果容器是vector、string和deque，则使用erase-remove习惯用法</p><p>如果容器是list，则使用list::remove</p><p>如果容器是标准关联容器，则使用它的erase成员函数</p></li><li><p><strong>要删除容器满足特定判别式的所有对象：</strong></p><p>如果容器是vector、string和deque，则使用erase-remove习惯用法</p><p>如果容器是list，则使用list::remove_if</p><p>如果容器是标准关联容器，则使用它的remove_if和swap成员函数，或者使用一个循环来遍历容器中的元素，逐个删除</p></li><li><p><strong>要在循环内做某些操作</strong>：</p><p>如果容器是一个标准序列容器，则写一个循环来遍历容器的元素，记住每次调用erase时，要用它的返回值更新迭代器</p><p>如果容器是一个标准关联容器，则写一个循环来遍历容器的元素，记住把迭代器传给erase时，要对迭代器做后缀递增</p></li></ul></blockquote><h2 id="第10条：了解分配子（allocator）的约定和限制"><a href="#第10条：了解分配子（allocator）的约定和限制" class="headerlink" title="第10条：了解分配子（allocator）的约定和限制"></a>第10条：了解分配子（allocator）的约定和限制</h2><p>略。</p><h2 id="第11条：理解自定义分配子的合理用法"><a href="#第11条：理解自定义分配子的合理用法" class="headerlink" title="第11条：理解自定义分配子的合理用法"></a>第11条：理解自定义分配子的合理用法</h2><p>略。</p><h2 id="第12条：切勿对STL容器的线程安全性有不切实际的依赖"><a href="#第12条：切勿对STL容器的线程安全性有不切实际的依赖" class="headerlink" title="第12条：切勿对STL容器的线程安全性有不切实际的依赖"></a>第12条：切勿对STL容器的线程安全性有不切实际的依赖</h2><p>概括来说：对于一个STL容器来说，你最多只能期望：</p><ul><li>多个线程读是安全的</li><li>对个线程对不同的容器做写入操作是安全的</li></ul><p>以上只是你期望，并不意味着所有的STL实现都会这样做。</p><p><strong>我们能做的就是用锁来保证线程安全性。</strong></p><h2 id="第13条：vector和string优于动态分配的数组"><a href="#第13条：vector和string优于动态分配的数组" class="headerlink" title="第13条：vector和string优于动态分配的数组"></a>第13条：vector和string优于动态分配的数组</h2><blockquote><p>原因很简单使用动态分配数组需要自己来释放内存，而vector和string则自动回收所分配的内存。</p><p>如果是new出来的数组，需要做到以下几点：</p><ol><li>确保以后有人用delete来删除所分配的内存</li><li>确保正确使用了delete的形式</li><li>确保只delete了一次</li></ol></blockquote><h2 id="第14条：使用reverse来避免不必要的重新分配"><a href="#第14条：使用reverse来避免不必要的重新分配" class="headerlink" title="第14条：使用reverse来避免不必要的重新分配"></a>第14条：使用reverse来避免不必要的重新分配</h2><p>我们首先以vector和string为例子，它们的空间增长过程是这样的：</p><ol><li>分配一块大小为当前容量的两倍的内存</li><li>把容器所有的元素复制到新内存中</li><li>析构旧内存的对象</li><li>释放旧内存</li></ol><p><strong>很显然，这些步骤都十分耗时。</strong></p><p>在标准容器中，只有vector和string提供了以下四个函数：</p><ol><li>size() 告诉你容器中多少个元素</li><li>capacity() 告诉你容器利用已经分配的内存可以容纳多少个元素</li><li>resize(Container :: size_type n) 强迫容器改变到包含n个元素的状态。如果n小于原来的元素个数，则将多出的元素析构；如果n大于原来的元素个数，则通过默认构造函数创建新元素添加到容器中。</li><li>reverse(Container :: size_type n) 强迫将容器的容量改变为至少是n，前提n是不小于当前元素个数。</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)v.push_back(i);</span><br></pre></td></tr></table></figure><p>对于大多数STL实现，该循环将导致2到10次重新分配。</p><p>如果我们事先使用reverse，则不会导致内存重新分配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.reverse(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)v.push_back(i);</span><br></pre></td></tr></table></figure><h2 id="第15条：注意string实现的多样性"><a href="#第15条：注意string实现的多样性" class="headerlink" title="第15条：注意string实现的多样性"></a>第15条：注意string实现的多样性</h2><p>略。</p><h2 id="第16条：了解如何把vector和string数据传给旧的API"><a href="#第16条：了解如何把vector和string数据传给旧的API" class="headerlink" title="第16条：了解如何把vector和string数据传给旧的API"></a>第16条：了解如何把vector和string数据传给旧的API</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector:"></a>vector:</h3><p>vector就是C中的数组，当所有以数组为参数，都可以用vector代替，反之不成立。</p><blockquote><p>vector&lt; int &gt; v(100, 0);</p><p>v[0]代表第一个元素的引用，&amp;v[0]代表指向第一个元素的指针，就好像int a[0]的a一样。</p></blockquote><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomeThing</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* pInts, <span class="keyword">size_t</span> numInts)</span></span>;</span><br><span class="line">DoSomeThing(&amp;v[<span class="number">0</span>], v.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure><p>有一个问题就是：如果v中没有元素，则&amp;v[0]不合法。所以需要在用之前判断v是否包含元素。</p><h3 id="string："><a href="#string：" class="headerlink" title="string："></a>string：</h3><p>所有以C类型的字符串都可以用c_str函数返回的字符串来代替。</p><blockquote><p>首先我们要知道：（1）、string中的数据不一定存储在连续的内存中；（2）、string的内部表示不一定是以空字符结尾的</p><p>而string的成员函数c_str函数返回一个指向字符串的指针，而且该指针可以用于C。</p></blockquote><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomeThing</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pString)</span></span>;</span><br><span class="line">DoSomeThing(s.c_str());</span><br></pre></td></tr></table></figure><h2 id="第17条：使用“swap技巧”除去多余的容量"><a href="#第17条：使用“swap技巧”除去多余的容量" class="headerlink" title="第17条：使用“swap技巧”除去多余的容量"></a>第17条：使用“swap技巧”除去多余的容量</h2><p>本条款要完成的目标：“shrink to fit”（将容量压缩至适当大小）</p><p>当我们有一个包含1000元素的vector content，但后来删除了900个元素，但所分配的内存并未被释放。如果我们仅仅需要容器中有包含100个元素的内存就足够的话，则需要将剩余的内存释放掉，我们可以通过以下代码来完成工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (content).swap(content);</span><br></pre></td></tr></table></figure><p>vector&lt; int &gt;(content)创建一个临时向量，它是content的拷贝，且分配的内存仅仅够存放拷贝而来的元素。换句话说，没有多余的内存。swap交换两个容器的内容，content获得了临时变量的内容，而临时变量获得了content的内容。因为是临时变量，这句代码过后就会释放它所分配的内存。</p><p><strong>同样，string也可以有相应的操作。</strong></p><h2 id="第18条：避免使用vector-lt-bool-gt"><a href="#第18条：避免使用vector-lt-bool-gt" class="headerlink" title="第18条：避免使用vector &lt; bool &gt;"></a>第18条：避免使用vector &lt; bool &gt;</h2><p>vector&lt; bool &gt;不是一个STL容器，其次，它并不存储bool，而是存储bool的紧凑表示。在一些典型实现中，vector中的每个bool只占一个二进制位.</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> *p1 = &amp;v[<span class="number">0</span>];<span class="comment">/*不能创建指向单个位的指针*/</span></span><br><span class="line"><span class="keyword">bool</span> *p2 = v[<span class="number">0</span>]; <span class="comment">/*不能创建指向单个位的引用*/</span></span><br></pre></td></tr></table></figure><p><strong>vector&lt; bool &gt;可以由dequeue&lt; bool &gt;、bitset代替。</strong></p><h2 id="第19条：理解相等-equality-和等价-equivalence-的区别"><a href="#第19条：理解相等-equality-和等价-equivalence-的区别" class="headerlink" title="第19条：理解相等(equality)和等价(equivalence)的区别"></a>第19条：理解相等(equality)和等价(equivalence)的区别</h2><p>在STL中，对两个对象进行比较，看它们的值是否相同，像这样的操作随处可见。例如find必须能够比较两个对象，看一个对象的值是否等于另一个对象的值；当使用set::insert时，必须能够缺点该元素是否已经在该set中；………</p><p>find对“相同”的定义是<strong>相等</strong>，是以<strong>operator==</strong>为基础的。</p><p>set::insert对“相同”的定义是<strong>等价</strong>，是以<strong>operator &lt;</strong>为基础的。</p><h3 id="相等："><a href="#相等：" class="headerlink" title="相等："></a>相等：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> lhs == rhs;</span><br></pre></td></tr></table></figure><h3 id="等价："><a href="#等价：" class="headerlink" title="等价："></a>等价：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> !(lhs &lt; rhs) &amp;&amp; !(rhs &lt; lhs);</span><br></pre></td></tr></table></figure><p>在一般情况下，一个关联容器的比较函数并不是operator &lt;，甚至不是less，它是用户自定义的判别式。</p><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CISringCompare</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="built_in">string</span>, <span class="built_in">string</span>, <span class="keyword">bool</span>&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">( )</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;lhs, <span class="keyword">const</span> <span class="built_in">string</span> &amp;rhs)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ciStringCompare(lhs, rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>, CIStringCompare&gt; ciss;</span><br></pre></td></tr></table></figure><h2 id="第20条：为包含指针的关联容器指定比较类型"><a href="#第20条：为包含指针的关联容器指定比较类型" class="headerlink" title="第20条：为包含指针的关联容器指定比较类型"></a>第20条：为包含指针的关联容器指定比较类型</h2><p>假设有一个包含string指针的set</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*&gt; ssp;</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;apple&quot;</span>));</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;banana&quot;</span>));</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;pear&quot;</span>));</span><br><span class="line">ssp.insert(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;peach&quot;</span>));</span><br></pre></td></tr></table></figure><p>写了以下代码，期望字符串安装字母顺序输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p : ssp)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;**p&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//*p是string*，**p是string</span></span><br></pre></td></tr></table></figure><p>但是结果并不如你所愿，set中排序并不是按照字母顺序的，而是按照string指针顺序来排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*&gt; ssp;</span><br><span class="line"><span class="comment">//其实是如下代码的缩写</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*, less&lt;<span class="built_in">string</span>*&gt;&gt; ssp;</span><br></pre></td></tr></table></figure><p>所以我们需要指定比较类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringPtrLess</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">bool</span>&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">( )</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> *ps1, <span class="keyword">const</span> <span class="built_in">string</span> *ps2)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *ps1 &lt; *ps2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>*, StringPtrLess&gt; ssp;</span><br></pre></td></tr></table></figure><blockquote><p>每当要创建包含指针的关联容器时，一定要记住，容器将会按照指针的值进行排序。绝大多数情况下，这不会是你所希望的，所以需要创建自己的函数子类来作为该容器的比较类型。并我们不能只是简单的写一个比较函数，因为set模板的三个参数每一个都是类型，传递一个函数给set模板是无法通过编译的。</p></blockquote><h2 id="第21条：总是让比较函数在等值的情况下返回false"><a href="#第21条：总是让比较函数在等值的情况下返回false" class="headerlink" title="第21条：总是让比较函数在等值的情况下返回false"></a>第21条：总是让比较函数在等值的情况下返回false</h2><p>创建一个set，用less_equal作为它的比较类型，然后把10插入到该集合中去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, less_equal&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">s.insert(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>当我们在执行一遍<strong>s.insert(10)</strong>时，会出现意想不到的事情。</p><p>按我们的尝试，s中只会有一个10，但是，实际上s中有两个10。原因是（由条款19可知，set::insert是的“相同”是基于等价的）。</p><p>当将第二个10插入之前，会进行如下比较</p><p>!(10 &lt;= 10) &amp;&amp; !(10 &lt;= 10)   =====    false &amp;&amp; false</p><p>也就是说两个10不等价，从而不相同。</p><p>就例如，条款20中的string指针比较类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringPtrLess</span> :</span> <span class="keyword">public</span> binary_function&lt;<span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">const</span> <span class="built_in">string</span>*, <span class="keyword">bool</span>&gt;&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">( )</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> *ps1, <span class="keyword">const</span> <span class="built_in">string</span> *ps2)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *ps1 &lt; *ps2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的思想是，通过比较函数内部的测试取反来改变排序顺序</span></span><br><span class="line"><span class="keyword">return</span> !(*ps1 &lt; *ps2);<span class="comment">//错误的，这样得到的是 “ &gt;= ”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *ps2 &lt; *ps1;    <span class="comment">//正确的，这样得到的是“ &gt; ”</span></span><br></pre></td></tr></table></figure><h2 id="第22条：切勿直接修改set或multiset的键"><a href="#第22条：切勿直接修改set或multiset的键" class="headerlink" title="第22条：切勿直接修改set或multiset的键"></a>第22条：切勿直接修改set或multiset的键</h2><p>先叙述一下原因：如果把关联容器中一个元素的值改变了，那么，新的值可能不在正确的位置上，这将打破关联容器的有序性。</p><p>对于map和multimap尤其简单，因为对于一个map&lt; k, v &gt; 或者 multimap&lt; k, v &gt;，其中的元素类型是pair<const k, v>,因为键的类型是const k，所以它不能修改。 </const></p><p>而对于set&lt; T &gt;或者multiset&lt; T &gt;，容器中元素的类型是T，而不是const T。所以set或者multiset的元素可以随便修改的。</p><p>下面给出一个例子：</p><blockquote><p>假设我们有一个存有员工信息的set，员工信息结构体包含员工的ID、名字、住址……。我们给set指定的比较类型是基于员工ID号的，所以说除了ID号外，我们改变结构体里的其他成员都不会破坏set的有序性。</p></blockquote><p><strong>总之，如果我们改变了set或multiset中的元素，请记住，一定不要改变键部分——元素的这部分信息会影响容器的排序性。至于其余部分，任意修改。</strong></p><p>如果实在要改变set或multiset元素的键，需要做以下工作：</p><blockquote><ol><li>先将要修改的元素拷贝出来</li><li>在新元素进行修改</li><li>在容器中删除旧元素</li><li>在容器中插入新元素</li></ol></blockquote><h2 id="第23条：考虑用排序的vector替代关联容器"><a href="#第23条：考虑用排序的vector替代关联容器" class="headerlink" title="第23条：考虑用排序的vector替代关联容器"></a>第23条：考虑用排序的vector替代关联容器</h2><p><code>一个容器通常的使用阶段有：</code></p><ol><li><strong>设置阶段</strong>：创建一个新的数据结构，并插入大量元素。在这个阶段，几乎所有的操作都是插入和删除操作。很少或几乎没有查找操作。</li><li><strong>查找阶段</strong>：查询该数据结构以找到特定的信息。在这个阶段，几乎所有的操作都是查找操作。很少或几乎没有插入和删除操作。</li><li><strong>重组阶段</strong>：改变数据结构的内容，或许是删除所有的当前数据，再插入新的数据。在行为上与设置阶段类似。</li></ol><h3 id="我们有两个充分的理由让你考虑用排序的vector替代关联容器"><a href="#我们有两个充分的理由让你考虑用排序的vector替代关联容器" class="headerlink" title="我们有两个充分的理由让你考虑用排序的vector替代关联容器"></a>我们有两个充分的理由让你考虑用排序的vector替代关联容器</h3><ul><li><blockquote><p>空间大小问题：假定我们有一个容器用来装载Widget对象，vector需要装载的内容就是Widget对象本身，并存储于连续内存中，；由于标准关联容器一般都是平衡二叉树来实现的，所以存储的对象并不是放在连续的内存，同时还要包含大量的指针域来指向这些对象。这是vector相对于关联容器的优势之一。</p></blockquote></li><li><blockquote><p>时间效率问题：由于关联容器所存储的对象不是位于连续内存中的，当要访问这些对象时，很有可能需要<strong>跨页</strong>访问，页面读取耗费一定的时间。而vector是基于连续内存存储对象的，访问对象并不会耗费太多的时间。</p></blockquote></li></ul><h3 id="下面给出两个排序的vector代替关联容器的例子："><a href="#下面给出两个排序的vector代替关联容器的例子：" class="headerlink" title="下面给出两个排序的vector代替关联容器的例子："></a>下面给出两个排序的vector代替关联容器的例子：</h3><h4 id="代替set"><a href="#代替set" class="headerlink" title="代替set"></a>代替set</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Widget&gt; vw；<span class="comment">/*设置阶段*/</span></span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">sort(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>());     <span class="comment">/*设置阶段结束*/</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="keyword">if</span>(binary_search(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>()))<span class="comment">/*查找阶段*/</span></span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">    </span><br><span class="line"> <span class="built_in">vector</span>&lt;Widget&gt;::iterator i = lower_bound(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span>(i != vw.<span class="built_in">end</span>()) &amp;&amp; !(w &lt; *i) <span class="comment">/*查找阶段结束*/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> sort(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>()); <span class="comment">/*开始新的查找阶段*/</span></span><br></pre></td></tr></table></figure><h4 id="代替map"><a href="#代替map" class="headerlink" title="代替map"></a>代替map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; Data;<span class="comment">/*本例子用于存储在map的类型*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataCompare</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> Data&amp; lhs, <span class="keyword">const</span> Data&amp; rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="comment">/*用于排序的比较函数*/</span></span><br><span class="line">        <span class="keyword">return</span> KeyLess(lhs.first, rhs.first);</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> Data&amp; lhs, <span class="keyword">const</span> Data::first_type&amp; k)</span> <span class="keyword">const</span> </span>&#123;<span class="comment">/*用于查找的比较函数，形式1*/</span></span><br><span class="line">        <span class="keyword">return</span> KeyLess(lhs.first, k);</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> Data::first_type&amp; k, <span class="keyword">const</span> Data&amp; rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="comment">/*用于查找的比较函数，形式2*/</span></span><br><span class="line">        <span class="keyword">return</span> KeyLess(k, lhs.first);</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">KeyLess</span><span class="params">(<span class="keyword">const</span> Data::first_type &amp;k1, <span class="keyword">const</span> Data::first_type &amp;k2)</span> <span class="keyword">const</span></span>&#123; <span class="comment">/*实际的比较函数*/</span></span><br><span class="line">        <span class="keyword">return</span> k1 &lt; k2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Data&gt; vd;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">sort(vd.<span class="built_in">begin</span>(), vd.<span class="built_in">end</span>());<span class="comment">/*设置阶段*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line"><span class="keyword">if</span>(binary_search(vd.<span class="built_in">begin</span>(), vd.<span class="built_in">end</span>(), s, DataCompare()))......<span class="comment">/*查找阶段*/</span></span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    。。。。。。。。</span><br></pre></td></tr></table></figure><h2 id="第24条：当效率至关重要时，请在map-operator-与map-insert之间谨慎做出选择"><a href="#第24条：当效率至关重要时，请在map-operator-与map-insert之间谨慎做出选择" class="headerlink" title="第24条：当效率至关重要时，请在map::operator[]与map::insert之间谨慎做出选择"></a>第24条：当效率至关重要时，请在map::operator[]与map::insert之间谨慎做出选择</h2><h3 id="map-operator-的设计目的是为了提供“添加和更新”的功能。"><a href="#map-operator-的设计目的是为了提供“添加和更新”的功能。" class="headerlink" title="map::operator[]的设计目的是为了提供“添加和更新”的功能。"></a>map::operator[]的设计目的是为了提供“添加和更新”的功能。</h3><p>例如：</p><p>map<k, v> m;</k,></p><p>表达式</p><p>m[k] = v;</p><p>检测键k是否已经在map中。如果没有，它就加入，并以v作为相应的值；如果k已经存在，则与之关联的值被更新为v。</p><p>具体来说：如果k已存在的话：operator[]返回一个引用，它指向与k相关联的值对象。然后v被赋给该引用。</p><p>​                      如果k不存在的话：operator[]使用值类型的默认构造函数创建一个新的对象，然后operator[]就能返回一个指向该新对象的引用了。</p><p>用一个例子来将上面的过程具体化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">m[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*以上代码功能等同于下面的代码*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; IntToInt;</span><br><span class="line"><span class="built_in">pair</span>&lt;IntToInt::iterator, <span class="keyword">bool</span>&gt; result = m.insert(IntToInt::value_type(<span class="number">1</span>, <span class="keyword">int</span>()));</span><br><span class="line">result.first-&gt;second = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*以上代代码又等价于以下代码*/</span></span><br><span class="line">m.insert(IntToInt::value_type(<span class="number">1</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>可见，operator[]通常比map::insert更加耗时。</p><p><strong>概括来说：更新用operator[];添加用map::insert;如果不知道键是否已经是否存在，则用operator[]</strong></p><h2 id="第25条：熟悉非标准的散列容器"><a href="#第25条：熟悉非标准的散列容器" class="headerlink" title="第25条：熟悉非标准的散列容器"></a>第25条：熟悉非标准的散列容器</h2><p>略。</p><h2 id="第26条：iterator优先于const-iterator、reverse-iterator及const-reverse-iterator"><a href="#第26条：iterator优先于const-iterator、reverse-iterator及const-reverse-iterator" class="headerlink" title="第26条：iterator优先于const_iterator、reverse_iterator及const_reverse_iterator"></a>第26条：iterator优先于const_iterator、reverse_iterator及const_reverse_iterator</h2><p>对于容器类Container&lt; T &gt;而言：</p><ul><li>iterator功效相当于T*</li><li>const_iterator相当于const T*</li><li>reverse_iterator相当于T*，不过递增方向是由容器尾反向遍历到容器头部。</li><li>const_reverse_iterator相当于T*，不过递增方向是由容器尾反向遍历到容器头部。</li></ul><p>首先来看一下vector&lt; T &gt;容器中insert和erase函数的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator <span class="built_in">position</span>, <span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator <span class="built_in">position</span>)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator rangeBegin, iterator rangeEnd)</span></span>;</span><br></pre></td></tr></table></figure><p>其实每个标准容器都提供了类似的函数，只不过返回值可能有所不同，但是参数类型都是一致的：iterator类型。显然iterator比其他四种迭代其受用更广。</p><h2 id="第27条：使用distance和advance将容器的const-iterator转换成iterator"><a href="#第27条：使用distance和advance将容器的const-iterator转换成iterator" class="headerlink" title="第27条：使用distance和advance将容器的const_iterator转换成iterator"></a>第27条：使用distance和advance将容器的const_iterator转换成iterator</h2><p>由条款26可知，我们通常需要iterator多于const_iterator。这条款就是将const_iterator转换成iterator。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; IntDeque;</span><br><span class="line"><span class="keyword">typedef</span> IntDeque::iterator Iter;</span><br><span class="line"><span class="keyword">typedef</span> IntDeque::const_iterator ConstIter;</span><br><span class="line"></span><br><span class="line">IntDeque d;</span><br><span class="line">ConstIter ci;</span><br><span class="line"><span class="function">Iter <span class="title">i</span><span class="params">(d.<span class="built_in">begin</span>())</span></span>;</span><br><span class="line">advance(i, distance(i, ci));</span><br></pre></td></tr></table></figure><p>但是以上代码不能通过编译，原因：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type</span><br><span class="line">distance(InputIterator frist, InputIterator second);</span><br><span class="line"></span><br><span class="line"><span class="comment">//i是iterator，而ci是const_iterator。而InputIterator不能同时代表两种不同的类型</span></span><br></pre></td></tr></table></figure><p>所以可以显式指明distance所使用的参数类型，从而避免让编译器来推断该类型的参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">advance(i, distance&lt;ConstIter&gt;(i, ci));</span><br></pre></td></tr></table></figure><p>这种转换可能需要线性时间，并且需要访问const_iterator所属的容器。</p><h2 id="第28条：正确理解有reverse-iterator的base-成员函数所产生的iterator的用法"><a href="#第28条：正确理解有reverse-iterator的base-成员函数所产生的iterator的用法" class="headerlink" title="第28条：正确理解有reverse_iterator的base()成员函数所产生的iterator的用法"></a>第28条：正确理解有reverse_iterator的base()成员函数所产生的iterator的用法</h2><p>略。</p><h2 id="第29条：对于逐个字符的输入请考虑使用istreambuf-iterator"><a href="#第29条：对于逐个字符的输入请考虑使用istreambuf-iterator" class="headerlink" title="第29条：对于逐个字符的输入请考虑使用istreambuf_iterator"></a>第29条：对于逐个字符的输入请考虑使用istreambuf_iterator</h2><p>略。</p><h2 id="第30条：确保目标区间足够大"><a href="#第30条：确保目标区间足够大" class="headerlink" title="第30条：确保目标区间足够大"></a>第30条：确保目标区间足够大</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line">transform(values.<span class="built_in">begin</span>(),  values.<span class="built_in">end</span>(), results.<span class="built_in">end</span>(), transmogrify);</span><br><span class="line"><span class="comment">/*将values中的每个值都通过transmogrify作用，然后追加到results的末尾*/</span></span><br></pre></td></tr></table></figure><p>但是上面的代码有一个错误：首先，transform首先以valuse[0]为参数调用transmogrify，并将结果传给*results.end()，后面的元素以此类推。</p><p>不过，results.end()并没有对象，更何况results.end()+1.</p><p>所以需要通过调用back_inserter生成一个迭代器来指定目标区间的起始位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line">transform(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), back_inserter(results), transmogrify);</span><br></pre></td></tr></table></figure><p>总之：如果所使用的释放需要指定一个目标区间，请确保目标区间足够大，或者请确保它会随着释放的运行而增大。要在算法执行过程增大目标区间，请使用<strong>插入型迭代器</strong>，比如back_inserter、front_inserter和inserter等等。如果是对vector和string而言，可以先调用reverse来提高效率。</p><h2 id="第31条：了解各种与排序有关的选择"><a href="#第31条：了解各种与排序有关的选择" class="headerlink" title="第31条：了解各种与排序有关的选择"></a>第31条：了解各种与排序有关的选择</h2><blockquote><ul><li>如果需要对vector、string、deque或者数组中的元素执行一次完全排序，那么可以使用sort或者stable_sort。</li><li>如果有一个vector、string、deque或者数组，并且只需要对的等价性最前面的n个元素进行排序，那么可以使用partial_sort。</li><li>如果有一个vector、string、deque或者数组，并且只需要找到第n个位置上的元素，或者，需要找到等价性最前面的n个元素但又不必对这n个元素进行排序，那么，nth_element正是你需要的函数。</li><li>如果需要将一个标准序列容器中的元素按照是否满足某个特定的条件区分开来，那么partion和stable_partion正可能是你需要的</li><li>如果你的数据在一个list中，那么你仍然可以使用partion和stable_partion算法：可以用list::sort来代替partion和stable_partion算法</li></ul></blockquote><h2 id="第32条：如果确实需要删除元素，则需要在remove这一类算法之后调用erase"><a href="#第32条：如果确实需要删除元素，则需要在remove这一类算法之后调用erase" class="headerlink" title="第32条：如果确实需要删除元素，则需要在remove这一类算法之后调用erase"></a>第32条：如果确实需要删除元素，则需要在remove这一类算法之后调用erase</h2><p>下面是remove的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">templat&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span> <span class="title">remove</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">ForwardIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>);</span></span><br></pre></td></tr></table></figure><blockquote><p>remove也需要一对迭代器来指定所要进行操作的元素区间。并不接受容器作为参数，所以remove并不知道这些元素放在哪个容器中。就是说**remove不可从容器中删除元素，而容器中的元素数目也不会因此减少。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.reverse(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)v.push_back(i);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//输出10</span></span><br><span class="line"></span><br><span class="line">v[<span class="number">0</span>] = v[<span class="number">2</span>] = v[<span class="number">4</span>] = <span class="number">99</span>;</span><br><span class="line"><span class="built_in">remove</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">99</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//仍然输出10</span></span><br></pre></td></tr></table></figure><p>请记住这句话：<strong>remove不是真正意义上的删除，因为它做不到。</strong></p><p>因为remove不知道所操作的元素在哪个容器中。如果不知道容器，remove就不可能调用它的成员函数来完成真正的删除功能。</p><p>简而言之：就是将不用删除的元素移动到区间的前面。它的返回的一个迭代器指向最后一个“不用被删除”的元素之后的元素。</p><p>所以要想真正的删除向量中的99，要这样做</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.erase(<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">99</span>), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="第33条：对包含指针的容器使用remove这一类算法要特别小心"><a href="#第33条：对包含指针的容器使用remove这一类算法要特别小心" class="headerlink" title="第33条：对包含指针的容器使用remove这一类算法要特别小心"></a>第33条：对包含指针的容器使用remove这一类算法要特别小心</h2><p>假设我们拥有一个装有动态分配的Widget指针的容器，需要将其中一些不合格的去除掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span> : </span><br><span class="line">    ........</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCertified</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">.......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Widget*&gt; v;</span><br><span class="line">........</span><br><span class="line">v.push_back(<span class="keyword">new</span> Widget);</span><br><span class="line">........</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*删除掉不合格的Widget*/</span></span><br><span class="line">v.erase(remove_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), not1(mem_fun(&amp;Widget::isCertified))), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>经过erase后，会发现内存泄露。指向合格的Widget的指针分布在向量的前部，后那些指针也是指向合格的Widget，所以哪些不合格的Widget没有指针指向，导致没有delete掉new出来的对象。</p><p>我们可以先将那些不合格的Widget的指针删除并置空，然后清除容器的所有空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delAndNullifyUncertified</span><span class="params">(Widegt*&amp; pWidget)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!pWidget-&gt;isCertified())&#123;</span><br><span class="line">        <span class="keyword">delete</span> pWidget;</span><br><span class="line">        pWidget = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), delAndNullifyUncertified));</span><br><span class="line"></span><br><span class="line">v.erase(<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="keyword">static_cast</span>&lt;Widget*&gt;(<span class="number">0</span>)), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>我们还可以使用智能指针，直接使用erase-remove习惯用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCSP</span>&#123;</span>...&#125;;<span class="comment">/*具有引用计数功能的智能指针 Reference Counting Smart Pointer*/</span></span><br><span class="line"><span class="keyword">typedef</span> RCSP&lt;Widget&gt; RCSPW;</span><br><span class="line"><span class="built_in">vector</span>&lt;RCSPW&gt; V;</span><br><span class="line">....</span><br><span class="line">v.push_back(RCSPW(<span class="keyword">new</span> Widget()));</span><br><span class="line">...</span><br><span class="line">v.erase(remove_if(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), not1(mem_fun(&amp;Widget::isCertified))), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="第34条：了解哪些算法要求使用排序的区间作为参数"><a href="#第34条：了解哪些算法要求使用排序的区间作为参数" class="headerlink" title="第34条：了解哪些算法要求使用排序的区间作为参数"></a>第34条：了解哪些算法要求使用排序的区间作为参数</h2><p>本条款的意思是某些算法是要在有序的区间才能运行或者效率更高。</p><p>必须要求传入区间是有序区间的算法有：</p><ul><li>binary_search</li><li>lower_bound</li><li>upper_bound</li><li>equal_range</li><li>set_union</li><li>set_intersection</li><li>set_difference</li><li>set_symmetric_difference</li><li>merge</li><li>inplace_merge</li><li>includes</li></ul><p><strong>何谓“一个区间被排序了？”</strong></p><p>这个区间经过默认的比较类型或你自定义的比较类型排序，然而这些算法都是使用默认比较类型进行比较，所以当你自定义了比较类型并使用它用来排序，你在使用以上算法时也要指定自定义的比较类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">/*默认是less&lt;int&gt;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag = binary_search(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>); <span class="comment">/*默认是less&lt;int&gt;*/</span></span><br><span class="line"><span class="comment">/*正确方式*/</span></span><br><span class="line"><span class="keyword">bool</span> flag = binary_search(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>, greater&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure><h2 id="第35条：通过mismatch或lexicographical-compare实现简单的忽略大小写的字符串比较"><a href="#第35条：通过mismatch或lexicographical-compare实现简单的忽略大小写的字符串比较" class="headerlink" title="第35条：通过mismatch或lexicographical_compare实现简单的忽略大小写的字符串比较"></a>第35条：通过mismatch或lexicographical_compare实现简单的忽略大小写的字符串比较</h2><h2 id="第36条：理解copy-if算法的正确实现"><a href="#第36条：理解copy-if算法的正确实现" class="headerlink" title="第36条：理解copy_if算法的正确实现"></a>第36条：理解copy_if算法的正确实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> Predicate&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">copy_if</span><span class="params">(InputIterator <span class="built_in">begin</span>, InputIterator <span class="built_in">end</span>, OutputIterator destBegin, Predicate P)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">begin</span> != <span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p(*<span class="built_in">begin</span>))*destBegin++ = *<span class="built_in">begin</span>;</span><br><span class="line">        ++<span class="built_in">begin</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> destBegin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第37条：使用accumulate或者for-each进行区间统计"><a href="#第37条：使用accumulate或者for-each进行区间统计" class="headerlink" title="第37条：使用accumulate或者for_each进行区间统计"></a>第37条：使用accumulate或者for_each进行区间统计</h2><p>略。</p><h2 id="第38条：遵循按值传递的原则来设计函数子类"><a href="#第38条：遵循按值传递的原则来设计函数子类" class="headerlink" title="第38条：遵循按值传递的原则来设计函数子类"></a>第38条：遵循按值传递的原则来设计函数子类</h2><p>开门见山地说：在c和c++的标准库函数都遵循这一规则：函数指针是按值传递的</p><p>STL函数对象是函数指针的一种抽象和建模形式，所以，按照惯例，在STL中，函数对象在函数之间来回传递的时候也是<strong>按值传递</strong>的。</p><p>所以当我们设计函数子类时，要明确知道这一点。</p><h2 id="第39条：确定判别式是“纯函数”"><a href="#第39条：确定判别式是“纯函数”" class="headerlink" title="第39条：确定判别式是“纯函数”"></a>第39条：确定判别式是“纯函数”</h2><p>首先介绍三个概念：</p><ul><li><strong>判别式</strong>：是一个返回类型为bool类型的函数</li><li><strong>纯函数</strong>：是指函数返回值仅仅依赖于其参数的函数。</li><li><strong>判别式类</strong>：是一个函数子类，它的operator()函数是一个判别式，也就是说它的operator()返回bool类型</li></ul><p>总而言之：确定函数子类中的比较函数是<strong>纯函数</strong>，这是因为函数对象在STL中是按值传递的。</p><h2 id="第40条：若一个子类是函数子，则应使它可配接"><a href="#第40条：若一个子类是函数子，则应使它可配接" class="headerlink" title="第40条：若一个子类是函数子，则应使它可配接"></a>第40条：若一个子类是函数子，则应使它可配接</h2><p>略。</p><h2 id="第41条：理解ptr-fun、mem-fun和mem-fun-ref的来由"><a href="#第41条：理解ptr-fun、mem-fun和mem-fun-ref的来由" class="headerlink" title="第41条：理解ptr_fun、mem_fun和mem_fun_ref的来由"></a>第41条：理解ptr_fun、mem_fun和mem_fun_ref的来由</h2><p>如果有一个函数f和一个对象x，现在希望在x上调用f，而我们<strong>在x的成员函数之外</strong>，那么为了执行这个调用，c++有提供了三种不同的语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(x);<span class="comment">/*#语法1：f是一个非成员函数*/</span></span><br><span class="line"></span><br><span class="line">x.f();<span class="comment">/*#语法2：f是成员函数，并且x是一个对象或者是对象的引用*/</span></span><br><span class="line"></span><br><span class="line">p-&gt;f(); <span class="comment">/*f是成员函数，并且p是一个指向对象的指针*/</span></span><br></pre></td></tr></table></figure><p>假设现在有一个可用于测试Widget对象的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> Widget&amp; w)</span></span>;</span><br></pre></td></tr></table></figure><p>另有一个存放Widget对象的容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Widget&gt; vw;</span><br></pre></td></tr></table></figure><p>为了测试每个对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(), test);<span class="comment">/*调用#1,：可以通过编译*/</span></span><br></pre></td></tr></table></figure><p>但是，如果test是Widget的成员函数的话，再次调用for_each来完成测试工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(), &amp;Widget::test);<span class="comment">/*调用#2,：不能通过编译*/</span></span><br></pre></td></tr></table></figure><p>如果一个容器存放的是Widget的指针，再来调用for_each看看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;Widget*&gt; lpw;</span><br><span class="line">for_each(lpw.<span class="built_in">begin</span>(), lpw.<span class="built_in">end</span>(), &amp;Widget::test);<span class="comment">/*调用#3,：不能通过编译*/</span></span><br></pre></td></tr></table></figure><p>我们首先来看一下，for_each算法的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Function&gt;</span><br><span class="line"><span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator <span class="built_in">begin</span>, InputIterator <span class="built_in">end</span>, Function f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">begin</span> != <span class="built_in">end</span>)</span><br><span class="line">        f(*<span class="built_in">begin</span>++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很明显的表明：“for_each”是基于调用实现的。这是STL中一种很普遍的惯例：<strong>函数或函数对象在被调用时，总是使用非成员函数的语法形式</strong>。所以2和3调用不能通过编译，此时，就需要mem_fun和mem_fun_ref.</p><p>调用2可以改成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(), ptr_fun(&amp;Widget::test));<span class="comment">/*调用#2,：可以通过编译*/</span></span><br></pre></td></tr></table></figure><p>调用3可以改成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;Widget*&gt; lpw;</span><br><span class="line">for_each(lpw.<span class="built_in">begin</span>(), lpw.<span class="built_in">end</span>(), mem_fun(&amp;Widget::test);<span class="comment">/*调用#3,：可以通过编译*/</span></span><br></pre></td></tr></table></figure><h2 id="第42条：确保less-lt-T-gt-与operator-lt-具有相同的语义"><a href="#第42条：确保less-lt-T-gt-与operator-lt-具有相同的语义" class="headerlink" title="第42条：确保less&lt; T &gt;与operator &lt; 具有相同的语义"></a>第42条：确保less&lt; T &gt;与operator &lt; 具有相同的语义</h2><blockquote><p>在STL中，less&lt; T &gt;默认使用operator &lt; .当我们使用了less，无论是显式的或是隐式的，都需要确保它与operator &lt; 具有相同的意义。</p></blockquote><h2 id="第43条：算法调用优先手写的循环"><a href="#第43条：算法调用优先手写的循环" class="headerlink" title="第43条：算法调用优先手写的循环"></a>第43条：算法调用优先手写的循环</h2><blockquote><p>理由有三：</p><ul><li>效率：算法通常比自己写的循环效率更高</li><li>正确性：自己写的循环比算法更容易出错</li><li>可维护性：使用算法的代码通常比手写的代码更加简洁</li></ul></blockquote><h2 id="第44条：容器的成员函数优于同名的算法"><a href="#第44条：容器的成员函数优于同名的算法" class="headerlink" title="第44条：容器的成员函数优于同名的算法"></a>第44条：容器的成员函数优于同名的算法</h2><p>有些STL容器提供了一些与算法同名的成员函数。比如，关联容器提供了count、find、lower_bound和equal_range,而list则提供了remove、remove_if、unique、sort、merge和reverse。</p><blockquote><p>大多数情况下，应该使用这些成员函数，而不是相应的STL算法。有两个理由：</p><ol><li>成员函数往往速度更快</li><li>成员函数通常与容器结合更紧密</li></ol></blockquote><h2 id="第45条：正确区分count、find、binary-search、lower-bound、upper-bound和equal-range"><a href="#第45条：正确区分count、find、binary-search、lower-bound、upper-bound和equal-range" class="headerlink" title="第45条：正确区分count、find、binary_search、lower_bound、upper_bound和equal_range"></a>第45条：正确区分count、find、binary_search、lower_bound、upper_bound和equal_range</h2><p>直接给出结论：</p><div class="table-container"><table><thead><tr><th>想知道什么</th><th>使用算法</th><th>使用成员函数</th></tr></thead><tbody><tr><td>特定的值存在吗？</td><td>对于未排序区间：find  对排序区间：binary_search</td><td>对set或者map：count 对multiset或者multimap：find</td></tr><tr><td>特定的值存在吗？如果存在，那第一个有该值的对象在哪里</td><td>对于未排序区间：find  对排序区间：equal_range</td><td>对set或者map：find 对multiset或者multimap：lower_bound</td></tr><tr><td>第一个不超过特定值的对象在哪里</td><td>对于未排序区间：find_if  对排序区间：lower_bound</td><td>对set或者map：lower_bound 对multiset或者multimap：lower_bound</td></tr><tr><td>第一个在某个特定值之后的对象在哪里</td><td>对于未排序区间：find_if  对排序区间：upper_bound</td><td>对set或者map：upper_bound 对multiset或者multimap：upper_bound</td></tr><tr><td>具有特定值的对象有多少个</td><td>对于未排序区间：count  对排序区间：equal_range(然后distance)</td><td>对set或者map：count 对multiset或者multimap：count</td></tr><tr><td>具有特定值的对象在哪里</td><td>对于未排序区间：find  对排序区间：equal_range</td><td>对set或者map：equal_range 对multiset或者multimap：equal_range</td></tr></tbody></table></div><h2 id="第46条：考虑使用函数对象而不是函数作为STL算法的参数"><a href="#第46条：考虑使用函数对象而不是函数作为STL算法的参数" class="headerlink" title="第46条：考虑使用函数对象而不是函数作为STL算法的参数"></a>第46条：考虑使用函数对象而不是函数作为STL算法的参数</h2><p>略。</p><h2 id="第47条：避免产生“直写型”的代码"><a href="#第47条：避免产生“直写型”的代码" class="headerlink" title="第47条：避免产生“直写型”的代码"></a>第47条：避免产生“直写型”的代码</h2><p><strong>不要为了省几行代码而直接将很多的内容塞在一两行中。就是不要写一些很难读懂的代码</strong></p><h2 id="第48条：总是包含-include-正确的头文件"><a href="#第48条：总是包含-include-正确的头文件" class="headerlink" title="第48条：总是包含(#include)正确的头文件"></a>第48条：总是包含(#include)正确的头文件</h2><p><strong>有些STL平台会默认包含某些头文件，但是为了代码的移植性，需要将用到的所有头文件都包含。</strong></p><h2 id="第49条：学会分析与STL相关的编译器诊断信息"><a href="#第49条：学会分析与STL相关的编译器诊断信息" class="headerlink" title="第49条：学会分析与STL相关的编译器诊断信息"></a>第49条：学会分析与STL相关的编译器诊断信息</h2><p>略。</p><h2 id="第50条：熟悉与STL相关的Web站点"><a href="#第50条：熟悉与STL相关的Web站点" class="headerlink" title="第50条：熟悉与STL相关的Web站点"></a>第50条：熟悉与STL相关的Web站点</h2><p><a href="http://www.sgi.com/tech/stl/">SGI STL</a></p><p><a href="http://www.stlport.org">STL port</a></p><p><a href="http://www.boost.org">Boost</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Effective STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>higer I-O</title>
      <link href="/2020/10/18/higer-I-O/"/>
      <url>/2020/10/18/higer-I-O/</url>
      
        <content type="html"><![CDATA[<h1 id="高级I-O函数"><a href="#高级I-O函数" class="headerlink" title="高级I/O函数"></a>高级I/O函数</h1><h2 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>pipe函数用于创建一个管道，以实现进程间通信。fd[0]和fd[1]通过pipe函数创建的两个文件描述符构成管道的两端。</p><p>fd[0]只能用于从管道读出数据、fd[1]只能用于从管道写入数据（不能反过来用）</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RW_by_pipe</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">&quot;pipe error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> id = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(id == <span class="number">0</span>)&#123;<span class="comment">//child</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">close(fd[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">char</span> *child = <span class="string">&quot;I am a child!&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">5</span>)&#123;</span><br><span class="line">write(fd[<span class="number">1</span>], child, <span class="built_in">strlen</span>(child) + <span class="number">1</span>);</span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;<span class="comment">//father</span></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(j &lt; <span class="number">5</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(msg, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"><span class="keyword">ssize_t</span> s = read(fd[<span class="number">0</span>], msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"><span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">msg[s - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//error</span></span><br><span class="line">perror(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="socketpair函数"><a href="#socketpair函数" class="headerlink" title="socketpair函数"></a>socketpair函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>socketpair函数的前三个参数与socket函数的参数含义一样，但是domain只能为AF_UNIX(仅能在本地创建双向管道)</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RW_by_socketpair</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, fd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socketpair error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sv[0] is : %d \n&quot;</span>, fd[<span class="number">0</span>]);   <span class="comment">//这两个套节字句柄并不相同，但作用是一样的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sv[1] is : %d \n&quot;</span>, fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> id = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">0</span>)&#123;<span class="comment">//child</span></span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">pid_t</span> pid = getpid();</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">read(fd[<span class="number">1</span>], &amp;val, <span class="keyword">sizeof</span>(val));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d receive message: %d\n&quot;</span>, pid, val);<span class="comment">//子进程从管道中读取数据</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//printf(&quot;%d receive message: %d\n&quot;, pid, val);</span></span><br><span class="line">            <span class="comment">//write(fd[1], &amp;val, sizeof(val));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;<span class="comment">//father</span></span><br><span class="line">        <span class="keyword">pid_t</span> pid = getpid();</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">++val;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d send message: %d\n&quot;</span>, pid, val);   </span><br><span class="line">            write(fd[<span class="number">0</span>], &amp;val, <span class="keyword">sizeof</span>(val));            <span class="comment">//父进程向管道里写数据</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//read(fd[0], &amp;val, sizeof(val));</span></span><br><span class="line">           <span class="comment">//printf(&quot;%d receive message: %d\n&quot;, pid, val);</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//error</span></span><br><span class="line">        perror(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dup函数和dup2函数"><a href="#dup函数和dup2函数" class="headerlink" title="dup函数和dup2函数"></a>dup函数和dup2函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd1, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure><p>dup函数用于创建一个新的文件描述符，该新文件描述符和原有文件描述fd指向相同的文件、管道或者网络连接。</p><p>dup2函数一样，只不过返回的是第一个大于fd2的描述符。</p><h2 id="readv函数和writev函数"><a href="#readv函数和writev函数" class="headerlink" title="readv函数和writev函数"></a>readv函数和writev函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br></pre></td></tr></table></figure><p>iovec结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>   *iov_base   <span class="comment">/* 数据区的起始地址 */</span></span><br><span class="line">    <span class="keyword">size_t</span>  iov_len     <span class="comment">/* 数据区的大小 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readv()称为散布读，即将文件中若干连续的数据块读入内存分散的缓冲区中。</p><p>writev()称为聚集写，即收集内存中分散的若干缓冲区中的数据写至文件的连续区域中。</p><h2 id="sendfile函数"><a href="#sendfile函数" class="headerlink" title="sendfile函数"></a>sendfile函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span>* offest, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>sendfile函数在两个文件描述符之间直接传输数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率高，称为零拷贝</p><p>in_fd：待读出的数据的文件描述符 </p><p>out_fd：待写入的文件描述符</p><p> offest：从哪个位置开始读</p><p> count：传输的字节数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> filefd = open(filename, O_RDONLY);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">fstat(filefd, &amp;stat_buf);</span><br><span class="line">。。。。。。。。。。。。</span><br><span class="line">。。。。。。。。。。。。</span><br><span class="line">sendfile(connfd, filefd, <span class="literal">NULL</span>, stat_buf.st_size);<span class="comment">//connfd是经accept函数返回的描述符</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux高性能服务器编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket API</title>
      <link href="/2020/10/18/socket-API/"/>
      <url>/2020/10/18/socket-API/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux网络编程基础API"><a href="#Linux网络编程基础API" class="headerlink" title="Linux网络编程基础API"></a>Linux网络编程基础API</h1><p>主机字节序和网络字节序：</p><ol><li>大端字节序（big endian)：高位字节在前，低位字节在后，这是人类读写数值的方法；</li><li>小端字节序（little endian)：低位字节在前，高位字节在后，即以0x1122形式储存；<br> 举例来说：数值0x2211使用两个字节储存：高位字节是0x22，低位字节是0x11。</li></ol><p>以下是判断机器字节序的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ByteOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line"><span class="keyword">short</span> value;</span><br><span class="line"><span class="keyword">char</span> union_bytes[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">&#125;test;</span><br><span class="line">test.value = <span class="number">0x0102</span>;</span><br><span class="line"><span class="keyword">if</span>(test.union_bytes[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;big endian\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(test.union_bytes[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;small endian\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unknown...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们称<strong>小段字节序为主机字节序，大端字节序为网络字节序。</strong></p><p>主机字节序和网络字节序的转换函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/*主机字节序   -----&gt;    网络字节序 （host to net）*/</span></span><br><span class="line"><span class="function">usingned <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>;</span><br><span class="line"><span class="function">usingned <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> hostshort)</span></span>;</span><br><span class="line"><span class="comment">/*网络字节序   -----&gt;    主机字节序 （net to host）*/</span></span><br><span class="line"><span class="function">usingned <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"><span class="function">usingned <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="socket地址结构体"><a href="#socket地址结构体" class="headerlink" title="socket地址结构体"></a>socket地址结构体</h2><h3 id="两种通用的socket结构体"><a href="#两种通用的socket结构体" class="headerlink" title="两种通用的socket结构体"></a>两种通用的socket结构体</h3><ol><li><p>sockaddr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;          <span class="comment">// 地址族</span></span><br><span class="line">    <span class="keyword">char</span>        sa_data[<span class="number">14</span>];        <span class="comment">// 存放socket地址值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>sockaddr_storage</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>         sa_family;                              <span class="comment">// 地址族</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>   __ss_align;                             <span class="comment">// 用于内存对齐</span></span><br><span class="line">    <span class="keyword">char</span>                __ss_padding[<span class="number">128</span>-<span class="keyword">sizeof</span>(__ss_align)];   <span class="comment">// 提供足够大的空间用于存放地址值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="专用socket地址结构体"><a href="#专用socket地址结构体" class="headerlink" title="专用socket地址结构体"></a>专用socket地址结构体</h3><ol><li><p>sockaddr_in</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>     sin_family;     <span class="comment">// 地址族</span></span><br><span class="line">    <span class="keyword">u_int16_t</span>       sin_port;       <span class="comment">// 端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>       <span class="comment">// IPv4地址结构体</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">u_int32_t</span>       s_addr;         <span class="comment">// IPv4地址，要用网络字节序表示</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>sockaddr_in6</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>     sin6_family;    <span class="comment">// 地址族</span></span><br><span class="line">    <span class="keyword">u_int16_t</span>       sin6_port;      <span class="comment">// 端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>      <span class="comment">// IPv6地址结构体</span></span><br><span class="line">    <span class="keyword">u_int32_t</span>       sin6_flowinfo;  <span class="comment">// 流信息</span></span><br><span class="line">    <span class="keyword">u_int32_t</span>       sin6_scope_id;  <span class="comment">// scope ID</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   sa_addr[<span class="number">16</span>];    <span class="comment">// IPv6地址，要用网络字节序表示</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>sockaddr_un</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>     sin_family;     <span class="comment">// 地址族</span></span><br><span class="line">    <span class="keyword">char</span>            sun_path[<span class="number">108</span>];  <span class="comment">// 文件路径名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sa_family成员是地址族类型(sa_family_t)的变量。地址族类型通常与协议族类型。详情见下表。</p><p>| 协议族   | 地址族   | 描述             | 地址值含义和长度                                             |<br>| ———— | ———— | ———————— | —————————————————————————————— |<br>| PF_UNIX  | AF_UNIX  | UNIX本地域协议族 | 文件的路径名，长度可达108字节                                |<br>| PF_INET  | AF_INET  | TCP/IPv4协议族   | 16bit端口号和32bitIPv4地址，共6字节                          |<br>| PF_INET6 | AF_INET6 | TCP/IPv6协议族   | 16bit端口号和32bit流比特，128bitIPv6地址，32bit范围ID，共26字节 |</p><p>IP地址转换函数</p><p>函数名中n代表network，a代表ASCII</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strptr)</span></span>; <span class="comment">/*将点分十进制字符串表示的IPv4地址转换为网络字节序整数表示的IPv4地址*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cp, struct in_addr* inp)</span></span>; <span class="comment">/*完成与inet_addr同样的功能，只是将转换结果存储到inp所指结构体中*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;    <span class="comment">/*将网络字节序表示的IPv4地址转化为点分十进制的字符串表示的IPv4地址*/</span></span><br><span class="line">   <span class="comment">/*inet_ntoa函数是不可重入的（就是它返回的结果是最后一次转换的）*/</span></span><br></pre></td></tr></table></figure><p>创建socket</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>| 参数     | 作用                                                         |<br>| ———— | —————————————————————————————— |<br>| domain   | 告诉系统使用哪个底层协议族                                   |<br>| type     | 指定服务类型（通常为SOCK_STREAM服务（流服务）和SOCK_DGRAM服务（数据报）） |<br>| protocol | 在前两个参数的指定下，再选择一个具体的协议，一般置0，表示使用默认协议 |</p></li></ol></li></ol><pre><code>  命名socket  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>  bind函数将my_addr所指的socket地址分配给未命名的sockfd文件描述符，成功返回0，失败返回-1并设置errno。errno常见有EACCES（代表地址是受保护地址，仅超级用户使用）和EADDRINUSE（代表地址正在使用中）  监听socket  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>  sockfd参数指定被监听的socket，backlog参数指定内核监听队列的最大长度，如果监听队列长度超过backlog，则不再理会新的连接。</code></pre><p>​                接收连接                                                </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd参数是过listen监听的socket。addr参数用来获取被接受连接的远端socket地址。addrlen参数表示addr地址的长度。</p><p>accept成功时返回一个新的连接socket，该socket唯一标识了被接受的这个连接，服务器可以通过读写该socket来与客户端通信；错误时返回-1,并设置errno。</p><p>发起连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd参数由socket系统调用返回一个socket。serv_addr参数服务器监听的socket地址，addrlen是serv_addr参数的长度。</p><p>connect成功时返回0，失败返回-1并设置errno（常见有ECONNREFUSED表示目标端口不存在 和 ETIMEDOUT表示连接超时）</p><p>一旦成功建立连接，客户端可以通过读写sockfd来与服务器通信。</p><p>关闭连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>close系统调用并非总是立即关闭一个连接，而是将其引用数减1，直到引用数变为0时才真正关闭这个连接。多进程程序中，每次fork都会增加父进程中打开的socket的引用数，所以在子进程中也需要close这些描述符。</p><p>如果需要立刻终止连接，就需要调用shutdown</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure><p>howto参数可选值有</p><ol><li>SHUT_RD:关闭sockfd上读的这一半</li><li>SHUT_WR:关闭sockfd上写的这一半</li><li>SHUT_RDWR:同时关闭sockfd的读和写</li></ol><p>数据读写</p><p>TCP数据读写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>send和recv返回-1时代表读或写失败，否则返回写入或读出的字节数。</p><p>UDP数据读写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr* src_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr* dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>地址信息函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>; <span class="comment">/*获取sockfd对应的本端socket地址，并将其存储于address所指结构体中*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>; <span class="comment">/*获取sockfd对应的远端socket地址，并将其存储于address所指结构体中*/</span></span><br></pre></td></tr></table></figure><p>socket选项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,  <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,  <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure><p>具体参数及其作用见man手册。</p><p>网络信息API</p><p>gethostbyname和gethostbyaddr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ghostname)</span></span>;                           <span class="comment">/*根据主机名称来获取主机的完整信息*/</span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> type)</span></span>;   <span class="comment">/*根据IP地址来获取主机的完整信息*/</span></span><br></pre></td></tr></table></figure><p>hostent结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>  *h_name;        <span class="comment">/*  official name of host */</span></span><br><span class="line">    <span class="keyword">char</span>  **h_aliases;    <span class="comment">/*  pointer to array of pointers to alias name */</span></span><br><span class="line">    <span class="keyword">int</span>     h_addrtype;   <span class="comment">/*  host address type: AF_INET */</span></span><br><span class="line">    <span class="keyword">int</span>     h_length;     <span class="comment">/*  length of address: 4 */</span></span><br><span class="line">    <span class="keyword">char</span>  **h_addr_list;  <span class="comment">/*  ptr to array of ptrs with IPv4 addrs */</span>              </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>getservbyname和getservbyport</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="function">struct servent *<span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ghostname, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;                           <span class="comment">/*根据名称来获取服务器的完整信息*/</span></span><br><span class="line"><span class="function">struct servent *<span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;    <span class="comment">/*根据端口号来获取服务器的完整信息*/</span></span><br></pre></td></tr></table></figure><p>servent结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span>  &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *s_name;         <span class="comment">/* Official service name.  */</span></span><br><span class="line"> <span class="keyword">char</span> **s_aliases;     <span class="comment">/* Alias list.  */</span></span><br><span class="line"> <span class="keyword">int</span> s_port;           <span class="comment">/* Port number.  */</span></span><br><span class="line">    <span class="keyword">char</span> *s_proto;        <span class="comment">/* Protocol to use.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux高性能服务器编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I-O reuse(复用)</title>
      <link href="/2020/10/18/I-O-reuse/"/>
      <url>/2020/10/18/I-O-reuse/</url>
      
        <content type="html"><![CDATA[<h1 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h1><h2 id="文件描述符就绪条件："><a href="#文件描述符就绪条件：" class="headerlink" title="文件描述符就绪条件："></a>文件描述符就绪条件：</h2><h3 id="socket可读："><a href="#socket可读：" class="headerlink" title="socket可读："></a>socket可读：</h3><ul><li>socket内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLWAT</li><li>socket通信对方关闭连接</li><li>socket上有错误未处理</li></ul><h3 id="socket可写："><a href="#socket可写：" class="headerlink" title="socket可写："></a>socket可写：</h3><ul><li>socket内核发送缓存区中的字节数大于或等于其低水位标记SO_RCVLWAT</li><li>socket的写操作被关闭</li><li>socket使用非阻塞的connect连接成功或超时之后</li><li>socket上有未处理的错误</li></ul><h2 id="select-API：在一段时间内，监听用户感兴趣的文件描述符上的可读、可写和异常事件。"><a href="#select-API：在一段时间内，监听用户感兴趣的文件描述符上的可读、可写和异常事件。" class="headerlink" title="select API：在一段时间内，监听用户感兴趣的文件描述符上的可读、可写和异常事件。"></a>select API：在一段时间内，监听用户感兴趣的文件描述符上的可读、可写和异常事件。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure><ol><li><p>nfds参数：指定被监听的文件描述符的总数（通常为select监听的文件描述符的最大值加1）.</p></li><li><p>readfds、writefds、exceptfds参数分别指向可读、可写、异常事件</p><p>fd_set结构体其实就是一个整型数组，数组中的每个元素的每一位标记了一个文件描述符</p><p>通过以下函数来访问结构体中的位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;<span class="comment">/*清楚fdset的所有位*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; <span class="comment">/*设置fdset的位fd*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">/*清除fdset的位fd*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;<span class="comment">/*测试fdset的位fd是否被设置*/</span></span><br></pre></td></tr></table></figure></li><li><p>timeout参数用来设置select的超时时间。当在指定值内没有就绪的文件描述符，返回0.否则返回就绪文件描述符的总数，并将等待时间通过timeout参数返回。失败返回-1.如果timeout参数设置为NULL则函数一直阻塞直到某个文件描述符就绪。</p></li></ol><p>调用示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fd_set read_fds;</span><br><span class="line">fd_set write_fds;</span><br><span class="line">fd_set exception_fds;</span><br><span class="line">FD_ZERO(&amp;read_fds);</span><br><span class="line">FD_ZERO(&amp;write_fds);</span><br><span class="line">FD_ZERO(&amp;exception_fds);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//1.fd为某个文件描述符，设置fd对应位</span></span><br><span class="line">    <span class="comment">//每次都要重新设置，因为当事件发生后，文件描述符集合会被内核修改</span></span><br><span class="line">FD_SET(fd, &amp;read_fds);</span><br><span class="line">FD_SET(fd, &amp;write_fds);</span><br><span class="line">FD_SET(fd, &amp;exception_fds);</span><br><span class="line">select(fd+<span class="number">1</span>, &amp;read_fds, &amp;write_fds, &amp;exception_fds, timeout);</span><br><span class="line">    <span class="comment">//2.根据不同事件作出不同处理</span></span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(某个文件描述符, &amp;read_fds))&#123;<span class="comment">//读</span></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(某个文件描述符, &amp;write_fds)&#123;<span class="comment">//写</span></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(某个文件描述符, &amp;exception_fds))&#123;<span class="comment">//异常</span></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poll-API"><a href="#poll-API" class="headerlink" title="poll API:"></a>poll API:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;<span class="comment">/*文件描述符*/</span></span><br><span class="line">    <span class="keyword">short</span> events;   <span class="comment">/*注册的事件*/</span></span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">/*实际发生的事件*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>fds参数是一个pollfd结构类型的数组，指定我们感兴趣的文件描述符上发生的可读、可写和异常事件。</li><li>nfds指定数组的大小。</li><li>timeout参数指定poll函数的超时值。-1代表永远阻塞，0代表立即返回。</li></ol><p>常见事件：</p><h2 id="epoll系列系统调用："><a href="#epoll系列系统调用：" class="headerlink" title="epoll系列系统调用："></a>epoll系列系统调用：</h2><blockquote><p>epoll是Linux的特有I/O复用函数。epoll使用一组函数来完成工作。其次，epoll用户把关心的文件描述符放在内核的一个<strong>事件表</strong>中，无需像poll一样重复传入事件集，但epoll需要一个文件描述符来唯一标识这个事件表。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line"><span class="keyword">_uint32_t</span> events;<span class="comment">/*epoll事件*/</span></span><br><span class="line"><span class="keyword">epoll_data_t</span> data; <span class="comment">/*用户数据*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data&#123;</span><br><span class="line"><span class="keyword">void</span>* ptr;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">uint32_t</span> u32;</span><br><span class="line"><span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>epoll_create函数用来创建唯一标识事件表的文件描述符，size参数指定事件表的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span>  fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure><p>epoll_ctl函数用来修改事件表中的事件，fd参数指定要操作的文件描述符，op参数指定操作类型，op参数可选值有：</p><ul><li>EPOLL_CTL_ADD：往事件表中注册fd上的事件</li><li>EPOLL_CTL_MOD：修改fd上的注册事件</li><li>EPOLL_CTL_DEL：删除fd上的注册事件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span></span><br></pre></td></tr></table></figure><p>epoll_wait函数用于在一段超时时间内等待一组文件描述符上的事件，如果检测到事件，就将所有的就绪事件从<strong>内核事件表</strong>中复制到第二个参数events指向的数组中。</p><p>使用poll和epoll的差别：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*poll*/</span></span><br><span class="line"><span class="keyword">int</span> ret = poll(fds, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*必须遍历所有已注册的文件描述符*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_EVENTS; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fds[i].revents &amp; POLLIN)&#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd = fds[i].fd;</span><br><span class="line">        <span class="comment">/*handle*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*epoll*/</span></span><br><span class="line"><span class="keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*仅需遍历ret个文件描述符*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">    <span class="comment">/*handle*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LT模式和ET模式："><a href="#LT模式和ET模式：" class="headerlink" title="LT模式和ET模式："></a>LT模式和ET模式：</h3><h4 id="LT模式：应用程序可以不立即处理epoll-wait检测出的事件，如果没处理，下次调用函数时依然会返回该事件"><a href="#LT模式：应用程序可以不立即处理epoll-wait检测出的事件，如果没处理，下次调用函数时依然会返回该事件" class="headerlink" title="LT模式：应用程序可以不立即处理epoll_wait检测出的事件，如果没处理，下次调用函数时依然会返回该事件"></a>LT模式：应用程序可以不立即处理epoll_wait检测出的事件，如果没处理，下次调用函数时依然会返回该事件</h4><h4 id="ET模式：应用程序需要立即处理epoll-wait检测出的事件，下次调用时，不再返回该事件"><a href="#ET模式：应用程序需要立即处理epoll-wait检测出的事件，下次调用时，不再返回该事件" class="headerlink" title="ET模式：应用程序需要立即处理epoll_wait检测出的事件，下次调用时，不再返回该事件"></a>ET模式：应用程序需要立即处理epoll_wait检测出的事件，下次调用时，不再返回该事件</h4><blockquote><p>LT模式是默认模式，如果需要改变为ET模式，需要进行如下操作：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">epoll_event event;</span><br><span class="line">event.events |= POLLET;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br></pre></td></tr></table></figure><h3 id="EPOLLONESHOT事件："><a href="#EPOLLONESHOT事件：" class="headerlink" title="EPOLLONESHOT事件："></a>EPOLLONESHOT事件：</h3><p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个事件、且只触发一次，除非我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;</span><br></pre></td></tr></table></figure><h2 id="三组I-O复用函数的比较："><a href="#三组I-O复用函数的比较：" class="headerlink" title="三组I/O复用函数的比较："></a>三组I/O复用函数的比较：</h2><p>select、poll、epoll的区别</p><h2 id="select的应用：非阻塞connect"><a href="#select的应用：非阻塞connect" class="headerlink" title="select的应用：非阻塞connect"></a>select的应用：非阻塞connect</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1023</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将文件描述符fd设置为非阻塞的*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetNonblock</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*非阻塞connect*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unblock_connect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ip, <span class="keyword">int</span> port, <span class="keyword">int</span> time)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> fdopt = SetNonblock(sockfd);<span class="comment">/*将sockfd设置为非阻塞的*/</span></span><br><span class="line">ret = connect(sockfd, (struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;<span class="comment">/*connect立即得到了回馈*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connect with server immediatedly\n&quot;</span>);</span><br><span class="line">fcntl( sockfd, F_SETFL, fdopt );</span><br><span class="line">        <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(errno != EINPROGRESS)&#123;<span class="comment">/*sockfd不支持阻塞*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unblock connect not support\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fd_set readfds;</span><br><span class="line">fd_set writefds;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">FD_ZERO(&amp;readfds);</span><br><span class="line">FD_SET(sockfd ,&amp;writefds);</span><br><span class="line"></span><br><span class="line">timeout.tv_sec = time;</span><br><span class="line">timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret = select(sockfd + <span class="number">1</span>, <span class="literal">NULL</span>, &amp;writefds, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line"><span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)&#123;<span class="comment">/*在超时时间内没有就绪事件*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection time out\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!FD_ISSET(sockfd, &amp;writefds))&#123;<span class="comment">/*sockfd上没有就绪事件*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;no events on sockfd found\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(error);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通过getsockopt获取sockfd上可能出现的错误*/</span></span><br><span class="line"><span class="keyword">if</span>(getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;length) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get socket option failed\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果error被改变，则代表sockfd上有错误*/</span></span><br><span class="line"><span class="keyword">if</span>(error != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection failed after select with the error: %d \n&quot;</span>, error);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*没有以上的错误，connect在等待相应*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection ready after select with the socket: %d \n&quot;</span>, sockfd);</span><br><span class="line">fcntl(sockfd, F_SETFL, fdopt);<span class="comment">/*将sockfd属性改回原样*/</span></span><br><span class="line"><span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the argumets number incorrect\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> sockfd = unblock_connect(ip, port, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">if</span>(sockfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shutdown(sockfd, SHUT_WR);</span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;send data out\n&quot;</span>);</span><br><span class="line">send(sockfd, <span class="string">&quot;abc&quot;</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poll的应用：聊天室"><a href="#poll的应用：聊天室" class="headerlink" title="poll的应用：聊天室"></a>poll的应用：聊天室</h2><p>客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argumetns number error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(port);</span><br><span class="line">inet_pton(AF_INET, ip, &amp;server_addr.sin_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">ret = connect(sockfd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connect error!\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[2];</span></span><br><span class="line">fds[<span class="number">0</span>].fd = <span class="number">0</span>;<span class="comment">/*标准输入*/</span></span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">fds[<span class="number">0</span>].revents = <span class="number">0</span>;<span class="comment">/*sockfd上的可读事件*/</span></span><br><span class="line">fds[<span class="number">1</span>].fd = sockfd;</span><br><span class="line">fds[<span class="number">1</span>].events = POLLIN | POLLRDHUP;</span><br><span class="line">fds[<span class="number">1</span>].revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> read_buf[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">ret = pipe(pipefd);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">ret = poll(fds, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;poll error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN)&#123;<span class="comment">/*文件描述符0（标准输入）有可读事件*/</span></span><br><span class="line">ret = splice(<span class="number">0</span>, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">ret = splice(pipefd[<span class="number">0</span>], <span class="literal">NULL</span>, sockfd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fds[<span class="number">1</span>].revents &amp; POLLRDHUP)&#123;<span class="comment">/*连接断开*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;server close the connection!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fds[<span class="number">1</span>].revents &amp; POLLIN)&#123;<span class="comment">/*sockfd上有可读事件*/</span></span><br><span class="line"><span class="built_in">memset</span>(read_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">recv(fds[<span class="number">1</span>].fd, read_buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, read_buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_LIMIT 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_LIMIT 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*客户的数据*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span>&#123;</span></span><br><span class="line">sockaddr_in address;</span><br><span class="line"><span class="keyword">char</span>* write_buf;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将sockfd设置为非阻塞的*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setNoBlock</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(sockfd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(sockfd, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arguments number error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通过命令行参数获取IP地址和端口号*/</span></span><br><span class="line"><span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化服务器的地址结构体*/</span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(port);</span><br><span class="line">inet_pton(PF_INET, ip, &amp;server_addr.sin_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建、命名、监听socket*/</span></span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ret = bind(listenfd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">listen</span>(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client_data* users = <span class="keyword">new</span> client_data[FD_LIMIT];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[<span class="title">USER_LIMIT</span> + 1];</span></span><br><span class="line"><span class="keyword">int</span> user_counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化化fds*/</span></span><br><span class="line">fds[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN | POLLERR;</span><br><span class="line">fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= USER_LIMIT; ++i)&#123;</span><br><span class="line">fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">fds[i].events = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">ret = poll(fds, USER_LIMIT + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;poll error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; user_counter +<span class="number">1</span>; ++i)&#123;</span><br><span class="line"><span class="comment">/*如果监听listenfd上有连接,即有新用户加入*/</span></span><br><span class="line"><span class="keyword">if</span>((fds[i].fd == listenfd) &amp;&amp; (fds[i].revents &amp; POLLIN))&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">bzero(&amp;client_addr, <span class="keyword">sizeof</span>(client_addr));</span><br><span class="line"><span class="keyword">socklen_t</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr_len);</span><br><span class="line"><span class="comment">/*accept发起的connect*/</span></span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr*)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line"><span class="comment">/*accept错误*/</span></span><br><span class="line"><span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is %d\n&quot;</span>, errno);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果用户数量超过最大值*/</span></span><br><span class="line"><span class="keyword">if</span>(user_counter &gt;= USER_LIMIT)&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* info = <span class="string">&quot;too many users\n&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %s&quot;</span>, info);</span><br><span class="line">send(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">close</span>(connfd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*修改新添的用户对应数据*/</span></span><br><span class="line">user_counter++;</span><br><span class="line">users[connfd].address = client_addr;</span><br><span class="line">setNoBlock(connfd);</span><br><span class="line">fds[user_counter].fd = connfd;</span><br><span class="line">fds[user_counter].events = POLLIN | POLLRDHUP | POLLERR;<span class="comment">/*注册监听事件：可读、连接关闭、错误*/</span></span><br><span class="line">fds[user_counter].revents = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;comes a new user, now have %d user\n&quot;</span>, user_counter);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果用户i的连接上发生了错误事件*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fds[i].revents &amp; POLLERR)&#123;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;get an error from %d\n&quot;</span>, fds[i].fd );</span><br><span class="line"><span class="keyword">char</span> errors[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(errors, <span class="string">&#x27;\0&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(errors);</span><br><span class="line"><span class="keyword">if</span>(getsockopt(fds[i].fd, SOL_SOCKET, SO_ERROR, &amp;errors, &amp;length) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get socket option failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果用户i的连接断开*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fds[i].revents &amp; POLLRDHUP)&#123;</span><br><span class="line">users[fds[i].fd] = users[fds[user_counter].fd];</span><br><span class="line">                <span class="built_in">close</span>( fds[i].fd );</span><br><span class="line">                fds[i] = fds[user_counter];</span><br><span class="line">                i--;</span><br><span class="line">                user_counter--;</span><br><span class="line">                <span class="built_in">printf</span>( <span class="string">&quot;a client left\n&quot;</span> ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果用户i的连接上有数据可读*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fds[i].revents &amp; POLLIN)&#123;</span><br><span class="line"><span class="keyword">int</span> connfd = fds[i].fd;</span><br><span class="line"><span class="built_in">memset</span>(users[connfd].buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);<span class="comment">/*初始化connfd对应的缓冲区*/</span></span><br><span class="line">ret = recv(connfd, users[connfd].buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);<span class="comment">/*将数据读到缓冲区*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get %d bytes of client data %s from %d\n&quot;</span>, ret, users[connfd].buf, connfd);</span><br><span class="line"><span class="comment">/*recv返回异常*/</span></span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">/*读操作出现错误，关闭连接*/</span></span><br><span class="line"><span class="keyword">if</span>(errno != EAGAIN)&#123;</span><br><span class="line"><span class="built_in">close</span>(connfd);</span><br><span class="line">users[fds[i].fd] = users[fds[user_counter].fd];</span><br><span class="line">fds[i] = fds[user_counter];</span><br><span class="line">i--;</span><br><span class="line">user_counter--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*没有读到数据*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*正常读出数据*/</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">/*通知其他的客户接收数据*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= user_counter; ++j)&#123;</span><br><span class="line"><span class="comment">/*如果是发送数据的那个客户，跳过*/</span></span><br><span class="line"><span class="keyword">if</span>(fds[j].fd == connfd)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">fds[j].events |= ~POLLIN;</span><br><span class="line">fds[j].events |= POLLOUT;</span><br><span class="line">users[fds[j].fd].write_buf = users[connfd].buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果用户i的连接上有数据可写*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fds[i].revents &amp; POLLOUT)&#123;</span><br><span class="line"><span class="keyword">int</span> connfd = fds[i].fd;</span><br><span class="line"><span class="keyword">if</span>(!users[connfd].write_buf)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = send(connfd, users[connfd].write_buf, <span class="built_in">strlen</span>(users[connfd].write_buf), <span class="number">0</span>);</span><br><span class="line">users[connfd].write_buf = <span class="literal">NULL</span>;</span><br><span class="line">fds[i].events |= ~POLLOUT;</span><br><span class="line">fds[i].events |= POLLIN;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> [] users;</span><br><span class="line"><span class="built_in">close</span>(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="epoll的应用：同时处理TCP、UDP服务"><a href="#epoll的应用：同时处理TCP、UDP服务" class="headerlink" title="epoll的应用：同时处理TCP、UDP服务"></a>epoll的应用：同时处理TCP、UDP服务</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_BUFFER_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UDP_BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将fd设置为非阻塞的*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">( <span class="keyword">int</span> fd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = fcntl( fd, F_GETFL );</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl( fd, F_SETFL, new_option );</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*epollfd事件表上注册fd上的事件*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    <span class="comment">//event.events = EPOLLIN | EPOLLET;</span></span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    epoll_ctl( epollfd, EPOLL_CTL_ADD, fd, &amp;event );</span><br><span class="line">    setnonblocking( fd );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arguments number error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"><span class="comment">/*初始化服务器地址结构体*/</span></span><br><span class="line">bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(port);</span><br><span class="line">inet_pton(PF_INET, ip, &amp;server_addr.sin_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建、命名、监听TCP socket*/</span></span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ret = bind(listenfd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">listen</span>(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化服务器地址结构体*/</span></span><br><span class="line">bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    inet_pton( AF_INET, ip, &amp;server_addr.sin_addr );</span><br><span class="line">    server_addr.sin_port = htons( port );</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*创建、命名、监听UDP socket*/</span></span><br><span class="line"><span class="keyword">int</span> udpfd = socket( PF_INET, SOCK_DGRAM, <span class="number">0</span> );</span><br><span class="line">assert(udpfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ret = bind(udpfd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">addfd(epollfd, listenfd);</span><br><span class="line">addfd(epollfd, udpfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(number &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failed!\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; ++i)&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*TCP 服务*/</span></span><br><span class="line"><span class="keyword">if</span>(sockfd == listenfd)&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr*)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">addfd(epollfd, connfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*UDP 服务*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sockfd == udpfd)&#123;</span><br><span class="line"><span class="keyword">char</span> buf[UDP_BUFFER_SIZE];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, UDP_BUFFER_SIZE);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"><span class="keyword">socklen_t</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">ret = recvfrom(udpfd, buf, UDP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr*)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line"><span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">sendto(udpfd, buf, UDP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr*)&amp;client_addr, client_addr_len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN)&#123;</span><br><span class="line"><span class="keyword">char</span> buf[TCP_BUFFER_SIZE];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, TCP_BUFFER_SIZE);</span><br><span class="line">ret = recv(sockfd, buf, TCP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((errno == EAGAIN) || (errno == EWOULDBLOCK))&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">close</span>(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">send(sockfd, buf, ret, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux高性能服务器编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ singleton(单例模式)</title>
      <link href="/2020/10/18/c-singleton/"/>
      <url>/2020/10/18/c-singleton/</url>
      
        <content type="html"><![CDATA[<h1 id="c-单例模式"><a href="#c-单例模式" class="headerlink" title="c++单例模式"></a>c++单例模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><font size="4">单例 Singleton 是设计模式的一种，其特点是只提供**唯一**一个类的实例,具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例;具体运用场景如：</font><ol><li>设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动;</li><li>数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取;</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li><p>要点：</p><ul><li>构造函数设为private</li><li>线程安全</li><li>禁止拷贝和赋值</li><li>通过接口（static类成员函数）获得实例</li></ul></li><li><p>实现的几种方式</p><ul><li>懒汉模式：就是要用到实例时才new对象。</li><li>代码（懒汉—普通指针版）：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Singleton()&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;constructor called!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果后面使用&quot;=delete&quot;去修饰，那么就表示这个函数被定义为deleted，也就意味着这个成员函数不能再被调用，否则就会出错</span></span><br><span class="line">    <span class="comment">//禁止拷贝和赋值</span></span><br><span class="line">Singleton(Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">static</span> Singleton* instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~Singleton()&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;destructor called!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">nullptr</span>)</span><br><span class="line">instance = <span class="keyword">new</span> Singleton;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Singleton *s1 = Singleton::getInstance();</span><br><span class="line">Singleton *s2 = Singleton::getInstance();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment">constructor called!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>优点：如果不调用实例就不会new对象占用内存</p></li><li><p>缺点：</p><ol><li>线程安全问题：如果一开始instance指针为nullptr时，有两个线程同时通过接口来获取实例时，会new两个对象；<strong>解决方法：</strong>加互斥锁</li><li>内存泄露问题：类只负责new对象，没有delete，会造成内存泄露；<strong>解决方法</strong>：使用<strong>shared_ptrf</strong>代替普通指针</li></ol></li><li><p>代码（懒汉—智能指针、锁）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;//mutex</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;//shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Singleton&gt; Ptr;<span class="comment">//智能指针声明</span></span><br><span class="line">~Singleton()&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;destructor called!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Singleton(Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Ptr <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">//双检锁</span></span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">locker</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">instance = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Singleton&gt;(<span class="keyword">new</span> Singleton);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Singleton()&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;constructor called!&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> Ptr instance;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::mutex mtx;<span class="comment">//互斥变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton::Ptr Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex Singleton::mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Singleton::Ptr instance = Singleton::getInstance();</span><br><span class="line">Singleton::Ptr instance2 = Singleton::getInstance();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*运行结果</span></span><br><span class="line"><span class="comment"> * constructor called!</span></span><br><span class="line"><span class="comment"> * destructor called！</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure><ul><li>优点：解决了第一个版本的问题，双检锁解决了线程安全问题，智能指针解决了内存泄露的问题。</li><li>缺点：代码量增加，要求用户也使用智能指针，使用锁会增加开销。而且<font size="4" color="yellow">双检锁有可能会失效</font></li></ul></li></ul><ul><li><p>代码（局部静态变量）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~Singleton()&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;destructor called!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Singleton(Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Singleton&amp;)=<span class="keyword">delete</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> Singleton instance;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Singleton()&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;constructor called!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Singleton&amp; instance1 = Singleton::getInstance();</span><br><span class="line">Singleton&amp; instance2 = Singleton::getInstance();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果：</span></span><br><span class="line"><span class="comment"> * constructor called!</span></span><br><span class="line"><span class="comment"> * destructor called!</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure></li><li><p>优点：如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。</p><ol><li>不需要使用智能指针</li><li>通过局部静态变量保证线程安全</li><li>需要返回单例的引用才能获得对象</li></ol></li></ul><font size="5">参考文章：</font><font size="4">[[C++ 单例模式总结与剖析](https://www.cnblogs.com/sunchaothu/p/10389842.html)]</font><font size="4">[面试中的单例](http://www.cnblogs.com/loveis715/archive/2012/07/18/2598409.html)</font>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++11 smart pointer（智能指针）</title>
      <link href="/2020/10/18/c-11-smart-pointer/"/>
      <url>/2020/10/18/c-11-smart-pointer/</url>
      
        <content type="html"><![CDATA[<h1 id="c-11-智能指针"><a href="#c-11-智能指针" class="headerlink" title="c++11 智能指针"></a>c++11 智能指针</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h2><blockquote><p>C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</p></blockquote><ol><li>从较浅的层面看，智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。</li><li>智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。</li><li>智能指针还有一个作用是把 <a href="https://www.cnblogs.com/Solstice/archive/2011/08/16/2141515.html">值语义</a> 转换成引用语义。</li></ol><h2 id="使用：一共有三个常用的智能指针（shared-ptr-unique-ptr-weak-ptr）-包含在在-头文件中"><a href="#使用：一共有三个常用的智能指针（shared-ptr-unique-ptr-weak-ptr）-包含在在-头文件中" class="headerlink" title="使用：一共有三个常用的智能指针（shared_ptr\unique_ptr\weak_ptr）,包含在在  头文件中"></a>使用：一共有三个常用的智能指针（shared_ptr\unique_ptr\weak_ptr）,包含在在 <memory> 头文件中</memory></h2><ul><li><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a><font size="6">shared_ptr</font></h3><blockquote><p>shared_ptr多个指针指向<strong>相同</strong>的对象。shared_ptr使用引用计数，每一个shared_ptr的<strong>拷贝</strong>都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是<strong>线程安全</strong>的，但是对象的读取需要加锁。</p></blockquote><ul><li><p>初始化：shared_ptr初始化要用make_shared函数，不能直接使用原始指针，或将原始指针直接赋值给一个智能指针。例如：shared_ptr<int> p = new int(4);//错误   shared_ptr<int> = make_shared<int>(new int(4)); //正确</int></int></int></p></li><li><p>拷贝和赋值：拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1</p><p>​                            1、拷贝：shared_ptr<int> p(a); // 使得a指向的对象引用数加1</int></p><p>​                             2、赋值 :shared_ptr<int> p1 = make_shared<int>(a);</int></int></p><p>​                                               shared_ptr<int> p2 = make_shared<int>(b);</int></int></p><p>​                                                p1 = p2; // 使得p1原先指向的对象（即a所指对象）引用数减1， p2原先所指对象（即b所指对象）引用数加1 </p></li><li><p>get函数获取原始指针 </p><p>例如：shared_ptr<int> p(a);  int *p = ptr.get();</int></p></li><li><p>注意不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存</p></li><li><p>注意避免<font color="Blue">循环引用</font>，shared_ptr的一个最大的陷阱是循环引用，循环，循环引用会导致堆内存无法正确释放，导致内存泄漏。循环引用在weak_ptr中介绍。</p></li></ul><p>示例程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_on_shared_ptr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptra = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(a);<span class="comment">//初始化，引用加1</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ptra2</span><span class="params">(ptra)</span></span>; <span class="comment">//拷贝，引用加1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">/*2*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> *pb = &amp;a;</span><br><span class="line">        <span class="comment">//std::shared_ptr&lt;int&gt; ptrb = pb;  //error</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptrb = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(b);<span class="comment">//初始化，引用加1</span></span><br><span class="line">        ptra2 = ptrb; <span class="comment">//赋值，ptra2原来的对象(a)引用减1;ptrbs所指对象(b)引用加1</span></span><br><span class="line">        pb = ptrb.<span class="built_in">get</span>(); <span class="comment">//获取原始指针</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptra.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">/*1*/</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ptrb.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">/*2*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><font size="6">unique_ptr</font><blockquote><font size="5">unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象<u>（通过禁止拷贝语义、只有移动语义来实现）。</u>相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。</font></blockquote><font size="6">示例程序：</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_on_unique_ptr</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">uptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;<span class="comment">//绑定动态对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//unique_ptr&lt;int&gt; uptr2 = uptr;//不能赋值</span></span><br><span class="line"><span class="comment">//unique_ptr&lt;int&gt; uptr2(uptr);//不能拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; uptr2 = <span class="built_in">move</span>(uptr);<span class="comment">//替换所有权</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *当然也可以通过以下方式来转移所有权</span></span><br><span class="line"><span class="comment"> up1的所有权转移到up2，up1不再管理指针，up1为空</span></span><br><span class="line"><span class="comment"> release的返回值是普通类型的指针</span></span><br><span class="line"><span class="comment"> up2.reset(up1.release());</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//u放弃当前指针的控制权，并将u置空，返回所管理的指针，</span></span><br><span class="line"><span class="comment">//若release函数的返回值没有被unique_ptr对象接收，我们需要手动释放内存，否则有内存泄漏。</span></span><br><span class="line">uptr2.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放u指向的对象</span></span><br><span class="line">uptr2.reset();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *q = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//令u指向q所管理的对象，q是普通的指针</span></span><br><span class="line">uptr2.reset(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><font size="6">weak_ptr</font><blockquote><p>weak_ptr的唯一作用是配合shared_ptr使用，weak_ptr没有重载 * 和 -&gt; ,它只能像个旁观者一样观测资源的使用情况。weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。</p></blockquote><font size="6">示例程序：</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_on_weak_ptr</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *expired()的功能等价于use_count()==0</span></span><br><span class="line"><span class="comment"> lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源</span></span><br><span class="line"><span class="comment"> 但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sh_ptr = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sh_ptr.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(sh_ptr)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;wp.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!wp.expired())&#123;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sh_ptr2 = wp.lock();</span><br><span class="line">*sh_ptr = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;wp.use_count()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环引用：考虑一个简单的对象建模——家长与子女：a-Parent-has-a-Child-a-Child-knows-his-her-Parent。"><a href="#循环引用：考虑一个简单的对象建模——家长与子女：a-Parent-has-a-Child-a-Child-knows-his-her-Parent。" class="headerlink" title="循环引用：考虑一个简单的对象建模——家长与子女：a Parent has a Child, a Child knows his/her Parent。"></a>循环引用：<strong>考虑一个简单的对象建模——家长与子女：a Parent has a Child, a Child knows his/her Parent。</strong></h3><font size="5">用原始指针实现：</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Child* myChild;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(Child* ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;myChild = ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;myChild) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Parent() &#123;</span><br><span class="line">        <span class="keyword">delete</span> myChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Parent* myParent;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(Parent* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;myParent = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;myParent) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Child() &#123;</span><br><span class="line">        <span class="keyword">delete</span> myParent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Parent* p = <span class="keyword">new</span> Parent;</span><br><span class="line">        Child* c =  <span class="keyword">new</span> Child;</span><br><span class="line">        p-&gt;setChild(c);</span><br><span class="line">        c-&gt;setPartent(p);</span><br><span class="line">        <span class="keyword">delete</span> c;  <span class="comment">//only delete one</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><font size="4">    注意：只删除一个的原因是，delete child的时候会调用child的析构函数，析构函数会delete Parent如果加上delete p的话，会重复delete（十分容易出错）</font></blockquote></li></ul>  <font size="5">用两个shared_ptr实现：</font>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.use_count()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Parent() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.use_count()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Child() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//初始化，parent对象引用加1</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line"><span class="comment">//初始化，child对象引用加1</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line"><span class="comment">//两个互相设置，parent和child对象引用各加1</span></span><br><span class="line">        p-&gt;setChild(c);</span><br><span class="line">        c-&gt;setPartent(p);</span><br><span class="line"><span class="comment">//检测p和c的引用数</span></span><br><span class="line">   wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//脱离作用域后，由初始化两个shared_ptr引起的加1失效</span></span><br><span class="line"><span class="comment">//但是由于两个对象仍然有两个shared_ptr互相指向，导致引用数不能减为0，内存无法释放</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wpp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wpc.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <font size="5">用一个shared_ptr和一个weak_ptr实现：</font>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//std::shared_ptr&lt;Child&gt; ChildPtr;</span></span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChild</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new shared_ptr</span></span><br><span class="line"><span class="comment">//因为ChildPtr是weak_ptr无法引用，需要调用lock函数来new一个shared_ptr来引用Child对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.lock()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Parent() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPartent</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.use_count()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Child() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Child&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">        p-&gt;setChild(c);</span><br><span class="line">        c-&gt;setPartent(p);</span><br><span class="line">        wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line">        <span class="comment">//Parent对象由两个shared_ptr指向，引用数为2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="comment">//Child对象由一个shared_ptr和一个weak_ptr指向，引用数为1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//由于child对象的引用减1为0，child对象释放，导致其对象内</span></span><br><span class="line"><span class="comment">//指向parent对象的shared_ptr失效，最终再引起</span></span><br><span class="line"><span class="comment">//parent对象的引用数减1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wpp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; wpc.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与上一个程序的主要区别在于父类，其成员是用weak_ptr指向其孩子，当需要引用到其孩子时，调用weak_ptr的lock函数，生成一个指向其孩子的shared_ptr.</p></blockquote><h2 id="设计和实现"><a href="#设计和实现" class="headerlink" title="设计和实现"></a>设计和实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _ptr;</span><br><span class="line">    <span class="keyword">size_t</span>* _count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SmartPointer(T* ptr = <span class="literal">nullptr</span>) :</span><br><span class="line">            _ptr(ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ptr) &#123;</span><br><span class="line">            _count = <span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _count = <span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SmartPointer(<span class="keyword">const</span> SmartPointer&amp; ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ptr) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line">            <span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">            (*<span class="keyword">this</span>-&gt;_count)++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SmartPointer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPointer&amp; ptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr == ptr._ptr) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr) &#123;</span><br><span class="line">            (*<span class="keyword">this</span>-&gt;_count)--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">        (*<span class="keyword">this</span>-&gt;_count)++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        assert(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        assert(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~SmartPointer() &#123;</span><br><span class="line">        (*<span class="keyword">this</span>-&gt;_count)--;</span><br><span class="line">        <span class="keyword">if</span> (*<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">use_count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">SmartPointer&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">        <span class="function">SmartPointer&lt;<span class="keyword">int</span>&gt; <span class="title">sp2</span><span class="params">(sp)</span></span>;</span><br><span class="line">        <span class="function">SmartPointer&lt;<span class="keyword">int</span>&gt; <span class="title">sp3</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">20</span>))</span></span>;</span><br><span class="line">        sp2 = sp3;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sp3.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//delete operator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="6" color="red">值得注意的是, 引用计数是用指针表示的，所有指向同一个的对象的不同智能指针的引用计数的指针都是指向同一个内存，这样可以做到一改全改。拷贝和赋值的时候只需要改变一次引用计数就可以了。</font>&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号</title>
      <link href="/2020/10/18/signal/"/>
      <url>/2020/10/18/signal/</url>
      
        <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>Linux标准信号：</p><p><img src="/2020/10/18/signal/jian/桌面/20180513185711893.png" alt="20180513185711893"></p><p>发送信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数把信号sig发送给pid指定的目的进程，pid的取值及其含义：</p><div class="table-container"><table><thead><tr><th>pid参数</th><th>含义</th></tr></thead><tbody><tr><td>pid &gt; 0</td><td>信号发送给PID为pid的进程</td></tr><tr><td>pid = 0</td><td>信号发送给本进程组内的其他进程</td></tr><tr><td>pid = -1</td><td>信号发送给除了init进程外的所有进程，但需要相应的权限</td></tr><tr><td>pid &lt; -1</td><td>信号发送给组ID为-pid的进程组的所有成员</td></tr></tbody></table></div><p>Linux定义信号值都大于0，如果sig取值为0，kill函数不发送任何信号。</p><p>函数成功返回0，失败返回-1，并设置errno</p><div class="table-container"><table><thead><tr><th>errno</th><th>含义</th></tr></thead><tbody><tr><td>EINVAL</td><td>无效的信号</td></tr><tr><td>EPERM</td><td>该进程没有权限发送信号给任何一个进程</td></tr><tr><td>ESRCH</td><td>目标进程或者进程组不存在</td></tr></tbody></table></div><p>信号处理方式：</p><p>目标进程在收到信号时，需要定义一个接收函数来处理。信号处理函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">_sighandler_t</span>)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>处理自定义信号处理函数外，还有系统定义了两种方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/signum.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_DEL((_sighandler_t) 0)  <span class="comment">/*使用默认处理方式*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_IGN((_sighandler_t) 1)  <span class="comment">/*忽略目标信号*/</span></span></span><br></pre></td></tr></table></figure><p>为一个信号设置处理函数，可以使用下面signal系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">_sighandler_t</span>  <span class="title">signal</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">_sighandler_t</span> _handler)</span></span></span><br></pre></td></tr></table></figure><p>sig指定信号类型，handler指定对应处理函数，函数返回上一次调用signal函数时传入的函数指针，如果第一次调用，则返回默认处理函数</p><p>或者调用以下接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">const</span> struct sigaction* act, struct sigaction* oact)</span></span></span><br></pre></td></tr></table></figure><p>和上面的signal函数类似，sig指定信号类型，act指定对应处理函数，oact指定上一次的处理函数。sigaction结构体详见手册。</p><p>信号默认处理有：</p><ul><li>结束进程（Term）</li><li>忽略信号（Ign）</li><li>结束进程并生成核心转储文件（Core）</li><li>暂停进程（Stop）</li><li>继续进程（Cont）</li></ul><p>信号集：</p><p>Linux使用sigset_t结构体来表示信号集：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/sigset.h&gt;</span></span></span><br><span class="line"><span class="meta">#defind _SIGSET_NWORDS  (1024 / (8 * sizeof(unsigned long int)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __val[_SIGSET_NWORDS]</span><br><span class="line">&#125;<span class="keyword">__sigset_t</span>;</span><br></pre></td></tr></table></figure><p>sigset_t其实就是一个长整型数组，数组的每个元素的每一位就代表一个信号。与fd_set的定义类似。</p><p>以下函数是用来设置、修改、删除和查询信号集：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span>* _set)</span><span class="comment">/*清空信号集*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span>* _set)</span>   <span class="comment">/*在信号集中设置所有信号*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span>* _set, <span class="keyword">int</span> _signo)</span> <span class="comment">/*将信号_signo添加至信号集中*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span>* _set, <span class="keyword">int</span> _signo)</span>  <span class="comment">/*将信号_signo从信号集中删除*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(_const <span class="keyword">sigset_t</span>* _set, <span class="keyword">int</span> _signo)</span><span class="comment">/*测试信号_signo是否在信号集中*/</span></span></span><br></pre></td></tr></table></figure><p>进程信号掩码：</p><blockquote><p>先说一下信号掩码的作用：在POSIX下，每个进程有一个信号掩码(signal mask)。简单地说，信号掩码是一个“位图”，其中每一位都对应着一种信号。如果位图中的某一位为1，就表示在执行当前信号的处理程序期间相应的信号暂时被“屏蔽”，使得在执行的过程中不会嵌套地响应那种信号。</p></blockquote><p>我们除了用sigaction结构体的sa_mask成员来设置进程的信号掩码。还可以用以下函数设置或者查看进程的信号掩码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpromask</span><span class="params">(<span class="keyword">int</span> _how, _const sigset* _set, sigset* _oset)</span></span>;</span><br></pre></td></tr></table></figure><p>_ set参数指定新的信号掩码，_ oset参数输出原来的信号掩码，_how指定设置进程信号掩码的方式。</p><p>_how的可选值</p><div class="table-container"><table><thead><tr><th>_how参数</th><th>含义</th></tr></thead><tbody><tr><td>SIG_BLOCK</td><td>将_set信号集所指信号屏蔽</td></tr><tr><td>SIG_UNBLOCK</td><td>将_set信号集所指信号设置为不屏蔽</td></tr><tr><td>SIG_SETMASK</td><td>直接将信号掩码设置为_set</td></tr></tbody></table></div><p>被挂起的信号：</p><p>设置信号掩码后，并屏蔽的信号不能被进程接收.如果给进程发送一个被屏蔽的信号，则操作系统将该信号设置为进程的一个被挂起的信号。如果我们取消对被挂起的信号的屏蔽，则它能被进程立即收到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>set参数用于保存被挂起的信号集。</p><h2 id="网络编程相关信号："><a href="#网络编程相关信号：" class="headerlink" title="网络编程相关信号："></a>网络编程相关信号：</h2><ul><li><p>SIGHUP：当挂起进程的控制终端时，SIGHUP信号将被触发。对于没有控制终端的网络后台程序而言，它们通常利用SIGHUP信号来强制服务器重读配置文件。</p></li><li><p>SIGPIPE：往一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号</p></li><li>SIGURG：socket连接上收到紧急数据（带外数据）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux高性能服务器编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_46</title>
      <link href="/2020/09/28/jzof-46/"/>
      <url>/2020/09/28/jzof-46/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h1><h2 id="递归解决这个问题："><a href="#递归解决这个问题：" class="headerlink" title="递归解决这个问题："></a>递归解决这个问题：</h2><p>就拿<strong>12258</strong>做例子（设i为指向12258的索引，从左到右，从0开始）</p><p>我们设立一个函数f，f(i)表示从第i位开始的数字一共有多少种不同的翻译方法</p><p>有以下几种情况：</p><ul><li>当i所指的数字为1：<ul><li>如果i不是指向数字的末尾，则此时f(i) = f(i + 1) + f(i + 2)，f(i + 1)表示将1当作一个数字翻译， f(i + 2)表示将1和其后面的一个数字当作一个整体来翻译</li><li>否则，f(i) = f(i + 1) </li></ul></li><li>当i所指的数字为2：<ul><li>如果i不是指向数字的末尾，并且i+1所指的数字小于等于5，此时f(i) = f(i + 1) + f(i + 2)，f(i + 1)表示将2当作一个数字翻译， f(i + 2)表示将2和其后面的一个数字当作一个整体来翻译</li><li>否则，否则，f(i) = f(i + 1) </li></ul></li><li>其他情况：<ul><li>f(i) = f(i + 1) </li></ul></li></ul><p>终止条件：</p><p>当i超出范围，返回0，当i刚好达到数字末尾返回1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> NUM;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == NUM.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; NUM.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(NUM[index] == <span class="string">&#x27;1&#x27;</span> || (NUM[index] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; NUM[index + <span class="number">1</span>] &lt;= <span class="string">&#x27;5&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span> helper(index + <span class="number">1</span>) + helper(index + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> helper(index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        NUM = to_string(num);</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_45</title>
      <link href="/2020/09/28/jzof-45/"/>
      <url>/2020/09/28/jzof-45/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h1><h2 id="由于数组里所有的数字都要用上，任何组合的答案数值的长度都是一样的。设两个数n1、n2，如果n1-lt-n2，同样n1的字符串-lt-n2的字符串。我们先将nums数组排序，排序规则，当to-string-n1-to-string-n2-lt-to-string-n2-to-string-n1-时，我们知道，需要将n1的放在n2的前面。这样我们可以自定义一个比较函数，来作为sort函数的第三参数。这样sort之后，只需组装就行了。"><a href="#由于数组里所有的数字都要用上，任何组合的答案数值的长度都是一样的。设两个数n1、n2，如果n1-lt-n2，同样n1的字符串-lt-n2的字符串。我们先将nums数组排序，排序规则，当to-string-n1-to-string-n2-lt-to-string-n2-to-string-n1-时，我们知道，需要将n1的放在n2的前面。这样我们可以自定义一个比较函数，来作为sort函数的第三参数。这样sort之后，只需组装就行了。" class="headerlink" title="由于数组里所有的数字都要用上，任何组合的答案数值的长度都是一样的。设两个数n1、n2，如果n1&lt;n2，同样n1的字符串&lt;n2的字符串。我们先将nums数组排序，排序规则，当to_string(n1)+to_string(n2) &lt; to_string(n2)+to_string(n1)时，我们知道，需要将n1的放在n2的前面。这样我们可以自定义一个比较函数，来作为sort函数的第三参数。这样sort之后，只需组装就行了。"></a>由于数组里所有的数字都要用上，任何组合的答案数值的长度都是一样的。设两个数n1、n2，如果n1&lt;n2，同样n1的字符串&lt;n2的字符串。我们先将nums数组排序，排序规则，当to_string(n1)+to_string(n2) &lt; to_string(n2)+to_string(n1)时，我们知道，需要将n1的放在n2的前面。这样我们可以自定义一个比较函数，来作为sort函数的第三参数。这样sort之后，只需组装就行了。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str1 = to_string(n1);</span><br><span class="line">        <span class="built_in">string</span> str2 = to_string(n2);</span><br><span class="line">        <span class="keyword">return</span> (str1 + str2) &lt; (str2 + str1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), comp);</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)ans += to_string(num);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_40</title>
      <link href="/2020/09/28/jzof-40/"/>
      <url>/2020/09/28/jzof-40/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h1><p>题解：</p><div class="table-container"><table><thead><tr><th></th><th>排序法</th><th>堆算法</th></tr></thead><tbody><tr><td>时间复杂度</td><td>O(N*logN)</td><td>O(N*logK)</td></tr><tr><td>空间复杂度</td><td>O(1)</td><td>O(K)</td></tr></tbody></table></div><p>排序法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">begin</span>() + k)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ans;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>堆：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//大根堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">size</span>() &lt; k)q.push(arr[i]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &lt; q.top())&#123;<span class="comment">//如果比堆顶小的就入堆，并且把原来的堆顶pop</span></span><br><span class="line">                    q.pop();</span><br><span class="line">                    q.push(arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时堆中的k个元素都是最小的k个数</span></span><br><span class="line">        <span class="comment">//将堆中的元素“倒”出来</span></span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            ans.push_back(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_39</title>
      <link href="/2020/09/28/jzof-39/"/>
      <url>/2020/09/28/jzof-39/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h1><div class="table-container"><table><thead><tr><th></th><th>哈希表法</th><th>排序法</th><th>摩尔投票法</th></tr></thead><tbody><tr><td>时间复杂度</td><td>O(N)</td><td>O(N*logN)</td><td>O(N)</td></tr><tr><td>空间复杂度</td><td>O(N)</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><h2 id="哈希表法和排序法：略"><a href="#哈希表法和排序法：略" class="headerlink" title="哈希表法和排序法：略"></a>哈希表法和排序法：略</h2><h2 id="摩尔投票法：如果一个数字出现的次数超过数组长度的一半，则除掉一个这样的树和其他的数，这个数依然是剩下数组的多数元素。设置两个变量num和count，num用来记录当前统计的数字，count用来记录num出现过的次数，如果出现不是num的数字则会抵消（也就是count减一）。"><a href="#摩尔投票法：如果一个数字出现的次数超过数组长度的一半，则除掉一个这样的树和其他的数，这个数依然是剩下数组的多数元素。设置两个变量num和count，num用来记录当前统计的数字，count用来记录num出现过的次数，如果出现不是num的数字则会抵消（也就是count减一）。" class="headerlink" title="摩尔投票法：如果一个数字出现的次数超过数组长度的一半，则除掉一个这样的树和其他的数，这个数依然是剩下数组的多数元素。设置两个变量num和count，num用来记录当前统计的数字，count用来记录num出现过的次数，如果出现不是num的数字则会抵消（也就是count减一）。"></a>摩尔投票法：如果一个数字出现的次数超过数组长度的一半，则除掉一个这样的树和其他的数，这个数依然是剩下数组的多数元素。设置两个变量num和count，num用来记录当前统计的数字，count用来记录num出现过的次数，如果出现不是num的数字则会抵消（也就是count减一）。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>, num = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            count = num != nums[i] ? count - <span class="number">1</span> : count + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)count = <span class="number">1</span>, num = nums[i];  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_38</title>
      <link href="/2020/09/28/jzof-38/"/>
      <url>/2020/09/28/jzof-38/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h1><h2 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h2><ol><li>“所有排列”</li><li>“任意顺序返回”</li><li>“不能有重复元素”</li></ol><h2 id="假设这道题给的字符串中各个字符不相同，则可以用算法课上学的perm1（基于交换的），就算字符串中有相同字符，也可以通过set去重，但是这样效率贼低。下面先贴用set去重的代码："><a href="#假设这道题给的字符串中各个字符不相同，则可以用算法课上学的perm1（基于交换的），就算字符串中有相同字符，也可以通过set去重，但是这样效率贼低。下面先贴用set去重的代码：" class="headerlink" title="假设这道题给的字符串中各个字符不相同，则可以用算法课上学的perm1（基于交换的），就算字符串中有相同字符，也可以通过set去重，但是这样效率贼低。下面先贴用set去重的代码："></a>假设这道题给的字符串中各个字符不相同，则可以用算法课上学的perm1（基于交换的），就算字符串中有相同字符，也可以通过set去重，但是这样效率贼低。下面先贴用set去重的代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; SET;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> index, <span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == s.<span class="built_in">size</span>())SET.insert(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            swap(s[i], s[index]);</span><br><span class="line">            helper(index + <span class="number">1</span>, s);</span><br><span class="line">            swap(s[i], s[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        helper(<span class="number">0</span>, s);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">ans</span><span class="params">(SET.<span class="built_in">begin</span>(), SET.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>排列方案数量： 对于一个长度为 n的字符串（假设字符互不重复），其排列共有n!种方案。</p><p>排列方案的生成方法： 根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 1 位字符（ n 种情况）、再固定第 2 位字符（ n−1 种情况）、… 、最后固定第 n 位字符（ 1 种情况</p><p>当字符串出现重复字符时，会出现相同的方案，我们可以通过剪枝操作，就说如果当前位置，已经固定了某个字符时，接下来在其后面寻找代替字符时（通过交换），如果这个字符已经在之前固定了一次，则不用在固定多一次（交换）。可以用在每个位置可以用set来达到这效果。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/mian-shi-ti-38-zi-fu-chuan-de-pai-lie-hui-su-fa-by/">参考链接</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> index, <span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == s.<span class="built_in">size</span>())ans.push_back(s);</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; SET;<span class="comment">//用set来记录当前位置已经出现过的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(SET.count(s[i]))<span class="keyword">continue</span>;<span class="comment">//已经出现过的话，则直接跳过</span></span><br><span class="line">            <span class="keyword">else</span> SET.insert(s[i]);<span class="comment">//否则加入set</span></span><br><span class="line">            <span class="comment">//通过交换，来遍历在此位置所有放的字符</span></span><br><span class="line">            swap(s[i], s[index]);</span><br><span class="line">            helper(index + <span class="number">1</span>, s);</span><br><span class="line">            swap(s[i], s[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        helper(<span class="number">0</span>, s);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_37</title>
      <link href="/2020/09/28/jzof-37/"/>
      <url>/2020/09/28/jzof-37/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></h1><h2 id="一共有两个工作："><a href="#一共有两个工作：" class="headerlink" title="一共有两个工作："></a>一共有两个工作：</h2><ul><li><h2 id="序列化：就是层次遍历，然后用字符串记录节点的值，还有加入“null”的时机，只有当前节点所在深度小于树的深度时才需要加入“null”，还有一个非常重要的点：字符串拼接。就如serialize函数中-ans-“-”-to-string-tmp-gt-left-gt-val-如果改为ans-ans-“-”-to-string-tmp-gt-left-gt-val-的话，无论是时间或空间消耗都会上升一个数量级。leetcode上别人的解释-、常见字符串拼接方法效率比较-、csdn上的解释"><a href="#序列化：就是层次遍历，然后用字符串记录节点的值，还有加入“null”的时机，只有当前节点所在深度小于树的深度时才需要加入“null”，还有一个非常重要的点：字符串拼接。就如serialize函数中-ans-“-”-to-string-tmp-gt-left-gt-val-如果改为ans-ans-“-”-to-string-tmp-gt-left-gt-val-的话，无论是时间或空间消耗都会上升一个数量级。leetcode上别人的解释-、常见字符串拼接方法效率比较-、csdn上的解释" class="headerlink" title="序列化：就是层次遍历，然后用字符串记录节点的值，还有加入“null”的时机，只有当前节点所在深度小于树的深度时才需要加入“null”，还有一个非常重要的点：字符串拼接。就如serialize函数中 ans += (“,” + to_string(tmp-&gt;left-&gt;val)); 如果改为ans = ans + “,” + to_string(tmp-&gt;left-&gt;val);的话，无论是时间或空间消耗都会上升一个数量级。leetcode上别人的解释   、常见字符串拼接方法效率比较  、csdn上的解释"></a>序列化：就是层次遍历，然后用字符串记录节点的值，还有加入“null”的时机，只有当前节点所在深度小于树的深度时才需要加入“null”，还有一个<strong>非常重要的点：字符串拼接</strong>。就如serialize函数中 ans += (“,” + to_string(tmp-&gt;left-&gt;val)); 如果改为ans = ans + “,” + to_string(tmp-&gt;left-&gt;val);的话，无论是时间或空间消耗都会上升一个数量级。<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/zha-zha-fa-xian-de-wen-ti-xi-wang-geng-duo-ren-kan/">leetcode上别人的解释</a>   、<a href="https://www.cnblogs.com/james6176/p/3222671.html">常见字符串拼接方法效率比较</a>  、<a href="https://blog.csdn.net/xiaobaismiley/article/details/25962483?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-25962483.nonecase&amp;utm_term=c++%20%E5%8A%A0%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5">csdn上的解释</a></h2></li><li><h2 id="反序列化：同样是层次遍历，根据字符串来建树，难点就是对substr取子串和stoi（字符串转整数）的运用，序列化则是对to-string的运用。"><a href="#反序列化：同样是层次遍历，根据字符串来建树，难点就是对substr取子串和stoi（字符串转整数）的运用，序列化则是对to-string的运用。" class="headerlink" title="反序列化：同样是层次遍历，根据字符串来建树，难点就是对substr取子串和stoi（字符串转整数）的运用，序列化则是对to_string的运用。"></a>反序列化：同样是层次遍历，根据字符串来建树，难点就是对substr取子串和stoi（字符串转整数）的运用，序列化则是对to_string的运用。</h2></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> getDepth(TreeNode *root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> max(getDepth(root-&gt;left), getDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">string</span> serialize(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> level = getDepth(root);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">string</span> ans = <span class="string">&quot;[&quot;</span> + to_string(root-&gt;val);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="keyword">empty</span>())&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">                TreeNode *tmp = q.front(); q.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    ans += (<span class="string">&quot;,&quot;</span> + to_string(tmp-&gt;left-&gt;val));</span><br><span class="line">                    q.push(tmp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != level)ans += <span class="string">&quot;,null&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    ans += (<span class="string">&quot;,&quot;</span> + to_string(tmp-&gt;right-&gt;val));</span><br><span class="line">                    q.push(tmp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != level)ans += <span class="string">&quot;,null&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    TreeNode* deserialize(<span class="keyword">string</span> data) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data.size() == <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找到根节点的值</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span> &lt;= data[j] &amp;&amp; data[j] &lt;= <span class="string">&#x27;9&#x27;</span>)++j;</span><br><span class="line">        <span class="keyword">int</span> rootValue = stoi(data.substr(i, j - i));</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(rootValue);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//bfs建树</span></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(data[j] != <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            TreeNode *tmp = q.front(); q.pop();</span><br><span class="line"></span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[i] == <span class="string">&#x27;n&#x27;</span>)&#123;</span><br><span class="line">                j += <span class="number">5</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span> &lt;= data[j] &amp;&amp; data[j] &lt;= <span class="string">&#x27;9&#x27;</span>)++j; </span><br><span class="line">                <span class="keyword">int</span> val =  stoi(data.substr(i, j - i));</span><br><span class="line">                TreeNode *node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                tmp-&gt;left = node;</span><br><span class="line">                q.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[i] == <span class="string">&#x27;n&#x27;</span>)&#123;</span><br><span class="line">                j += <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span> &lt;= data[j] &amp;&amp; data[j] &lt;= <span class="string">&#x27;9&#x27;</span>)++j;</span><br><span class="line">                <span class="keyword">int</span> val =  stoi(data.substr(i, j - i));</span><br><span class="line">                TreeNode *node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                tmp-&gt;right = node;</span><br><span class="line">                q.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_36</title>
      <link href="/2020/09/28/jzof-36/"/>
      <url>/2020/09/28/jzof-36/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></h1><h2 id="题解"><a href="#题解" class="headerlink" title="题解:"></a>题解:</h2><blockquote><p>因为题目中链表的节点值的顺序是从小到大的，符合BST的中序遍历序列，所以我们采用中序遍历来将树来变成一个双向链表。下面是用栈来模拟中序遍历，然后逐个节点连接起来。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Node *head, *cur, *tmp, *prev;</span><br><span class="line">        head = cur  = prev = <span class="literal">NULL</span>;</span><br><span class="line">        tmp = root;</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(tmp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                s.push(tmp);</span><br><span class="line">                tmp = tmp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = s.top(); s.pop();</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">NULL</span>)head = tmp;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">            <span class="comment">//以下两步就是连接cur和pre节点</span></span><br><span class="line">            cur-&gt;left = prev;</span><br><span class="line">            <span class="keyword">if</span>(prev != <span class="literal">NULL</span>)prev-&gt;right = cur;</span><br><span class="line">            </span><br><span class="line">            tmp = tmp-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">while</span>(!s.empty() || tmp);</span><br><span class="line">        <span class="comment">//将头尾节点连接起来</span></span><br><span class="line">        head-&gt;left = cur;</span><br><span class="line">        cur-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归版的中序遍历，只需要几个全局变量来记录头尾节点以及前一个节点就可以了。"><a href="#递归版的中序遍历，只需要几个全局变量来记录头尾节点以及前一个节点就可以了。" class="headerlink" title="递归版的中序遍历，只需要几个全局变量来记录头尾节点以及前一个节点就可以了。"></a>递归版的中序遍历，只需要几个全局变量来记录头尾节点以及前一个节点就可以了。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *head, *prev, *tail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        inorder(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//连接root和prev两个节点</span></span><br><span class="line">        root-&gt;left = prev;</span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="literal">NULL</span>)prev-&gt;right = root;</span><br><span class="line">        <span class="keyword">else</span> head = root;<span class="comment">//记录头结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接完成后将prev指向当前节点</span></span><br><span class="line">        prev = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录尾节点</span></span><br><span class="line">        tail = root;</span><br><span class="line">   </span><br><span class="line">        inorder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        head = tail = prev = <span class="literal">NULL</span>;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="comment">//连接头尾节点</span></span><br><span class="line">        head-&gt;left = tail;</span><br><span class="line">        tail-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_34</title>
      <link href="/2020/09/28/jzof-34/"/>
      <url>/2020/09/28/jzof-34/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h1><h2 id="先序遍历和路径记录，路径记录用一个vector即可"><a href="#先序遍历和路径记录，路径记录用一个vector即可" class="headerlink" title="先序遍历和路径记录，路径记录用一个vector即可"></a>先序遍历和路径记录，路径记录用一个vector即可</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//其实就是先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> s, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        <span class="comment">//将当前节点的值加上</span></span><br><span class="line">        s += root-&gt;val;</span><br><span class="line">        <span class="comment">//如果当前路径和与目标值相等且当前节点为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(s == sum &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            ans.push_back(path);</span><br><span class="line">        dfs(root-&gt;left, s, sum);</span><br><span class="line">        dfs(root-&gt;right, s, sum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_33</title>
      <link href="/2020/09/28/jzof-33/"/>
      <url>/2020/09/28/jzof-33/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h1><h2 id="观察BST后序遍历的特性，最后一个为根节点，比根节点小的节点都是属于左子树，比根节点大的节点都是属于右子树。违背上面规则的话就不是BST。"><a href="#观察BST后序遍历的特性，最后一个为根节点，比根节点小的节点都是属于左子树，比根节点大的节点都是属于右子树。违背上面规则的话就不是BST。" class="headerlink" title="观察BST后序遍历的特性，最后一个为根节点，比根节点小的节点都是属于左子树，比根节点大的节点都是属于右子树。违背上面规则的话就不是BST。"></a>观察BST后序遍历的特性，最后一个为根节点，比根节点小的节点都是属于左子树，比根节点大的节点都是属于右子树。违背上面规则的话就不是BST。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;postorder, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果当前区间没有元素或只有一个元素返回true</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= <span class="built_in">end</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//当前区间最后一个元素为根节点的值</span></span><br><span class="line">        <span class="keyword">int</span> rootValue = postorder[<span class="built_in">end</span>];</span><br><span class="line">        <span class="comment">//比根节点小的都是左子树的节点</span></span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; <span class="built_in">end</span> &amp;&amp; postorder[i] &lt;= rootValue)</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="comment">//除了左子树外剩下的应该都是右子树的节点，应该都比根节点大</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; <span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">if</span>(postorder[j++] &lt; rootValue)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果上面没有出错，接下来递归调用</span></span><br><span class="line">        <span class="keyword">return</span> helper(postorder, start, i - <span class="number">1</span>) &amp;&amp; helper(postorder, i, <span class="built_in">end</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_32</title>
      <link href="/2020/09/28/jzof-32/"/>
      <url>/2020/09/28/jzof-32/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h1><p>题解：直接用bfs遍历二叉树，因为要求从左到右，所以入队时也是按照从左到右的顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *t=q.front();q.pop();</span><br><span class="line">            ans.push_back(t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h1><p>题解：在上面的代码的基础上稍作修改，就可以达到一层一层的打印效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        TreeNode *t;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="comment">//这就是比上面代码多出的步骤</span></span><br><span class="line">            <span class="comment">//用于表示当前层有多少个节点</span></span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span>=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">size</span>--)&#123;</span><br><span class="line">                t=q.front();q.pop();</span><br><span class="line">                v.push_back(t-&gt;val);</span><br><span class="line">                <span class="comment">//将下一层的节点入队</span></span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h1><p>思路：和第二题一样，如果需要从右到左的话，就在遍历完每层的节点后，将得到的序列逆序即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">bool</span> left_to_right = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">                TreeNode *tmp = q.front(); q.pop();</span><br><span class="line">                v.push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left)q.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right)q.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!left_to_right)&#123;</span><br><span class="line">                reverse(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">                left_to_right = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left_to_right = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="当然还可以使用双端队列来完成"><a href="#当然还可以使用双端队列来完成" class="headerlink" title="当然还可以使用双端队列来完成"></a>当然还可以使用双端队列来完成</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        q.push_back(root);</span><br><span class="line">        <span class="keyword">bool</span> left_to_right = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            TreeNode *t;</span><br><span class="line">            <span class="keyword">if</span>(left_to_right)&#123;<span class="comment">//从左到右</span></span><br><span class="line">                <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">                    t = q.front(); q.pop_front();</span><br><span class="line">                    v.push_back(t-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(t-&gt;left)q.push_back(t-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(t-&gt;right)q.push_back(t-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//从右到左</span></span><br><span class="line">                <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">                    t = q.back(); q.pop_back();</span><br><span class="line">                    v.push_back(t-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(t-&gt;right)q.push_front(t-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span>(t-&gt;left)q.push_front(t-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(v);</span><br><span class="line">            left_to_right = left_to_right ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_31</title>
      <link href="/2020/09/28/jzof-31/"/>
      <url>/2020/09/28/jzof-31/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h1><p>先将第一个序列入栈，然后再根据第二个序列出栈。</p><h2 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : pushed)&#123;</span><br><span class="line">            s.push(num);</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() == popped[i])&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法2：与上面的类似，不过用来原来的数组作为栈"><a href="#方法2：与上面的类似，不过用来原来的数组作为栈" class="headerlink" title="方法2：与上面的类似，不过用来原来的数组作为栈"></a>方法2：与上面的类似，不过用来原来的数组作为栈</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//i所指的就是栈顶的上一个位置，即push新元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : pushed)&#123;</span><br><span class="line">            pushed[i] = num;<span class="comment">//相当于栈push</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; pushed[i] == popped[j])&#123;</span><br><span class="line">                ++j;</span><br><span class="line">                --i;<span class="comment">//pop</span></span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i等于0表示栈为空</span></span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_30</title>
      <link href="/2020/09/28/jzof-30/"/>
      <url>/2020/09/28/jzof-30/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h1><h2 id="普通的栈有push和pop操作，题目增添了一个min操作，且要求这三个操作的时间复杂度为O-1"><a href="#普通的栈有push和pop操作，题目增添了一个min操作，且要求这三个操作的时间复杂度为O-1" class="headerlink" title="普通的栈有push和pop操作，题目增添了一个min操作，且要求这三个操作的时间复杂度为O(1)"></a>普通的栈有push和pop操作，题目增添了一个min操作，且要求这三个操作的时间复杂度为O(1)</h2><p>我们可以将当前栈中最小的元素用另一个栈储存，此时就详细的分析三个操作</p><p>（设用来存储元素的栈称为a，辅助栈称为b）</p><ul><li>push：新元素直接加入到a栈，而对b栈来说，如果b栈为空，直接加入b栈（因为此时a栈在加入新元素前也肯定为空的，此时这个新元素就是a栈中的最小元素）；如果b栈不为空，就要将新元素与b栈的栈顶比较，如果新元素比b栈栈顶元素小或者相等则加入b栈。（总之，我们要b栈的栈顶元素为a栈的最小元素）</li><li>pop：a栈直接pop，b栈的话要看a栈pop出来的元素是否与b栈的栈顶元素相等，如果相等，则b栈也pop（此时a栈的最小元素为b栈pop后的栈顶元素）；相等的话，则b栈不操作</li><li>min：直接返回b栈的栈顶元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        a.push(x);</span><br><span class="line">        <span class="keyword">if</span>(b.empty() || x &lt;= b.top())b.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a.top();</span><br><span class="line">        a.pop();</span><br><span class="line">        <span class="keyword">if</span>(!b.empty() &amp;&amp; x == b.top())b.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_29</title>
      <link href="/2020/09/28/jzof-29/"/>
      <url>/2020/09/28/jzof-29/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h1><blockquote><p>分四个方向去打印：→、↓、←、↑，每打印一个方向后需要改变边界值。难点就在于边界值的确定以及确定终止条件。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> left, right, up, down, i, j, sum = matrix.<span class="built_in">size</span>()*matrix[<span class="number">0</span>].<span class="built_in">size</span>(), num = <span class="number">0</span>;</span><br><span class="line">        left = <span class="number">0</span>; right = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; up = <span class="number">0</span>; down = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; sum)&#123;</span><br><span class="line">            i = up; j = left;</span><br><span class="line">            <span class="comment">//从左到右</span></span><br><span class="line">            <span class="keyword">while</span>(num &lt; sum &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">                ans.push_back(matrix[i][j]);</span><br><span class="line">                ++j;</span><br><span class="line">                ++num;</span><br><span class="line">            &#125;</span><br><span class="line">            ++up; --j; ++i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从上到下</span></span><br><span class="line">            <span class="keyword">while</span>(num &lt; sum &amp;&amp; i &lt;= down)&#123;</span><br><span class="line">                ans.push_back(matrix[i][j]);</span><br><span class="line">                ++i;</span><br><span class="line">                ++num;</span><br><span class="line">            &#125;</span><br><span class="line">            --right; --i; --j;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从右到左</span></span><br><span class="line">            <span class="keyword">while</span>(num &lt; sum &amp;&amp; j &gt;= left)&#123;</span><br><span class="line">                ans.push_back(matrix[i][j]);</span><br><span class="line">                --j;</span><br><span class="line">                ++num;</span><br><span class="line">            &#125;</span><br><span class="line">            --down; ++j; --i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从下到上</span></span><br><span class="line">            <span class="keyword">while</span>(num &lt; sum &amp;&amp; i &gt;= up)&#123;</span><br><span class="line">                ans.push_back(matrix[i][j]);</span><br><span class="line">                --i;</span><br><span class="line">                ++num;</span><br><span class="line">            &#125; </span><br><span class="line">            ++left; ++i; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_28</title>
      <link href="/2020/09/28/jzof-28/"/>
      <url>/2020/09/28/jzof-28/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h1><p>对称二叉树是关于以过根节点的垂线为轴的轴对称树。将这棵树的左右子树看为两棵树，先比较当前节点的值是否相同，然后是两棵树的子树比较，左子树的右子树与右子树的左子树比较、左子树的左子树与右子树的右子树比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode *p, TreeNode *q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p &amp;&amp; !q)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((p &amp;&amp; !q) || (!p &amp;&amp; q) || (p-&gt;val != q-&gt;val))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSame(p-&gt;left, q-&gt;right) &amp;&amp; isSame(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSame(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_27</title>
      <link href="/2020/09/28/jzof-27/"/>
      <url>/2020/09/28/jzof-27/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h1><p>所谓镜像就是将每个节点的左右子树调换。直接上代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode *t = root-&gt;left;</span><br><span class="line">        root-&gt;left = mirrorTree(root-&gt;right);</span><br><span class="line">        root-&gt;right = mirrorTree(t);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_26</title>
      <link href="/2020/09/28/jzof-26/"/>
      <url>/2020/09/28/jzof-26/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h1><h2 id="思路1："><a href="#思路1：" class="headerlink" title="思路1："></a>思路1：</h2><p>先用bfs在A树中找到与B树根节点值相同的节点，找到，就用判断两个点是否有相同子结构。</p><p>判断规则：</p><ol><li>如果B为空，返回true</li><li>如果A为空或者A和B节点不同，返回false；</li><li>不满足1、2点，则返回对左右子树的递归判断。</li></ol><h2 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h2><p>与思路1类似，只是不是通过bfs来准确找到某个点，而是全部点都试一试，1、判读以A为根节点的树与b树是否满足条件；2、判断以A的左孩子为根节点的树与b树是否满足条件；3、判断以A的右孩子为根节点的树与b树是否满足条件。以上三个节点满足其中之一即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode *p,TreeNode *B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>||B-&gt;val!=p-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left,B-&gt;left) &amp;&amp; isSameTree(p-&gt;right,B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (A&amp;&amp;B) &amp;&amp; (isSameTree(A,B) || isSubStructure(A-&gt;left,B) || isSubStructure(A-&gt;right,B));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_25</title>
      <link href="/2020/09/28/jzof-25/"/>
      <url>/2020/09/28/jzof-25/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h1><h2 id="简单的归并排序"><a href="#简单的归并排序" class="headerlink" title="简单的归并排序"></a>简单的归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *head=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *rear=head;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&gt;l2-&gt;val)&#123;</span><br><span class="line">                rear-&gt;next=l2;</span><br><span class="line">                rear=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                rear-&gt;next=l1;</span><br><span class="line">                rear=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rear-&gt;next = l1 == <span class="literal">NULL</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_24</title>
      <link href="/2020/09/28/jzof-24/"/>
      <url>/2020/09/28/jzof-24/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h1><h2 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode *tail = reverseList(head-&gt;next);<span class="comment">//先找到最后一个节点</span></span><br><span class="line">        head-&gt;next-&gt;next = head;<span class="comment">//将当前节点的下一个节点的next指向当前节点</span></span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;<span class="comment">//将当前节点的next断掉，否则会出现环</span></span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代："><a href="#迭代：" class="headerlink" title="迭代："></a>迭代：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = <span class="literal">NULL</span>, *pre = head;<span class="comment">//pre指向的cur节点在新链表顺序中的前一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (pre != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ListNode* t = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            cur = pre;</span><br><span class="line">            pre = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_23</title>
      <link href="/2020/09/28/jzof-23/"/>
      <url>/2020/09/28/jzof-23/</url>
      
        <content type="html"><![CDATA[<h1 id="23、链表中环的入口节点"><a href="#23、链表中环的入口节点" class="headerlink" title="23、链表中环的入口节点"></a>23、链表中环的入口节点</h1><h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h1><h2 id="双指针（快慢指针-）：先用快慢指针来检查链表中是否有环，如果有再寻找环的入口。"><a href="#双指针（快慢指针-）：先用快慢指针来检查链表中是否有环，如果有再寻找环的入口。" class="headerlink" title="双指针（快慢指针 ）：先用快慢指针来检查链表中是否有环，如果有再寻找环的入口。"></a>双指针（快慢指针 ）：先用快慢指针来检查链表中是否有环，如果有再寻找环的入口。</h2><ol><li>检查是否有环：快慢指针，慢指针每次走一步，快指针每次走两步，如果两个指针相遇，则链表中有环；如果快指针走到为空指针，则链表无环。</li><li>若第一步检查出有环，则将慢指针重新指向链表头，然后快慢指针以同样的速度（每次走一步）来走，直到两个指针相遇，此时相遇初就是链表环的入口节点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast-&gt;next == <span class="literal">NULL</span> || fast-&gt;next-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="当然快慢指针除了上面这个解决方法，还有其他。如果我知道环中有n个节点，我们可以先让快指针走n步，然后慢指针指向链表头，然后以相同速度（每次走一步），直到两者相遇，则相遇处为环的入口节点。（当然应该还是第一种更快吧？！）"><a href="#当然快慢指针除了上面这个解决方法，还有其他。如果我知道环中有n个节点，我们可以先让快指针走n步，然后慢指针指向链表头，然后以相同速度（每次走一步），直到两者相遇，则相遇处为环的入口节点。（当然应该还是第一种更快吧？！）" class="headerlink" title="当然快慢指针除了上面这个解决方法，还有其他。如果我知道环中有n个节点，我们可以先让快指针走n步，然后慢指针指向链表头，然后以相同速度（每次走一步），直到两者相遇，则相遇处为环的入口节点。（当然应该还是第一种更快吧？！）"></a>当然快慢指针除了上面这个解决方法，还有其他。如果我知道环中有n个节点，我们可以先让快指针走n步，然后慢指针指向链表头，然后以相同速度（每次走一步），直到两者相遇，则相遇处为环的入口节点。（当然应该还是第一种更快吧？！）</h2><h2 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h2><blockquote><p>已知环中节点有n个，设不在环中的节点有m个（m可以为任意值），所以链表一共有n+m个节点。所以从链表头走n+m-1步刚好走到链表的“尾部”；从链表头走n+m步刚好走到链表中环的入口节点。我们设第一个先走的指针为p1，第二个为p2。p1走了n步，p2开始指向链表头，此时p1和p2以每次走一步的速度前进，当走了m步后，p1和p2相遇，相遇处就是环入口节点。（因为p1走了n+m步，到了环入口节点；p2走了m步，同样走到环入口节点）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="comment">//先检查链表中是否有环</span></span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有环</span></span><br><span class="line">        <span class="keyword">if</span>(fast-&gt;next == <span class="literal">NULL</span> || fast-&gt;next-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//统计环中有多少个节点</span></span><br><span class="line">        ListNode *tmp = slow;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;<span class="keyword">while</span>(tmp != slow);</span><br><span class="line">        <span class="comment">//快慢指针以相同速度移动直至相遇</span></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_22</title>
      <link href="/2020/09/28/jzof-22/"/>
      <url>/2020/09/28/jzof-22/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h1><ul><li><h2 id="方法1：第一次遍历一次链表统计节点个数n，第二次遍历到第n-k个节点返回。"><a href="#方法1：第一次遍历一次链表统计节点个数n，第二次遍历到第n-k个节点返回。" class="headerlink" title="方法1：第一次遍历一次链表统计节点个数n，第二次遍历到第n-k个节点返回。"></a>方法1：第一次遍历一次链表统计节点个数n，第二次遍历到第n-k个节点返回。</h2></li><li><h2 id="方法2：双指针（first和second），first先走k步，然后second指针指向链表头，此时两个指针同时走，直到first指针为空-其实有三个方面需要注意：1、先检查head指针是否为空指针；2、防止链表节点个数小于k"><a href="#方法2：双指针（first和second），first先走k步，然后second指针指向链表头，此时两个指针同时走，直到first指针为空-其实有三个方面需要注意：1、先检查head指针是否为空指针；2、防止链表节点个数小于k" class="headerlink" title="方法2：双指针（first和second），first先走k步，然后second指针指向链表头，此时两个指针同时走，直到first指针为空.(其实有三个方面需要注意：1、先检查head指针是否为空指针；2、防止链表节点个数小于k)"></a>方法2：双指针（first和second），first先走k步，然后second指针指向链表头，此时两个指针同时走，直到first指针为空.(其实有三个方面需要注意：1、先检查head指针是否为空指针；2、防止链表节点个数小于k)</h2></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *first=head;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//first先走k步</span></span><br><span class="line">        <span class="keyword">while</span>(++i&lt;=k&amp;&amp;first)</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果链表没有k个节点，返回NULL</span></span><br><span class="line">        <span class="keyword">if</span>(!first&amp;&amp;i&lt;k)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *second=head;</span><br><span class="line">        <span class="comment">//接下来first和second一起走n-k步（n为链表长度）</span></span><br><span class="line">        <span class="keyword">while</span>(first)</span><br><span class="line">        &#123;</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_21</title>
      <link href="/2020/09/28/jzof-21/"/>
      <url>/2020/09/28/jzof-21/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h1><h2 id="双指针：用两个指针（left指针和right指针），left初始时指向第一个元素，right初始时指向最后一个元素。然后两个指针向中间移动，移动规则：1、左指针：若left所指的元素为奇数，则右移一位（直至指针所指元素为偶数或者left与right相遇）；2、右指针：若right所指的元素为偶数，则左移一位（直至指针所指元素为奇数或者right与left相遇）。这个解法复杂度为O-N-。"><a href="#双指针：用两个指针（left指针和right指针），left初始时指向第一个元素，right初始时指向最后一个元素。然后两个指针向中间移动，移动规则：1、左指针：若left所指的元素为奇数，则右移一位（直至指针所指元素为偶数或者left与right相遇）；2、右指针：若right所指的元素为偶数，则左移一位（直至指针所指元素为奇数或者right与left相遇）。这个解法复杂度为O-N-。" class="headerlink" title="双指针：用两个指针（left指针和right指针），left初始时指向第一个元素，right初始时指向最后一个元素。然后两个指针向中间移动，移动规则：1、左指针：若left所指的元素为奇数，则右移一位（直至指针所指元素为偶数或者left与right相遇）；2、右指针：若right所指的元素为偶数，则左移一位（直至指针所指元素为奇数或者right与left相遇）。这个解法复杂度为O(N)。"></a>双指针：用两个指针（left指针和right指针），left初始时指向第一个元素，right初始时指向最后一个元素。然后两个指针向中间移动，移动规则：1、左指针：若left所指的元素为奇数，则右移一位（直至指针所指元素为偶数或者left与right相遇）；2、右指针：若right所指的元素为偶数，则左移一位（直至指针所指元素为奇数或者right与left相遇）。这个解法复杂度为O(N)。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; (nums[left]&amp;<span class="number">1</span>))</span><br><span class="line">                ++left;</span><br><span class="line">            <span class="keyword">while</span>(right &gt; left &amp;&amp; !(nums[right]&amp;<span class="number">1</span>))</span><br><span class="line">                --right;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)swap(nums[left], nums[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>考虑扩展性：</p><p>如果</p><ul><li>要将正数和负数放到数字的两边</li><li>要将能被3整除或者不能被3整除的放在两边</li><li>。。。。。</li></ul><p>这时，我们可以将我中间两个while语句中的判断条件抽象为一个函数，然后通过函数指针调用，来扩展不同的判断标准。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_18</title>
      <link href="/2020/09/28/jzof-18/"/>
      <url>/2020/09/28/jzof-18/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h1><p>直接上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val==val)<span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="comment">//由于不是双链表，需要一个指针记录删除节点的前节点</span></span><br><span class="line">        ListNode *pre=head;</span><br><span class="line">        ListNode *t=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(t-&gt;val!=val)&#123;</span><br><span class="line">            t=t-&gt;next;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时t为删除节点</span></span><br><span class="line">        <span class="comment">//所谓删除就是将删除节点跳过</span></span><br><span class="line">        pre-&gt;next=t-&gt;next;</span><br><span class="line">        <span class="comment">//delete t;</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而剑指offer上的要求不是这样的，其要求在O(1)时间内完成删除节点操作。</p><p>上面的解法是顺序查找，复杂度为O(N) </p>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_17</title>
      <link href="/2020/09/28/jzof-17/"/>
      <url>/2020/09/28/jzof-17/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a></h1><p>这题如果是如leetcode上面考的话没有难度，我们需要考虑的是如果我们需要打印的数超过了int，long，甚至long long的范围，如何处理，这是需要用字符串来解决。</p><ul><li><h2 id="方法1：用字符串模拟数字加法"><a href="#方法1：用字符串模拟数字加法" class="headerlink" title="方法1：用字符串模拟数字加法"></a>方法1：用字符串模拟数字加法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increase</span><span class="params">(<span class="built_in">string</span> &amp;num)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = num.<span class="built_in">size</span>(), i = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> carry = <span class="number">1</span>;<span class="comment">//进位 </span></span><br><span class="line"><span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> sum = num[i] - <span class="string">&#x27;0&#x27;</span> + carry;</span><br><span class="line">num[i] = sum % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">carry = sum / <span class="number">10</span>;<span class="comment">//计算当前位之和是否有进1 </span></span><br><span class="line">--i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(carry)num = <span class="string">&quot;1&quot;</span> + num;<span class="comment">//如果有进位，则在num的最左边加一个1 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Max</span><span class="params">(n, <span class="string">&#x27;9&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">num</span><span class="params">(<span class="number">1</span>, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(num &lt; Max)&#123;<span class="comment">//逐个数字输出 </span></span><br><span class="line">Increase(num);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Max&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">printNumbers(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><h2 id="方法2：全排列"><a href="#方法2：全排列" class="headerlink" title="方法2：全排列"></a>方法2：全排列</h2></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_e</span><span class="params">(<span class="keyword">char</span> *number, <span class="keyword">int</span> length)</span></span>&#123;<span class="comment">//自定义打印函数</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; length &amp;&amp; number[i] == <span class="string">&#x27;0&#x27;</span>)++i;<span class="comment">//忽略前缀0 </span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; length)<span class="built_in">cout</span>&lt;&lt;number[i++];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumbersRecurisely</span><span class="params">(<span class="keyword">char</span> *number, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span></span>&#123;<span class="comment">//递归生成数字 </span></span><br><span class="line">    <span class="keyword">if</span>(index == length - <span class="number">1</span>)&#123;<span class="comment">//如果数字位数已经够了 </span></span><br><span class="line">        print_e(number, length);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">        number[index + <span class="number">1</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        printNumbersRecurisely(number, length, index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    number[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">        number[<span class="number">0</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        printNumbersRecurisely(number, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> [] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">printNumbers(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_16</title>
      <link href="/2020/09/28/jzof-16/"/>
      <url>/2020/09/28/jzof-16/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h1><script type="math/tex; mode=display">pow(x,n)=\begin{cases}pow(x,n/2)^{2}& \text{n为偶数}\\pow(x,n/2)^{2}*x& \text{n是奇数}\end{cases}</script><p>唯一需要注意的是，要检查n是否为正数，不是的话就将其转为相反数，x转为其倒数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">double</span> sum = helper(x, n/<span class="number">2</span>);</span><br><span class="line">        sum *= sum;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> ==<span class="number">1</span>)sum *= x;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span>(N &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1.0</span> / x;</span><br><span class="line">            N = -N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(x, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_15</title>
      <link href="/2020/09/28/jzof-15/"/>
      <url>/2020/09/28/jzof-15/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h1><p>两种方法：</p><ul><li><h2 id="第一种：逐位统计"><a href="#第一种：逐位统计" class="headerlink" title="第一种：逐位统计"></a>第一种：逐位统计</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>)++ans;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="上面这种解法在这条题目是可行的，因为输入的是无符号数。但是一旦输入的是有符号数且为负数，就会出现意料之外的事情。"><a href="#上面这种解法在这条题目是可行的，因为输入的是无符号数。但是一旦输入的是有符号数且为负数，就会出现意料之外的事情。" class="headerlink" title="上面这种解法在这条题目是可行的，因为输入的是无符号数。但是一旦输入的是有符号数且为负数，就会出现意料之外的事情。"></a>上面这种解法在这条题目是可行的，因为输入的是无符号数。但是一旦输入的是有符号数且为负数，就会出现意料之外的事情。</h3><blockquote><p>我们先来复习一下数字左移、右移的步骤</p><p>首先是左移：m&lt;&lt;n表示m左移n位，将m最左边的n位弃掉，然后在最右边补n个0</p><p>再接这是右移：m&gt;&gt;n表示m右移n位，如果m是无符号数，则将m的最右n位弃掉，然后在最左边补n个0，如果m不是无符号数的话，则将m的右n位弃掉，然后在最左边补n个与符号位相同的值。</p></blockquote><p>有了这个知识后，我们可知如果负数右移的话，补的是1，这样移动的话，最终n是不会变为0的，也成了死循环。所以有了一下这种解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&amp;(<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>先用1与n作位于操作，统计最低位是否为1，然后1左移一位，统计左数第二位是否为1，以此类推。</p></blockquote><ul><li><h2 id="位运算："><a href="#位运算：" class="headerlink" title="位运算："></a>位运算：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="comment">//n&amp;(n−1) 解析： 二进制数字 nn 最右边的 11 变成 00 ，其余不变。</span></span><br><span class="line">            n&amp;=(n<span class="number">-1</span>);</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们观察可知n-1就是将n的最右边的1变为0，这个位右边的0变为1，n&amp;(n-1)就是将n的最右边1及其右边全部位变为0，这样可以减少迭代次数。</p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_14</title>
      <link href="/2020/09/28/jzof-14/"/>
      <url>/2020/09/28/jzof-14/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h1><h1 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></h1><ul><li><h2 id="第一题：我们观察求解过程，每一步都有一个最优解，每一部分都是可以分为规模更小的题目来解答，满足动态规划的求解特征。回到问题：一段绳子可以减为两段，然后剪出来的两段绳子可以继续剪。由于我们不止那种剪法是最优的，所以要检查所有剪法，求其中乘积最大值。至于证明，不会！参考其他人的证明："><a href="#第一题：我们观察求解过程，每一步都有一个最优解，每一部分都是可以分为规模更小的题目来解答，满足动态规划的求解特征。回到问题：一段绳子可以减为两段，然后剪出来的两段绳子可以继续剪。由于我们不止那种剪法是最优的，所以要检查所有剪法，求其中乘积最大值。至于证明，不会！参考其他人的证明：" class="headerlink" title="第一题：我们观察求解过程，每一步都有一个最优解，每一部分都是可以分为规模更小的题目来解答，满足动态规划的求解特征。回到问题：一段绳子可以减为两段，然后剪出来的两段绳子可以继续剪。由于我们不止那种剪法是最优的，所以要检查所有剪法，求其中乘积最大值。至于证明，不会！参考其他人的证明："></a>第一题：我们观察求解过程，每一步都有一个最优解，每一部分都是可以分为规模更小的题目来解答，满足动态规划的求解特征。回到问题：一段绳子可以减为两段，然后剪出来的两段绳子可以继续剪。由于我们不止那种剪法是最优的，所以要检查所有剪法，求其中乘积最大值。至于证明，不会！参考其他人的证明：</h2></li></ul><h3 id="贪心法证明"><a href="#贪心法证明" class="headerlink" title="贪心法证明"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/">贪心法证明</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]代表integerBreak(i)</span></span><br><span class="line">        <span class="comment">//i至少由两个数(x,y)之和组成，(x,y)可以进行同样的操作（分成两个数）</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//将前面小的值先写入</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;dp[<span class="number">2</span>]=<span class="number">2</span>;dp[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">        <span class="comment">//从长度为4的绳子开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i/<span class="number">2</span>;++j)&#123;<span class="comment">//检查所有剪法，求其中乘积最大值</span></span><br><span class="line">                Max = <span class="built_in">max</span>(Max, dp[j]*dp[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = Max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><h2 id="第二题：其实第一题和第二题几乎一样，就是输入n的范围不同，第二题的范围更大，如果我们同样使用动态规划来解决第二题会发现超时，因为动态规划的复杂度为O-N-2-所以要寻求更高效的办法—贪心法。我们需要尽量剪出长度为3的绳子，这样最后得出乘积最大。"><a href="#第二题：其实第一题和第二题几乎一样，就是输入n的范围不同，第二题的范围更大，如果我们同样使用动态规划来解决第二题会发现超时，因为动态规划的复杂度为O-N-2-所以要寻求更高效的办法—贪心法。我们需要尽量剪出长度为3的绳子，这样最后得出乘积最大。" class="headerlink" title="第二题：其实第一题和第二题几乎一样，就是输入n的范围不同，第二题的范围更大，如果我们同样使用动态规划来解决第二题会发现超时，因为动态规划的复杂度为O(N^2).所以要寻求更高效的办法—贪心法。我们需要尽量剪出长度为3的绳子，这样最后得出乘积最大。"></a>第二题：其实第一题和第二题几乎一样，就是输入n的范围不同，第二题的范围更大，如果我们同样使用动态规划来解决第二题会发现超时，因为动态规划的复杂度为O(N^2).所以要寻求更高效的办法—贪心法。我们需要尽量剪出长度为3的绳子，这样最后得出乘积最大。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果n&lt;3，直接返回n-1</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)<span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//尽量减出长度为3的绳子</span></span><br><span class="line">        <span class="keyword">int</span> timesOf3 = n / <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//如果减了若干个长度为三大绳子后，还剩一个1，这样的话，就是有一个4</span></span><br><span class="line">        <span class="comment">//如果长度为4的话分为2、2比3、1好，所以此时要将长度为3的绳子段数减一</span></span><br><span class="line">        <span class="keyword">if</span>(n - timesOf3*<span class="number">3</span> == <span class="number">1</span>)timesOf3--;</span><br><span class="line">        <span class="comment">//如果绳子减了若干段长度为3的绳子后，还剩下的要乘上</span></span><br><span class="line">        <span class="keyword">if</span>(n - timesOf3*<span class="number">3</span>)ans *= n - timesOf3*<span class="number">3</span>; </span><br><span class="line">        <span class="comment">//本来可以直接用pow(3,timesOf3),但是这样会溢出，所以用while</span></span><br><span class="line">        <span class="keyword">while</span>(timesOf3--)ans = (ans*<span class="number">3</span>%<span class="number">1000000007</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_13</title>
      <link href="/2020/09/28/jzof-13/"/>
      <url>/2020/09/28/jzof-13/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h1><p>见到题目的时候，你可能回想直接遍历二维数组的每个坐标看有几个左边是满足和小于等于k的，那这个数就是答案。但是仔细一想，有没有这种可能一个坐标是满足和小于等于k，但是它无法有其他满足条件的点走过来。答案是有的。所以我们只能从[0,0]进行bfs，将其周围满足条件的点入队，同时也要标记以入队的点，防止一个点重复入队。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//检查[x,y]之“和&quot;是否小于等于k</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(y)&#123;</span><br><span class="line">            sum += y % <span class="number">10</span>;</span><br><span class="line">            y /= <span class="number">10</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上下左右四个方向</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; direction = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//访问标志矩阵</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>; </span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(<span class="number">0</span>);q.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">int</span> y = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> newx = x + direction[<span class="number">2</span>*i], newy = y + direction[<span class="number">2</span>*i + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//如果坐标越界或者已经访问过的话就跳过该点</span></span><br><span class="line">                <span class="keyword">if</span>(newx == m || newx &lt; <span class="number">0</span> || newy == n || newy &lt; <span class="number">0</span> || visited[newx][newy])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(check(newx, newy, k))&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    visited[newx][newy] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(newx); q.push(newy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_12</title>
      <link href="/2020/09/28/jzof-12/"/>
      <url>/2020/09/28/jzof-12/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h1><h2 id="回溯法："><a href="#回溯法：" class="headerlink" title="回溯法："></a>回溯法：</h2><blockquote><p>见题“路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格”我们可得知每一个位置有四个方向可以走，如果走不通在回溯到上一个节点尝试其他方向。同时由于要标记已走过的路径，需要一个矩阵visited来标记位置是否已经走过。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果走完了字符串</span></span><br><span class="line">        <span class="keyword">if</span>(pos == WORD.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//判断位置是否越界或者是否已经访问过</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x == row || y &lt; <span class="number">0</span> || y == col || visited[x][y] || WORD[pos] != board[x][y])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//标记位置已访问</span></span><br><span class="line">        visited[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//四个方向中只要有一个走通就行</span></span><br><span class="line">        flag = dfs(board , visited, x - <span class="number">1</span>, y, pos + <span class="number">1</span>) || dfs(board , visited, x + <span class="number">1</span>, y, pos + <span class="number">1</span>) || dfs(board , visited, x, y - <span class="number">1</span>, pos + <span class="number">1</span>) || dfs(board , visited, x, y + <span class="number">1</span>, pos + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//恢复原状</span></span><br><span class="line">        visited[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        row = board.<span class="built_in">size</span>();</span><br><span class="line">        col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        WORD = <span class="keyword">word</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">visited</span><span class="params">(row , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col , <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;<span class="comment">//遍历矩阵</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="keyword">word</span>[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(board, visited, i , j , <span class="number">0</span>))&#123;<span class="comment">//如果字符与字符串第一个字符相同，就以该点为起点作dfs</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line">    <span class="built_in">string</span> WORD;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_11</title>
      <link href="/2020/09/28/jzof-11/"/>
      <url>/2020/09/28/jzof-11/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h1><p>观察旋转数组的特性，我们可知数组一共有两个递增序列组成，可能第二个递增序列的元素个数为0。</p><ol><li>如果中间元素比最后一个元素要小的话，证明最小元素是在第一个递增序列里。移动右指针。</li><li>如果中间元素比最后一个元素要大的话，证明最小元素是在第二个递增序列里。移动左指针。</li><li>如果中间元素和最后一个元素相等的话，证明最小元素是在第一个递增序列里。将右指针左移一位。</li></ol><blockquote><p>相信前面两点很容易理解，问题是第三点，为何要“将右指针左移一位”。由于第三种情况我们不能判断最小元素是位于前半段还是后半段，所以不能随便忽略某一部分。最右元素与中间元素相等，无论最右元素是否为最小元素，我们都可以将右指针左移动一位来缩小范围。因为最右元素有中间元素代替。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(left &lt;right)&#123;    </span><br><span class="line">     mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[right] &lt; numbers[mid])</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">if</span>(numbers[mid] &lt; numbers[right])  </span><br><span class="line">        right = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        --right;          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_10</title>
      <link href="/2020/09/28/jzof-10/"/>
      <url>/2020/09/28/jzof-10/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h1><h1 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h1><h3 id="问题三：用一个2×1的小矩形去覆盖一个大矩形，小矩形可以横着或竖着去覆盖，问有多少种想法。"><a href="#问题三：用一个2×1的小矩形去覆盖一个大矩形，小矩形可以横着或竖着去覆盖，问有多少种想法。" class="headerlink" title="问题三：用一个2×1的小矩形去覆盖一个大矩形，小矩形可以横着或竖着去覆盖，问有多少种想法。"></a>问题三：用一个2×1的小矩形去覆盖一个大矩形，小矩形可以横着或竖着去覆盖，问有多少种想法。</h3><p>题解：</p><blockquote><p>以上问题都是斐波那契数列的变式。</p></blockquote><h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划：由于递归重复计算很多，计算效率极低，我们将中间结果存储起来，可以避免重复计算。"><a href="#动态规划：由于递归重复计算很多，计算效率极低，我们将中间结果存储起来，可以避免重复计算。" class="headerlink" title="动态规划：由于递归重复计算很多，计算效率极低，我们将中间结果存储起来，可以避免重复计算。"></a>动态规划：由于递归重复计算很多，计算效率极低，我们将中间结果存储起来，可以避免重复计算。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    d.resize(<span class="number">101</span>);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[n]!=<span class="number">0</span>)<span class="keyword">return</span> d[n];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> r=(fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>))%<span class="number">1000000007</span>;</span><br><span class="line">            d[n]=r;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数学方法："><a href="#数学方法：" class="headerlink" title="数学方法："></a>数学方法：</h3><p>其实fib(n)</p><script type="math/tex; mode=display">fib(n) = \left[ \begin{matrix}1&1\\1&0 \end{matrix} \right]^{n-1}</script><p>其中求矩阵的n-1次方可以用求pow的相同方式去求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_9</title>
      <link href="/2020/09/28/jzof-9/"/>
      <url>/2020/09/28/jzof-9/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h1><p>队列主要有三个功能，</p><ul><li>front()：返回队首元素</li><li>pop()：在队首删除元素</li><li>push()：在队尾插入元素</li></ul><ul><li><h2 id="push操作复杂度为O-1-pop-操作复杂度为O-N"><a href="#push操作复杂度为O-1-pop-操作复杂度为O-N" class="headerlink" title="push操作复杂度为O(1),pop()操作复杂度为O(N)"></a>push操作复杂度为O(1),pop()操作复杂度为O(N)</h2></li></ul><blockquote><p>我们先来看看栈的特性，（如果入栈期间不出栈）出栈序列和入栈序列互为逆序，而对于队列来说，（如果入队期间不出队）入队序列和出队序列相同。所以要想用栈来模拟队列，栈从栈顶到栈底的顺序应该就是队列的出序序列，也就是说要将先入栈的元素的位置比后入栈的位置要高，这单凭一个栈是无法完成的。所以需要两个栈，一个用于存储“队列”元素（称为A），另一个用于辅助<strong>入队</strong>操作（称为B）：先将把新入队元素加入A栈，然后再把已经入队的元素加入到这个辅助的栈（直至A栈空），然后再将B栈的元素按序倒入A栈。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;<span class="comment">//先将已经入队的元素加入到这个辅助的栈（直至A栈空）</span></span><br><span class="line">    <span class="keyword">while</span>(!a.empty())&#123;</span><br><span class="line">        b.push(a.top());</span><br><span class="line">        a.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    a.push(val);<span class="comment">//将新元素加入A栈</span></span><br><span class="line">    <span class="keyword">while</span>(!b.empty())&#123;<span class="comment">//再将B栈所有元素按序倒入到a栈</span></span><br><span class="line">        a.push(b.top());</span><br><span class="line">        b.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> front = a.top(); a.pop();</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="push操作复杂度为O-N-pop-操作复杂度为O-1"><a href="#push操作复杂度为O-N-pop-操作复杂度为O-1" class="headerlink" title="push操作复杂度为O(N),pop()操作复杂度为O(1)"></a>push操作复杂度为O(N),pop()操作复杂度为O(1)</h2></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接将新元素加入到A栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    a.push(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其实就是利用B栈作辅助，取出A栈栈底元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">while</span>(!a.empty())&#123;</span><br><span class="line">        b.push(a.top());</span><br><span class="line">        a.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    ans = b.top(); b.pop();</span><br><span class="line">    <span class="keyword">while</span>(!b.empty())&#123;</span><br><span class="line">        a.push(b.top());</span><br><span class="line">        b.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_8</title>
      <link href="/2020/09/28/jzof-8/"/>
      <url>/2020/09/28/jzof-8/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的下一个节点，给定二叉树中的一个节点，请找出中序遍历的下一个节点。（节点包含：左右指针以及父指针）"><a href="#二叉树的下一个节点，给定二叉树中的一个节点，请找出中序遍历的下一个节点。（节点包含：左右指针以及父指针）" class="headerlink" title="二叉树的下一个节点，给定二叉树中的一个节点，请找出中序遍历的下一个节点。（节点包含：左右指针以及父指针）"></a>二叉树的下一个节点，给定二叉树中的一个节点，请找出中序遍历的下一个节点。（节点包含：左右指针以及父指针）</h1><blockquote><p>由于leetcode上没有第8题，所以根据题目意思自己写函数。</p></blockquote><p>节点结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">treeNode *left, *right, *parent;</span><br><span class="line">treeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), parent(<span class="literal">NULL</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>分析情况：</p><ol><li>若给出节点的父节点为空，则给出节点为根节点，则其下一节点为其右孩子。</li><li>若父节点的不为空<ol><li>若给出节点是父节点的左孩子,则下一节点就是其父节点</li><li>若给出节点是父节点的右孩子<ol><li>若当前节点的右孩子不为空，则下一节点就是其右子树的最左那个节点</li><li>若当前节点的右孩子为空，则下一节点需要沿着父节点一直往搜寻，直到找到一个这样的节点：它是其夫节点的左孩子（如果这样的节点存在，则这就是我们要找的下一个节点）</li></ol></li></ol></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">treeNode* <span class="title">getNext</span><span class="params">(treeNode* pNode)</span></span>&#123;</span><br><span class="line">    treeNode *nextNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">NULL</span>)<span class="comment">//情况0</span></span><br><span class="line">nextNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;parent == <span class="literal">NULL</span>)<span class="comment">//情况1</span></span><br><span class="line">        nextNode = pNode-&gt;right;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;parent-&gt;left == pNode)<span class="comment">//情况2.1</span></span><br><span class="line">            nextNode = pNode-&gt;parent;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//情况2.2</span></span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;right != <span class="literal">NULL</span>)&#123;<span class="comment">//情况2.2.1</span></span><br><span class="line">                pNode = pNode-&gt;right;</span><br><span class="line">                <span class="keyword">while</span>(pNode-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                    pNode = pNode-&gt;left;</span><br><span class="line">                nextNode = pNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//情况2.2.2</span></span><br><span class="line">                <span class="keyword">while</span>(pNode != <span class="literal">NULL</span> &amp;&amp; pNode-&gt;parent != <span class="literal">NULL</span> &amp;&amp; pNode-&gt;parent-&gt;right == pNode)</span><br><span class="line">                    pNode = pNode-&gt;parent;</span><br><span class="line">                <span class="keyword">if</span>(pNode == <span class="literal">NULL</span>)</span><br><span class="line">                    nextNode = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                nextNode = pNode-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_7</title>
      <link href="/2020/09/28/jzof-7/"/>
      <url>/2020/09/28/jzof-7/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h1><blockquote><p>例：</p><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]</p><p>观察前序遍历和中序遍历的序列关系，我们可知前序遍历序列的第一个元素是根，然后我们在中序遍历序列找到其位置，由中序遍历的特点可知，其左边的元素为当前节点的左子树的中序遍历序列，右边的元素为当前节点右子树的中序遍历序列。这样可以得出左右子树的元素个数，就可以再将中序序列与前序序列一一对应，递归调用生成整棵树。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=preorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTree_1(preorder,<span class="number">0</span>,len<span class="number">-1</span>,inorder,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree_1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,<span class="keyword">int</span> ps,<span class="keyword">int</span> pe ,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> is,<span class="keyword">int</span> ie)</span><span class="comment">//辅助函数（ps、pe指代前序序列范围，is、ie指代中序序列范围）</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode *root=<span class="keyword">new</span> TreeNode(preorder[ps]);</span><br><span class="line">        <span class="keyword">int</span> i=is;</span><br><span class="line">        <span class="keyword">while</span>(inorder[i]!=preorder[ps])<span class="comment">//查找根节点在中序序列的位置</span></span><br><span class="line">            ++i；</span><br><span class="line">        <span class="comment">//计算左右子树元素个数</span></span><br><span class="line">        <span class="keyword">int</span> leftsize=i-is;</span><br><span class="line">        <span class="keyword">int</span> rightsize=ie-i;</span><br><span class="line">        <span class="comment">//递归生成左右子树</span></span><br><span class="line">        <span class="keyword">if</span>(leftsize!=<span class="number">0</span>)root-&gt;left=buildTree_1(preorder,ps+<span class="number">1</span>,ps+leftsize,inorder,is,is+leftsize<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rightsize!=<span class="number">0</span>)root-&gt;right=buildTree_1(preorder,ps+leftsize+<span class="number">1</span>,pe,inorder,is+leftsize+<span class="number">1</span>,ie);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_6</title>
      <link href="/2020/09/28/jzof-6/"/>
      <url>/2020/09/28/jzof-6/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h1><blockquote><p>直接用递归或者用栈来模拟递归实现倒序打印链表。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseTravelList</span><span class="params">(ListNode* head)</span></span>&#123;<span class="comment">//辅助函数</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line">        reverseTravelList(head-&gt;next);<span class="comment">//先访问下一节点</span></span><br><span class="line">        ans.push_back(head-&gt;val);<span class="comment">//再打印当前节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        reverseTravelList(head);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_5</title>
      <link href="/2020/09/28/jzof-5/"/>
      <url>/2020/09/28/jzof-5/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h1><blockquote><p>由于题目给出的参数类型是string，我们只能先遍历一次字符串统计空格个数，然后在新建一个字符串，其长度为原来字符串长度加上两倍的空格个数。然后设置两个指针分别指向两个字符串，根据原来字符串中的字符是否为空格做出不同的赋值。</p><p>如果题目给出的参数类型是char<em>或者char[]，则我们可以<em>*从字符串的尾部开始复制</em></em>，避免字符重复移动，增加复杂度。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfSpace = <span class="number">0</span>;<span class="comment">//空格数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s)<span class="comment">//统计空格个数</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                ++numOfSpace;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">ans</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">2</span>*numOfSpace , <span class="string">&#x27;a&#x27;</span>)</span></span>;<span class="comment">//新建字符串</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.<span class="built_in">size</span>() ; ++i)&#123;<span class="comment">//字符串复制</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                ans[j++] = s[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans[j++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                ans[j++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                ans[j++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_4</title>
      <link href="/2020/09/28/jzof-4/"/>
      <url>/2020/09/28/jzof-4/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h1><blockquote><p>矩阵特点：每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</p><p>我们一般都会从左上角开始搜寻，但是这样会出现错误，若当前元素比目标小，可知，比当前元素大的元素在其下方及右方，此时无法确定搜索的方向。</p><p>当我们从左下角开始搜寻则不一样，<strong>若当前元素比目标小</strong>，可知比当前元素大的元素只在其右方，而当前元素所在列的上方都比其小，所以可以跳过当前元素所在列；<strong>若当前元素比目标大</strong>，可知比当前元素小的元素只在其上方，而当前元素所在行的右方都比其大，所以可以跳过当前元素所在行。重复搜索直到找到元素或越界为止。</p><p>其实，我们从右上角搜也是可以的，但是从右下角开始搜索不行。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从左下角搜索</span></span><br><span class="line">        <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>() ;</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = row - <span class="number">1</span> , j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; row &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; col)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target)</span><br><span class="line">                --i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_3</title>
      <link href="/2020/09/28/jzof-3/"/>
      <url>/2020/09/28/jzof-3/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h1><p>题解：</p><ol><li><p>采用一个数组来标记数字出现次数，复杂度：时间：O(N)，空间：O(N)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m</span><span class="params">(nums.<span class="built_in">size</span>() , <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(++m[num] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>排序，然后遍历数组，看前后是否有两个相同的元素，复杂度：时间：O(N*logN)，空间：O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>() , nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> ; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>重拍数组，从头到尾访问数组，访问到下标为i，大小为m的元素，若i等于m，则跳过该元素；若i不等于m，则与下标为m的元素比较，若m与下标为m的元素大小相等，则直接返回元素，否则交换两个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>() ; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[nums[i]])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                swap(nums[i] , nums[nums[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis底层数据结构的实现</title>
      <link href="/2020/09/04/redis-basical-structure/"/>
      <url>/2020/09/04/redis-basical-structure/</url>
      
        <content type="html"><![CDATA[<h2 id="简单动态字符串（simple-dynamic-string，SDS）"><a href="#简单动态字符串（simple-dynamic-string，SDS）" class="headerlink" title="简单动态字符串（simple dynamic string，SDS）"></a>简单动态字符串（simple dynamic string，SDS）</h2><h3 id="SDS的定义："><a href="#SDS的定义：" class="headerlink" title="SDS的定义："></a>SDS的定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"><span class="comment">//记录SDS保存字符串的长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录buf数组中未使用的字节数量</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><blockquote><p>例如我们保存了一个“Redis”的字符串。结构内的属性值分别为：len：5，free：0，buf数组的前五个字节分别为‘R’，‘e’，‘d’，‘i’，‘s’，而最后一个字节保存了空字符‘\0’.（这个空字符添加操作是由SDS函数自动完成的，所以对用户来所是透明的）</p></blockquote><h3 id="SDS与C字符串的区别："><a href="#SDS与C字符串的区别：" class="headerlink" title="SDS与C字符串的区别："></a>SDS与C字符串的区别：</h3><ol><li>常数复杂度获取字符串长度：要获取C字符串的长度，就对整个字符串进行计数，直到遇到空字符,复杂度为O(N)；要获取SDS的长度，只需读取其len属性，复杂度为O(1).</li><li>可以避免缓冲区溢出：由于C字符串不记录长度，所以当使用strcat函数（char <em>strcat(char </em>dest,char *src)）时是默认dest是有足够的空间，否则就会出现缓冲区溢出现象。而SDS在进行字符串拼接，会先检查字符串长度，如果空间不够会先进行扩容，再拼接。</li><li>减少修改字符串时带来的内存重分配次数：对C字符串来说，每次修改字符串，都会引起数组的内存重分配操作，对SDS来说，每次修改字符串只是修改对应的<strong>len</strong>属性和<strong>free</strong>属性，采用<code>预分配</code>(每次会分配额外的空间)和<code>惰性空间释放</code>(不会立即释放多余的空间，而是用free记录)。</li><li>二进制安全：C字符串中的字符必须符合某种编码，且不能包含空字符，否则认为是字符串结尾；而对SDS来说，可以储存任何格式的数据，因为SDS是根据len来判断是否为字符串结尾。</li></ol><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="双向-链表和链表节点的定义："><a href="#双向-链表和链表节点的定义：" class="headerlink" title="(双向)链表和链表节点的定义："></a>(双向)链表和链表节点的定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line"><span class="comment">//前置节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"><span class="comment">//后置节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="comment">//节点的值</span></span><br><span class="line"><span class="keyword">void</span> *value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="comment">//表头节点</span></span><br><span class="line">listNode *headl;</span><br><span class="line"><span class="comment">//表尾节点</span></span><br><span class="line">listNode *tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"><span class="comment">//节点值复制函数</span></span><br><span class="line"><span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"><span class="comment">//节点值释放函数</span></span><br><span class="line"><span class="keyword">void</span> *(*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"><span class="comment">//节点值比较函数</span></span><br><span class="line"><span class="keyword">void</span> *(*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><p><img src="/2020/09/04/redis-basical-structure/list.jpg" alt="list"></p><h3 id="链表的特性："><a href="#链表的特性：" class="headerlink" title="链表的特性："></a>链表的特性：</h3><blockquote><p>双向、无环、带头尾指针、带长度计数器以及多态（使用void*来保存节点的值）</p></blockquote><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="字典的定义："><a href="#字典的定义：" class="headerlink" title="字典的定义："></a>字典的定义：</h3><blockquote><p>键值对：键和值进行关联，这些关联的键和值就是键值对<br>字典：又称符号表、关联数组、映射，是一种用于保存键值对的抽象数据结构.</p></blockquote><h3 id="哈希表节点的定义："><a href="#哈希表节点的定义：" class="headerlink" title="哈希表节点的定义："></a>哈希表节点的定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> *key;<span class="comment">//键</span></span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line"><span class="keyword">void</span> *val;</span><br><span class="line">uint64 _tu64;</span><br><span class="line">int64 _ts64;</span><br><span class="line">&#125;v;<span class="comment">//值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span><span class="comment">//指向下个哈希表节点，形成链表，将多个哈希值相同的键值对连接在一起，用于解决键冲突问题</span></span><br><span class="line">&#125;dictEntry;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="哈希表的定义："><a href="#哈希表的定义：" class="headerlink" title="哈希表的定义："></a>哈希表的定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">dictEntry **table;<span class="comment">//哈希表数组</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;<span class="comment">//哈希表大小</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;<span class="comment">//哈希表大小掩码，用于计算索引值，总是等于size-1</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> used;<span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">&#125;dictht;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字典的定义：-1"><a href="#字典的定义：-1" class="headerlink" title="字典的定义："></a>字典的定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型特定函数定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;<span class="comment">//计算哈希值函数（如 MurmurHash算法）</span></span><br><span class="line"><span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);<span class="comment">//复制键函数</span></span><br><span class="line"><span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span>  *obj);<span class="comment">//复制值函数</span></span><br><span class="line"><span class="keyword">void</span> *(*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key1);<span class="comment">//对比键函数</span></span><br><span class="line"><span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);<span class="comment">//销毁键函数</span></span><br><span class="line"><span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);<span class="comment">//销毁值函数</span></span><br><span class="line">&#125;dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">dictType *type;<span class="comment">//类型特定函数，为用途不同字典设置不同的类型特定函数</span></span><br><span class="line"><span class="keyword">void</span> *privdata;<span class="comment">//私有数据，传给那些类型特定函数的可选参数</span></span><br><span class="line">dictht ht[<span class="number">2</span>];<span class="comment">//哈希表 ht[1]用于rehash</span></span><br><span class="line"><span class="keyword">int</span> trehashidx;<span class="comment">//rehash索引，记录哈希进度，-1 未进行rehash中</span></span><br><span class="line">&#125;dict;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ol><li>type属性指向一个dictType指针，用来保存特定类型键值对的操作函数</li><li>privdata保存了需要传给那些类型特定函数的可选参数</li><li>我可以看见ht是一个包含两个哈希表的数组，一般情况下，字典只使用ht[0],ht[1]只会在对ht[0]进行rehas时才会使用。</li></ol></blockquote><p>示例：</p><p><img src="/2020/09/04/redis-basical-structure/dict.jpg" alt="dict"></p><h3 id="哈希算法："><a href="#哈希算法：" class="headerlink" title="哈希算法："></a>哈希算法：</h3><blockquote><p>每次有一个新的键值对插入字典，都会用哈希算法计算出索引值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br></pre></td></tr></table></figure><blockquote><p>具体的hashFunction的底层实现使用的是<strong>MurmurHash2</strong>算法。</p></blockquote><h3 id="解决键冲突问题："><a href="#解决键冲突问题：" class="headerlink" title="解决键冲突问题："></a>解决键冲突问题：</h3><blockquote><p>Redis是使用<strong>链地址法</strong>来解决键冲突，而且是<strong>头插法</strong>。</p></blockquote><h3 id="rehash（重新排列）："><a href="#rehash（重新排列）：" class="headerlink" title="rehash（重新排列）："></a>rehash（重新排列）：</h3><blockquote><p>随着键值对的个数增大或减少，我们要通过<strong>rehash操作</strong>让<strong>负载因子</strong>维持在一个合理范围</p><p>（负载因子计算公式：负载因子 = 哈希表节点数量 / 哈希表大小）</p></blockquote><h4 id="具体的操作："><a href="#具体的操作：" class="headerlink" title="具体的操作："></a>具体的操作：</h4><blockquote><ol><li>为字典ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作以及ht[0]当前包含的键值对数量（ht[0].used），如果执行的是<strong>扩展</strong>操作，那么ht[1]的大小为第一个大于等于ht[0].used<em>2的n次幂，如果执行的是<em>*收缩</em></em>操作，那么ht[1]的大小为第一个大于等于ht[0].used的2的n次幂。</li><li>将保存在ht[0]中的所有键值对rehash到ht[1]上面rehash指的是重新计算键的哈希值和索引值,然后将键值对放置到ht[1]哈希表的指定位置上。</li><li>当ht[0]包含的所有键值对都迁移到了ht[1]之后释放ht[0]将ht[1]设置为ht[0],并在ht[1]新创键一个空白哈希表为下一次rehash做准备。</li></ol><p>哈希表<strong>渐进式rehash</strong>采用分而置之的方式，避免了集中式rehash带来的庞大计算量，在进行期间，字典的<code>删除、查找、更新</code>等操作会在<strong>两个哈希表</strong>上进行，<code>新添加</code>到字典的键值对一律会保存到ht[1]里面，则ht[0]不再进行任何添加操作。</p></blockquote><h2 id="跳跃表（skipList）："><a href="#跳跃表（skipList）：" class="headerlink" title="跳跃表（skipList）："></a>跳跃表（skipList）：</h2><h4 id="跳表介绍"><a href="#跳表介绍" class="headerlink" title="跳表介绍"></a><a href="https://www.iteye.com/blog/kenby-1187303">跳表介绍</a></h4><blockquote><p>跳跃表是一种有序数据结构，它通过每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p></blockquote><h3 id="跳跃表节点的实现："><a href="#跳跃表节点的实现：" class="headerlink" title="跳跃表节点的实现："></a>跳跃表节点的实现：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    robj *obj;  <span class="comment">/*成员对象*/</span></span><br><span class="line">    <span class="keyword">double</span> score;   <span class="comment">/*分值*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">/*后退指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span> <span class="comment">/*层*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span>  <span class="comment">/*前进指针*/</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;  <span class="comment">/*跨度*/</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><h4 id="属性的解释："><a href="#属性的解释：" class="headerlink" title="属性的解释："></a>属性的解释：</h4><ul><li>成员对象：节点的成员对象(obj属性)是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。在同一个跳跃表中，各个节点保存的成员对象必须是唯一的。</li><li>分值：节点的分值(score属性)是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序</li><li>层：跳跃表节点的level数组可以包含多个元素，每个元素都包含一些指向其他节点的指针，一般来说，层越多，访问节点速度越快。每次创建一个新跳跃表节点时，根据<strong>幂次定律</strong>随机生成一个介于1~32的值作为level数组的大小，也就是层的“高度”。</li><li>前进指针：每个层都有一个指向表尾方向的前进指针(level[i].forward属性)，用于从表头向表尾方向访问节点</li><li>跨度：层的跨度(level[i].span属性)用于记录两个节点之间的距离，<strong>跨度实际上是用来计算排位(rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</strong></li><li>后退指针：节点的后退指针(backward属性)用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次<strong>只能后退至前一个节点</strong>。</li></ul><h3 id="跳跃表的实现："><a href="#跳跃表的实现：" class="headerlink" title="跳跃表的实现："></a>跳跃表的实现：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>    <span class="comment">//header指向跳跃表的表头节点，tail指向跳跃表的表尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;   <span class="comment">//记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</span></span><br><span class="line">    <span class="keyword">int</span> level;  <span class="comment">//记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><h4 id="属性的解释：-1"><a href="#属性的解释：-1" class="headerlink" title="属性的解释："></a>属性的解释：</h4><ul><li>header：指向跳跃表的表头节点</li><li>tail：指向跳跃表的表尾节点</li><li>level：记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</li><li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</li></ul><p>示例：</p><p><img src="/2020/09/04/redis-basical-structure/skiplist.jpg" alt="skiplist"></p><h2 id="整数集合："><a href="#整数集合：" class="headerlink" title="整数集合："></a>整数集合：</h2><blockquote><p>整数集合是集合键的底层实现之一，当一个集合只包含整数且数量不多时，就会使用整数集合作为集合键的底层实现。</p></blockquote><h3 id="整数集合的实现："><a href="#整数集合的实现：" class="headerlink" title="整数集合的实现："></a>整数集合的实现：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 编码方式 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">/* 集合包含的元素数量 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">/* 保存元素的数组 */</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><p><img src="/2020/09/04/redis-basical-structure/intset.jpg" alt="intset"></p><h4 id="属性的解释：-2"><a href="#属性的解释：-2" class="headerlink" title="属性的解释："></a>属性的解释：</h4><ul><li>encoding：其值表示为整数的编码方式，有INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64，对应的是整数类型：int16_t、int32_t、int64_t.</li><li>length：集合的元素个数</li><li>contents：该数组储存的是集合的元素，按从小到大的顺序排列。</li></ul><h3 id="升级：每当添加的元素的类型比整数集合中的所有元素的类型都长的时候，需要进行升级操作。"><a href="#升级：每当添加的元素的类型比整数集合中的所有元素的类型都长的时候，需要进行升级操作。" class="headerlink" title="升级：每当添加的元素的类型比整数集合中的所有元素的类型都长的时候，需要进行升级操作。"></a>升级：每当添加的元素的类型比整数集合中的所有元素的类型都长的时候，需要进行升级操作。</h3><h4 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h4><ol><li>根据新元素的类型扩展数组的空间</li><li>将其他的数据类型转化为与新元素的数据类型相同，并将转换后的元素放到正确位置上</li><li>将新元素插入到数据的合适位置，并更新<code>encoding</code>属性的值</li></ol><p>我们可以观察到每当出现升级操作时，新元素的摆放位置肯定是在最前面或最后面，因为其长度是大于整数集合中的所有元素。</p><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><blockquote><p>压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量表项，并且每个列表项要么就是小整数，要么就是长度比较短的字符串，那么Redis就会使用压缩列表作为列表键的底层实现。</p></blockquote><h3 id="压缩列表的实现："><a href="#压缩列表的实现：" class="headerlink" title="压缩列表的实现："></a>压缩列表的实现：</h3><p><img src="/2020/09/04/redis-basical-structure/ziplist.png" alt="ziplist"></p><h3 id="压缩列表节点的构成："><a href="#压缩列表节点的构成：" class="headerlink" title="压缩列表节点的构成："></a>压缩列表节点的构成：</h3><p><img src="/2020/09/04/redis-basical-structure/ziplistnode.png" alt="ziplistnode"></p><h4 id="属性解释："><a href="#属性解释：" class="headerlink" title="属性解释："></a>属性解释：</h4><ul><li>previous_entry_length 属性以字节为单位,记录了压缩列表中前一个节点的长度,previous_entry_length属性的长度可以是1字节或者5字节（如果前一节点的长度小于254字节那么previous_entry_length属性的长度为1字节 ，如果前一节点的长度大于等于254字节）。根据当前节点的地址和previous_entry_length的值来计算出前一个节点的地址，压缩列表的从表尾向表头遍历操作就是使用这一原理实现的</li><li>encoding属性记录了字节数组的边码方式以及编码长度。</li><li>content属性负责保存节点的值，节点值可以是一个字节数组或者整数值的类型和长度由encoding决定</li></ul><h3 id="连锁更新："><a href="#连锁更新：" class="headerlink" title="连锁更新："></a>连锁更新：</h3><blockquote><p>当加入新节点的长度比后面节点的长度要大时，前面节点的更新会引起后面节点的连锁更新。例如：当前压缩列表里的节点长度都是一字节，新加入的节点的长度为五字节，所以后面节点的previous_entry_length无法记录前一节点的长度。需要重新分配内存。除了添加节点，还有删除节点也会引起连锁反应。</p></blockquote><p>下面是一些具体示例：</p><p>插入：</p><p><img src="/2020/09/04/redis-basical-structure/insert.jpg" alt="insert"></p><p>删除：</p><p><img src="/2020/09/04/redis-basical-structure/delete.jpg" alt="delete"></p><p>连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(n) 连锁更新最坏的时间复杂度O(n*n)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis设计与实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc、g++、gdb常用参数</title>
      <link href="/2020/09/02/gcc-g-gdb/"/>
      <url>/2020/09/02/gcc-g-gdb/</url>
      
        <content type="html"><![CDATA[<h2 id="gcc、g-编译工作的流程"><a href="#gcc、g-编译工作的流程" class="headerlink" title="gcc、g++编译工作的流程"></a>gcc、g++编译工作的流程</h2><div class="table-container"><table><thead><tr><th>部件</th><th>负责工作</th></tr></thead><tbody><tr><td>预处理器（cpp）</td><td>预处理生成.i文件</td></tr><tr><td>编译器（egcs）</td><td>将预处理后的文件转换成汇编语言，生成.文件</td></tr><tr><td>汇编器（as）</td><td>将汇编语言文件变为目标机器代码，生成.o文件</td></tr><tr><td>链接器（ld）</td><td>连接目标代码，生成可执行程序</td></tr></tbody></table></div><a id="more"></a><h2 id="gcc、g-常用参数解释"><a href="#gcc、g-常用参数解释" class="headerlink" title="gcc、g++常用参数解释"></a>gcc、g++常用参数解释</h2><div class="table-container"><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>只做预处理、编译、汇编部分工作，只生成目标文件（.o文件）</td></tr><tr><td>-S</td><td>只做预处理、编译部分工作，只生成汇编文件（.s文件）</td></tr><tr><td>-E</td><td>只做预处理部分工作，不生成文件，需要<strong>重定向</strong>到另一个文件 用法：gcc -E inputfile &gt; outputfile</td></tr><tr><td>-o</td><td>将输出文件重定向到指定文件 用法：gcc -o outputfile inputfile[1]…..inputfile[n]</td></tr><tr><td>-O0 \ -O1 \ -O3</td><td>优化选项，生成优化代码，其中O3优化级别最高</td></tr><tr><td>-w</td><td>不生成任何警告信息</td></tr><tr><td>-Wall</td><td>生成所有警告信息</td></tr><tr><td>-M</td><td>生成文件关联（依赖）信息</td></tr><tr><td>-MM</td><td>和“-M”一样，但是它忽略有#include<file>造成的依赖关系</file></td></tr></tbody></table></div><h2 id="gdb调试："><a href="#gdb调试：" class="headerlink" title="gdb调试："></a>gdb调试：</h2><blockquote><p>注意：如果需要gdb调试，在用gcc、g++进行编译时需要用“-g”参数</p></blockquote><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>gdb <program> : program为需要调试的执行文件    </program></p><p>gdb <program> <PID> : 指定这个程序运行时的进程ID（只有当程序是一个服务器程序时） </PID></program></p><h2 id><a href="#" class="headerlink" title=" "></a> </h2><h2 id="常见交互命令："><a href="#常见交互命令：" class="headerlink" title="常见交互命令："></a>常见交互命令：</h2><h3 id="运行命令："><a href="#运行命令：" class="headerlink" title="运行命令："></a>运行命令：</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>run，简写r</td><td>运行程序，直到遇到断点后，会在断点处停止运行等待用户输入命令</td></tr><tr><td>continue，简写c</td><td>继续执行直到下一断点处或执行结束</td></tr><tr><td>next，简写n</td><td>单步跟踪程序，在遇到自定义函数调用时，不进入函数体（即把函数当作整体的一步）</td></tr><tr><td>step，简写s</td><td>与next相同，不过在遇到自定义函数调用时，会进入函数体</td></tr><tr><td>until</td><td>运行程序直到退出循环体</td></tr><tr><td>until+行号</td><td>运行至某行，不仅仅用来跳出循环体</td></tr><tr><td>finish</td><td>运行程序，直到当前函数返回，并打印函数返回的堆栈地址和返回值及其参数信息</td></tr><tr><td>call+函数名（参数）</td><td>调用程序可见函数，并传递参数，如：call print（5）</td></tr><tr><td>quit</td><td>退出gdb</td></tr></tbody></table></div><h3 id="设置端点"><a href="#设置端点" class="headerlink" title="设置端点"></a>设置端点</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>break n，简写b n</td><td>在第n行设置断点（可以带上代码路径及代码文件名，如b main.cpp 14）</td></tr><tr><td>break func</td><td>在函数func的入口处设置断点</td></tr><tr><td>delete 断点号n</td><td>删除第n个断点</td></tr><tr><td>disable 断点号n</td><td>暂停第n个断点</td></tr><tr><td>enable 断点n</td><td>开启第n个断点</td></tr><tr><td>clear 行号n</td><td>删除第n行设置的断点</td></tr><tr><td>info breakpoins，简写info b</td><td>显示设置断点信息</td></tr><tr><td>delete breakpoints</td><td>清除所有设置的断点</td></tr></tbody></table></div><h3 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>list，简写l</td><td>列出源代码，默认显示出10行</td></tr><tr><td>list+行号n</td><td>显示以n为中心的10行代码</td></tr><tr><td>list+函数名</td><td>显示函数体</td></tr><tr><td>list</td><td>将接着上一次list命令输出如下内容</td></tr></tbody></table></div><h3 id="打印表达式"><a href="#打印表达式" class="headerlink" title="打印表达式"></a>打印表达式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>print 表达式，简写p 表达式</td><td>打印表达式的值，表达式可以为当前调试程序的任何有效表达式</td></tr><tr><td>p a</td><td>显示整数a的值</td></tr><tr><td>p str</td><td>显示字符串str</td></tr><tr><td>p test(22)</td><td>打印以22为参数调用test函数的返回值</td></tr><tr><td>p test(a)</td><td>打印以a为参数调用test函数的返回值</td></tr><tr><td>display 表达式</td><td>在使用display设置表达式后，它将在<strong>每次</strong>单步调试（step、next）后，紧接着输出表达式的值</td></tr><tr><td>watch 表达式</td><td>设置一个监视点，一旦被监视的表达式的值发生改变，将强行终止正在被调试的程序</td></tr><tr><td>whatis 变量或函数</td><td>查询变量或函数</td></tr><tr><td>info locals</td><td>显示当前堆栈页的所有变量</td></tr></tbody></table></div><h3 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a>查询运行信息</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>where / bt</td><td>显示当前运行的堆栈列表</td></tr><tr><td>bt / backtrace</td><td>显示当前调用的堆栈列表</td></tr><tr><td>up / down</td><td>改变堆栈显示的深度</td></tr><tr><td>set args var</td><td>指定程序运行时的参数</td></tr><tr><td>show args</td><td>显示设置好的参数</td></tr><tr><td>info program</td><td>显示程序是否正在运行</td></tr></tbody></table></div><h3 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>layout</td><td>用于分割代码，边看代码边测试</td></tr><tr><td>layout src</td><td>显示源代码窗口</td></tr><tr><td>layout asm</td><td>显示反汇编代码窗口</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> gcc\g++\gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题---树</title>
      <link href="/2020/08/08/tree/"/>
      <url>/2020/08/08/tree/</url>
      
        <content type="html"><![CDATA[<h1 id="14-leetcode刷题—-树"><a href="#14-leetcode刷题—-树" class="headerlink" title="14.leetcode刷题—-树"></a>14.leetcode刷题—-树</h1><h2 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a>相关题目：</h2><h2 id="树的递归："><a href="#树的递归：" class="headerlink" title="树的递归："></a>树的递归：</h2><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>我们首先要注意到深度的定义：<strong>根节点到最远叶子节点的最长路径上的节点数</strong>。</p><p>可知当前节点的深度等于 <code>以其左孩子为根节点的深度</code> 或 <code>以其右孩子为根节点的深度</code> 两者中最大值加1.</p></blockquote><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="literal">NULL</span>?<span class="number">0</span>:<span class="built_in">max</span>(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p>示例 1:</p><p>给定二叉树 [3,9,20,null,null,15,7] </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回 true 。</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>当前节点平衡的条件：1.左子树为平衡二叉树，2.右子树为平衡二叉树，3.左右孩子高度之差的绝对值小于2.定义一个辅助函数，其功能为：如果以当前节点为根节点的树为平衡二叉树就返回这棵树的高度，否则返回-1.</p></blockquote><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;<span class="comment">//返回节点的高度，若过当前节点不平衡就返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=helper(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right=helper(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">-1</span>||right==<span class="number">-1</span>||<span class="built_in">abs</span>(left-right)&gt;<span class="number">1</span>)<span class="comment">//如果左子树不平衡或者右子树不平衡或者左右子树高度之差大于1，返回-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root)!=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>示例 :<br>给定二叉树</p><pre><code>      1     / \    2   3   / \       4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><blockquote><p><code>一颗二叉树的直径长度的定义：任意两个结点路径长度中的最大值。</code></p><p>可知二叉树的直径长度为以根节点中转节点，其数值等于左右子树的高度之和。</p></blockquote><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;<span class="comment">//返回以root为根节点的二叉树的高度</span></span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=helper(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right=helper(root-&gt;right);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,left+right);<span class="comment">//更新最大直径长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h3><h4 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><pre><code>          5         / \        4   8       /   / \      11  13  4     /  \      \    7    2      1</code></pre><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>采用将sum递减的方法，如果当前节点为叶子节点且sum等于0，返回true</p><p>如果否则对其左右子树递归。</p></blockquote><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">        sum-=root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right&amp;&amp;sum==<span class="number">0</span>)<span class="comment">//叶子节点且路径和等于sum</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left,sum)||hasPathSum(root-&gt;right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h3><h4 id="题目描述：；"><a href="#题目描述：；" class="headerlink" title="题目描述：；"></a>题目描述：；</h4><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><pre><code>          5         / \        4   8       /   / \      11  13  4     /  \    / \    7    2  5   1</code></pre><p>返回:</p><blockquote><p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p></blockquote><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>相当于dfs，只不过多了一个用vector记录路径的步骤。与上面的题目解法类似。</p></blockquote><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root,<span class="keyword">int</span> sum,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        sum-=root-&gt;val;</span><br><span class="line">        v.push_back(root-&gt;val);<span class="comment">//记录路径</span></span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right)&#123;<span class="comment">//如果当前节点为叶子节点且路径和等于sum</span></span><br><span class="line">            ans.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root-&gt;left,sum,v);</span><br><span class="line">        helper(root-&gt;right,sum,v);</span><br><span class="line">        v.pop_back();<span class="comment">//当左右子树都已访问，将其记录消除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        helper(root,sum,v);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></h3><h4 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p><p>示例：</p><p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p><pre><code>      10     /  \    5   -3   / \    \  3   2   11 / \   \3  -2   1返回 3。和等于 8 的路径有:1.  5 -&gt; 32.  5 -&gt; 2 -&gt; 13.  -3 -&gt; 11</code></pre><h4 id="题目描述：-5"><a href="#题目描述：-5" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote><p>对每个节点都有两种情况（注意：<strong>路径方向必须是向下的（只能从父节点到子节点）</strong>）</p><ol><li>取该节点的值，且连续取其子树的节点的值</li><li>不取该节点的值，以其孩子为路径起点</li></ol><p>对于情况1来说，我们需要一个辅助函数来完成其连续取值的累加和工作</p><p>对于情况2来说，用原函数递归完成</p></blockquote><h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSumWithRoot</span><span class="params">(TreeNode* root,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=root-&gt;val==sum?<span class="number">1</span>:<span class="number">0</span>;<span class="comment">//如果当前节点的值等于目标值sum，count置为1，否则置为0</span></span><br><span class="line">        <span class="comment">//递归调用左右子树计算路径和</span></span><br><span class="line">        count+=pathSumWithRoot(root-&gt;left,sum-root-&gt;val);</span><br><span class="line">        count+=pathSumWithRoot(root-&gt;right,sum-root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空树返回0</span></span><br><span class="line">        <span class="keyword">return</span> pathSumWithRoot(root,sum)+<span class="comment">//以当前节点为路径起点（加上root-&gt;val）</span></span><br><span class="line">            pathSum(root-&gt;left,sum)+pathSum(root-&gt;right,sum);<span class="comment">//或以当前节点左右孩子为根节点（没有加上root-&gt;val）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h3><h4 id="题目描述：-6"><a href="#题目描述：-6" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> \   \</span><br><span class="line"> <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure><p>进阶：</p><p>你可以运用递归和迭代两种方法解决这个问题吗？</p><h4 id="题解（递归）："><a href="#题解（递归）：" class="headerlink" title="题解（递归）："></a>题解（递归）：</h4><blockquote><p>如果以当前节点为根节点的二叉树为是镜像对称的。要满足以下条件：</p><ol><li>其左右子树的值相同，或者左右子树同时为空。</li><li>其左子树的左子树与其右子树的右子树是镜像兑成的。</li><li>其左子树的右子树与其右子树的左子树是镜像兑成的。</li></ol><p>（有点混淆）</p></blockquote><h4 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* r1,TreeNode* r2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!r1&amp;&amp;!r2)<span class="comment">//r1和r2都为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!r1||!r2)<span class="comment">//r1和r2不同</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(r1-&gt;val!=r2-&gt;val)<span class="comment">//r1和r2的值不对称 （不满足条件1）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//条件2和3</span></span><br><span class="line">        <span class="keyword">return</span> helper(r1-&gt;left,r2-&gt;right)&amp;&amp;helper(r1-&gt;right,r2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !root||helper(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解（迭代）：参考"><a href="#题解（迭代）：参考" class="headerlink" title="题解（迭代）：参考"></a>题解（迭代）：<a href="https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/">参考</a></h4><blockquote><p>层次遍历，不过入队的方式有所不同，首先将根节点入队两次。然后每次从队列中提取两节点来比较，若两值相同，入队顺序：节点1的左子树、节点2的右子树、节点1的右子树、节点2的左子树。与上面的<strong>条件2</strong>：<code>其左子树的左子树与其右子树的右子树是镜像兑成的</code>和<strong>条件3：</strong><code>其左子树的右子树与其右子树的左子树是镜像兑成的</code>相同。</p></blockquote><h4 id="代码：-7"><a href="#代码：-7" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* u,TreeNode* v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(u);q.push(v);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="comment">//提取队列中的两个节点</span></span><br><span class="line">            u=q.front();q.pop();</span><br><span class="line">            v=q.front();q.pop();</span><br><span class="line">            <span class="comment">//队列中每两个相邻节点值的情况肯定相同</span></span><br><span class="line">            <span class="keyword">if</span>(!u&amp;&amp;!v)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((!u||!v)||(u-&gt;val!=v-&gt;val))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            q.push(u-&gt;left);<span class="comment">//u的左子树与v的右子树比较</span></span><br><span class="line">            q.push(v-&gt;right);</span><br><span class="line">            </span><br><span class="line">            q.push(u-&gt;right);<span class="comment">//u的右子树和v的左子树比较</span></span><br><span class="line">            q.push(v-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1110-删点成林"><a href="#1110-删点成林" class="headerlink" title="1110. 删点成林"></a><a href="https://leetcode-cn.com/problems/delete-nodes-and-return-forest/">1110. 删点成林</a></h3><h4 id="题目描述：-7"><a href="#题目描述：-7" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给出二叉树的根节点 root，树上每个节点都有一个不同的值。</p><p>如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。</p><p>返回森林中的每棵树。你可以按任意顺序组织答案。</p><p>示例：</p><p><img src="/2020/08/08/tree/screen-shot-2019-07-01-at-53836-pm.png" alt="screen-shot-2019-07-01-at-53836-pm"></p><blockquote><p>输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]<br>输出：[[1,2,null,4],[6],[7]]</p></blockquote><p>提示：</p><ul><li>树中的节点数最大为 1000。</li><li>每个节点都有一个介于 1 到 1000 之间的值，且各不相同。</li><li>to_delete.length &lt;= 1000</li><li>to_delete 包含一些从 1 到 1000、各不相同的值。</li><li>通过次数4,146提交次数6,907</li></ul><h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>采用自底向上的方法。从底层开始，先对其左右子树递归调用。如果当前节点的值在删除节点的集合中，（左右子树不在删除集合中）则将其左右孩子加入到森林forest并将其置为NULL。</p></blockquote><h4 id="代码：-8"><a href="#代码：-8" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode*&amp; root,<span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; forest,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&amp; deleteN)</span> </span>&#123;<span class="comment">//自底向上</span></span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对应左右子树递归调用</span></span><br><span class="line">        root-&gt;left=helper(root-&gt;left,forest,deleteN);</span><br><span class="line">        root-&gt;right=helper(root-&gt;right,forest,deleteN);</span><br><span class="line">        <span class="keyword">if</span>(deleteN.count(root-&gt;val))&#123;<span class="comment">//如果当前节点的值在删除节点中，只有这种情况才会将节点加入到森林</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)<span class="comment">//如果左子树不为空，则加入到森林</span></span><br><span class="line">                forest.push_back(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)<span class="comment">//如果右子树不为空，则加入到森林</span></span><br><span class="line">                forest.push_back(root-&gt;right);</span><br><span class="line">            root=<span class="literal">NULL</span>;<span class="comment">//将当前节点置空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">deleteN</span><span class="params">(to_delete.<span class="built_in">begin</span>(),to_delete.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; forest;</span><br><span class="line">        root=helper(root,forest,deleteN);</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            forest.push_back(root);</span><br><span class="line">        <span class="keyword">return</span> forest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="遍历："><a href="#遍历：" class="headerlink" title="遍历："></a>遍历：</h2><h3 id="层次遍历："><a href="#层次遍历：" class="headerlink" title="层次遍历："></a>层次遍历：</h3><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h3><h4 id="题目描述：-8"><a href="#题目描述：-8" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><p>示例 1：</p><blockquote><p>输入：<br>     3<br>    / \<br>  9  20<br>      /  \<br>    15   7<br>输出：[3, 14.5, 11]<br>解释：<br>第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</p></blockquote><h4 id="题解：-6"><a href="#题解：-6" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>典型的层次遍历模板。</p></blockquote><h4 id="代码：-9"><a href="#代码：-9" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span>=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;++i)&#123;</span><br><span class="line">                TreeNode* t=q.front();q.pop();</span><br><span class="line">                sum+=t-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(sum/<span class="built_in">size</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="前序遍历：；"><a href="#前序遍历：；" class="headerlink" title="前序遍历：；"></a>前序遍历：；</h3><h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h3><p>给定一个二叉树，返回它的 前序 遍历。</p><p> 示例:</p><blockquote><p>输入: [1,null,2,3]<br>   1<br>    \<br>     2<br>    /<br>   3 </p><p>输出: [1,2,3]</p><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><h4 id="题解（递归）：-1"><a href="#题解（递归）：-1" class="headerlink" title="题解（递归）："></a>题解（递归）：</h4><blockquote><p>略</p></blockquote><h4 id="代码：-10"><a href="#代码：-10" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        preorder_route.push_back(root-&gt;val);</span><br><span class="line">        preorder(root-&gt;left,preorder_route);</span><br><span class="line">        preorder(root-&gt;right,preorder_route);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder_route;</span><br><span class="line">        preorder(root,preorder_route);</span><br><span class="line">        <span class="keyword">return</span> preorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解（迭代）："><a href="#题解（迭代）：" class="headerlink" title="题解（迭代）："></a>题解（迭代）：</h4><blockquote><p>用一个栈来模拟前序遍历时函数调用的过程。主要过程如下：我们每入栈一个节点就将其节点值加入到数组中，然后一直将其左边的节点入栈直到左边不存在节点。其后从取栈顶节点，取其右孩子，若不为空继续上述操作。这样重复执行直到栈空。</p></blockquote><h4 id="代码：-11"><a href="#代码：-11" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* t=root;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(t)&#123;</span><br><span class="line">                s.push(t);<span class="comment">//入栈时将节点值加入到队列中</span></span><br><span class="line">                preorder_route.push_back(t-&gt;val);</span><br><span class="line">                t=t-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            t=s.top();s.pop();t=t-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">while</span>(!s.empty()||t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder_route;</span><br><span class="line">        preorder(root,preorder_route);</span><br><span class="line">        <span class="keyword">return</span> preorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h3><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h3><h4 id="题目描述：-9"><a href="#题目描述：-9" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    <span class="string">\</span></span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    <span class="string">/</span></span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="string">输出:</span> [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h4 id="题解（递归）"><a href="#题解（递归）" class="headerlink" title="题解（递归）:"></a>题解（递归）:</h4><blockquote><p>略。</p></blockquote><h4 id="代码：-12"><a href="#代码：-12" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        inorder(root-&gt;left,inorder_route);</span><br><span class="line">        inorder_route.push_back(root-&gt;val);</span><br><span class="line">        inorder(root-&gt;right,inorder_route);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_route;</span><br><span class="line">        inorder(root,inorder_route);</span><br><span class="line">        <span class="keyword">return</span> inorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解（迭代）：-1"><a href="#题解（迭代）：-1" class="headerlink" title="题解（迭代）："></a>题解（迭代）：</h4><blockquote><p>和前序遍历的迭代代码类似，只是将节点值加入到数组的时机不同。</p></blockquote><h4 id="代码：-13"><a href="#代码：-13" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* t=root;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(t)&#123;</span><br><span class="line">                s.push(t);</span><br><span class="line">                t=t-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            t=s.top();s.pop();<span class="comment">//出栈时将节点值加入到数组</span></span><br><span class="line">            inorder_route.push_back(t-&gt;val);</span><br><span class="line">            t=t-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">while</span>(!s.empty()||t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_route;</span><br><span class="line">        inorder(root,inorder_route);</span><br><span class="line">        <span class="keyword">return</span> inorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后序遍历："><a href="#后序遍历：" class="headerlink" title="后序遍历："></a>后序遍历：</h3><h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h3><h4 id="题目描述：-10"><a href="#题目描述：-10" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，返回它的 后序 遍历。</p><p>示例:</p><blockquote><p>输入: [1,null,2,3]<br>   1<br>    \<br>     2<br>    /<br>   3 </p><p>输出: [3,2,1]<br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><h4 id="题解（递归）：-2"><a href="#题解（递归）：-2" class="headerlink" title="题解（递归）："></a>题解（递归）：</h4><blockquote><p>略。</p></blockquote><h4 id="代码：-14"><a href="#代码：-14" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        postorder(root-&gt;left,postorder_route);</span><br><span class="line">        postorder(root-&gt;right,postorder_route);</span><br><span class="line">        postorder_route.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder_route;</span><br><span class="line">        postorder(root,postorder_route);</span><br><span class="line">        <span class="keyword">return</span> postorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解（迭代）：-2"><a href="#题解（迭代）：-2" class="headerlink" title="题解（迭代）："></a>题解（迭代）：</h4><blockquote><p>同样用栈模拟遍历过程，先将根<code>I:</code>节点入栈，然后将其出栈，再入栈，同时紧跟一个NULL入栈，然后按照先右后左的顺序入栈。当我们从栈顶提取节点时，若栈顶元素为NULL则表示其下面的节点的左右子树已经遍历，将其值加入到数组中，否则，则表示该元素左右子树未遍历，需要重复进行<code>I</code>操作。</p></blockquote><h4 id="代码：-15"><a href="#代码：-15" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* t=root;</span><br><span class="line">        s.push(t);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            t=s.top();s.pop();</span><br><span class="line">            <span class="keyword">if</span>(t)&#123;<span class="comment">//当t的左右子树未入栈时，将t再次入栈，使其在栈中位于左右子树下面，并用NULL标记表示其左右子树都已经遍历过</span></span><br><span class="line">                s.push(t);</span><br><span class="line">                s.push(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">//因为栈是先进后出，要想先遍历左子树，左子树要后入栈</span></span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)s.push(t-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left)s.push(t-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//在NULL下面的节点，已经访问过其左右子树了</span></span><br><span class="line">                postorder_route.push_back(s.top()-&gt;val);</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder_route;</span><br><span class="line">        postorder(root,postorder_route);</span><br><span class="line">        <span class="keyword">return</span> postorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="根据遍历序列构造树："><a href="#根据遍历序列构造树：" class="headerlink" title="根据遍历序列构造树："></a>根据遍历序列构造树：</h3><blockquote><p>一共有三种组合：</p><ol><li>前序和中序</li><li>中序和后序</li><li>前序和后序</li></ol><p><strong>只有1和2可以唯一确定一颗二叉树，3不能<code>唯一</code>确定一颗二叉树</strong></p></blockquote><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><h4 id="题目描述：-11"><a href="#题目描述：-11" class="headerlink" title="题目描述："></a>题目描述：</h4><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><blockquote><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]</p></blockquote><p>返回如下的二叉树：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><h4 id="题解：-7"><a href="#题解：-7" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>观察前序和中序遍历序列的关系。前序第一个为根节点的值，然后在中序找到这个值的位置，其左边的元素个数，就是左子树的节点个数，其右边的元素个数，就是右子树的节点个数。根据这个规律，可以用递归的方法实现。</p></blockquote><h4 id="代码：-16"><a href="#代码：-16" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,<span class="keyword">int</span> first1,<span class="keyword">int</span> last1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> first2,<span class="keyword">int</span> last2)</span> </span>&#123;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(preorder[first1]);</span><br><span class="line">        <span class="keyword">int</span> pos=first2;</span><br><span class="line">        <span class="keyword">while</span>(inorder[pos]!=preorder[first1])&#123;<span class="comment">//找到根节点的值在中序序列中的位置</span></span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftsize=pos-first2;<span class="comment">//计算左右子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> rightsize=last2-pos;</span><br><span class="line">        <span class="comment">//递归生成左右子树</span></span><br><span class="line">        <span class="keyword">if</span>(leftsize)root-&gt;left=helper(preorder,first1+<span class="number">1</span>,first1+leftsize,inorder,first2,pos<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rightsize)root-&gt;right=helper(preorder,first1+leftsize+<span class="number">1</span>,last1,inorder,pos+<span class="number">1</span>,last2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>,inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><h4 id="题目描述：-12"><a href="#题目描述：-12" class="headerlink" title="题目描述："></a>题目描述：</h4><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><blockquote><p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]</p></blockquote><p>返回如下的二叉树：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><h4 id="题解：-8"><a href="#题解：-8" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>与上面前序和中序的想法类似。不具体介绍。</p></blockquote><h4 id="代码：-17"><a href="#代码：-17" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> first1,<span class="keyword">int</span> last1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder,<span class="keyword">int</span> first2,<span class="keyword">int</span> last2)</span> </span>&#123;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(postorder[last2]);</span><br><span class="line">        <span class="keyword">int</span> pos=first1;</span><br><span class="line">        <span class="keyword">while</span>(inorder[pos]!=postorder[last2])&#123;<span class="comment">//找出根节点在中序序列的位置</span></span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算左右子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> leftsize=pos-first1;</span><br><span class="line">        <span class="keyword">int</span> rightsize=last1-pos;</span><br><span class="line">        <span class="comment">//递归生成左右子树</span></span><br><span class="line">        <span class="keyword">if</span>(leftsize)root-&gt;left=helper(inorder,first1,pos<span class="number">-1</span>,postorder,first2,first2+leftsize<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rightsize)root-&gt;right=helper(inorder,pos+<span class="number">1</span>,last1,postorder,first2+leftsize,last2<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>,postorder,<span class="number">0</span>,postorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="889-根据前序和后序遍历构造二叉树"><a href="#889-根据前序和后序遍历构造二叉树" class="headerlink" title="889. 根据前序和后序遍历构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a></h3><h4 id="题目描述：-13"><a href="#题目描述：-13" class="headerlink" title="题目描述："></a>题目描述：</h4><p>返回与给定的前序和后序遍历匹配的任何二叉树。</p><p> pre 和 post 遍历中的值是不同的正整数。</p><p>示例：</p><blockquote><p>输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]<br>输出：[1,2,3,4,5,6,7]</p></blockquote><p>提示：</p><ul><li>1 &lt;= pre.length == post.length &lt;= 30</li><li>pre[] 和 post[] 都是 1, 2, …, pre.length 的排列</li><li>每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。</li></ul><h4 id="题解：-9"><a href="#题解：-9" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>与上面两题类似。不过这个特别一点，特别之处是找左右子树的节点个数不同。这里不是根据根节点来找，而是根据<strong>pre[first1+1]</strong>在后序遍历序列中的位置来确定。因为这个点是当前根节点的左孩子，其在左子树的后序遍历中是最后访问的，所以找出这个位置就相当于找出了左子树的节点个数，以及右子树的节点个数。需要注意的是：这里确定边界的方法有所不同。</p></blockquote><h4 id="代码：-18"><a href="#代码：-18" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre,<span class="keyword">int</span> first1,<span class="keyword">int</span> last1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post,<span class="keyword">int</span> first2,<span class="keyword">int</span> last2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前区间不存在节点</span></span><br><span class="line">        <span class="keyword">if</span>(first1&gt;last1||first2&gt;last2)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(pre[first1]);</span><br><span class="line">        <span class="comment">//当前区间只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(first1==last1)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">int</span> pos=first2;</span><br><span class="line">        <span class="keyword">while</span>(pre[first1+<span class="number">1</span>]!=post[pos])&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算左右子树节点个数</span></span><br><span class="line">        <span class="keyword">int</span> leftsize=pos-first2+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightsize=last2-pos<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//递归生成左右子树</span></span><br><span class="line">        root-&gt;left=helper(pre,first1+<span class="number">1</span>,first1+leftsize,post,first2,pos);</span><br><span class="line">        root-&gt;right=helper(pre,first1+leftsize+<span class="number">1</span>,last1,post,pos+<span class="number">1</span>,last2<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(pre,<span class="number">0</span>,pre.<span class="built_in">size</span>()<span class="number">-1</span>,post,<span class="number">0</span>,post.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/solution/kan-wo-jiu-gou-liao-san-chong-bian-li-fang-shi-gou/">总结</a></strong></p><h2 id="二叉搜索树："><a href="#二叉搜索树：" class="headerlink" title="二叉搜索树："></a>二叉搜索树：</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><blockquote><p>二叉搜索树的特点：对于树中的每个节点X，它的左子树中所有关键字值小于X的关键字值，而它的右子树中所有关键字值大于X的关键字值。</p><p>根据这个性质，<strong>对一个二叉树进行中序遍历，如果是单调递增的，则可以说明这个树是二叉搜索树</strong>。</p></blockquote><h3 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a></h3><h4 id="题目描述：-14"><a href="#题目描述：-14" class="headerlink" title="题目描述："></a>题目描述：</h4><p>二叉搜索树中的两个节点被错误地交换。</p><p>请在不改变其结构的情况下，恢复这棵树。</p><p>示例 1:</p><p>输入: [1,3,null,null,2]</p><blockquote><p>  1<br>  /<br> 3<br>  \<br>   2</p></blockquote><p>输出: [3,1,null,null,2]</p><blockquote><p>   3<br>  /<br> 1<br>  \<br>   2</p></blockquote><p><strong>进阶:</strong></p><ul><li>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。</li><li>你能想出一个只使用常数空间的解决方案吗？</li></ul><h4 id="题解1："><a href="#题解1：" class="headerlink" title="题解1："></a>题解1：</h4><blockquote><p>先中序遍历一遍获得中序遍历序列，然后再一次中序遍历，将树的节点一一赋值即可。时间复杂度O(N)，空间复杂度O(N).</p></blockquote><h4 id="代码：-19"><a href="#代码：-19" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_route;</span><br><span class="line">    <span class="comment">//获取中序遍历序列</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_inorder_route</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        get_inorder_route(root-&gt;left);</span><br><span class="line">        inorder_route.push_back(root-&gt;val);</span><br><span class="line">        get_inorder_route(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据中序遍历序列恢复BST</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Recover_BST</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp;pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Recover_BST(root-&gt;left,pos);</span><br><span class="line">        root-&gt;val=inorder_route[++pos];</span><br><span class="line">        Recover_BST(root-&gt;right,pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        get_inorder_route(root);</span><br><span class="line">        sort(inorder_route.<span class="built_in">begin</span>(),inorder_route.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">-1</span>;</span><br><span class="line">        Recover_BST(root,pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解2："><a href="#题解2：" class="headerlink" title="题解2："></a>题解2：</h4><h4 id="代码：-20"><a href="#代码：-20" class="headerlink" title="代码："></a>代码：</h4><h3 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h3><h4 id="题目描述：-15"><a href="#题目描述：-15" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><p>示例 1:</p><p>输入: </p><blockquote><p>   1<br>   / \<br>  0   2</p><p> L = 1</p><p>R = 2</p><p>输出:   </p><p>1</p><p>   \</p><p>​      2</p></blockquote><h4 id="题解：-10"><a href="#题解：-10" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>运用bst的特性用递归解决。如果当前节点的值小于L，就返回其右子树，因为其右子树的值都比这个节点的值大，如果当前节点的值大于R，就返回其左子树，因为其左子树的值都比这个节点的值小。</p></blockquote><h4 id="代码：-21"><a href="#代码：-21" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&lt;L)<span class="comment">//在范围外的左侧</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root-&gt;right,L,R);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&gt;R)<span class="comment">//在范围外的右侧</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root-&gt;left,L,R);</span><br><span class="line">        <span class="comment">//在范围内</span></span><br><span class="line">        root-&gt;left=trimBST(root-&gt;left,L,R);</span><br><span class="line">        root-&gt;right=trimBST(root-&gt;right,L,R);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="字典树：208-实现-Trie-前缀树"><a href="#字典树：208-实现-Trie-前缀树" class="headerlink" title="字典树：208. 实现 Trie (前缀树)"></a>字典树：<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h3><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><blockquote><p>又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。<br><strong>字典树与字典很相似,当你要查一个单词是不是在字典树中,首先看单词的第一个字母是不是在字典的第一层,如果不在,说明字典树里没有该单词,如果在就在该字母的孩子节点里找是不是有单词的第二个字母,没有说明没有该单词,有的话用同样的方法继续查找.字典树不仅可以用来储存字母,也可以储存数字等其它数据。</strong></p></blockquote><h4 id="题目描述：-16"><a href="#题目描述：-16" class="headerlink" title="题目描述："></a>题目描述：</h4><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p><p>示例:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = <span class="built_in">new</span> Trie();</span><br><span class="line">trie.<span class="keyword">insert</span>(&quot;apple&quot;);</span><br><span class="line">trie.<span class="keyword">search</span>(&quot;apple&quot;);   // 返回 <span class="keyword">true</span></span><br><span class="line">trie.<span class="keyword">search</span>(&quot;app&quot;);     // 返回 <span class="keyword">false</span></span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 <span class="keyword">true</span></span><br><span class="line">trie.<span class="keyword">insert</span>(&quot;app&quot;);   </span><br><span class="line">trie.<span class="keyword">search</span>(&quot;app&quot;);     // 返回 <span class="keyword">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>你可以假设所有的输入都是由小写字母 a-z 构成的。</li><li>保证所有输入均为非空字符串。</li></ul><h4 id="代码：-22"><a href="#代码：-22" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isval;</span><br><span class="line">    TrieNode()&#123;</span><br><span class="line">        isval=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">            child[i]=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    TrieNode* root;</span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root=<span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        TrieNode* t=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">word</span>.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!t-&gt;child[<span class="keyword">word</span>[i]-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                t-&gt;child[<span class="keyword">word</span>[i]-<span class="string">&#x27;a&#x27;</span>]=<span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[<span class="keyword">word</span>[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        t-&gt;isval=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        TrieNode* t=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">word</span>.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!t)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[<span class="keyword">word</span>[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !t?<span class="literal">false</span>:t-&gt;isval;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* t=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prefix.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!t)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[prefix[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !t?<span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="基础练习："><a href="#基础练习：" class="headerlink" title="基础练习："></a>基础练习：</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h4><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="题解：-11"><a href="#题解：-11" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>递归应用。</p></blockquote><h4 id="代码：-23"><a href="#代码：-23" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* right=invertTree(root-&gt;left);</span><br><span class="line">        root-&gt;left=invertTree(root-&gt;right);</span><br><span class="line">        root-&gt;right=right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><h4 id="题目描述：-17"><a href="#题目描述：-17" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例 1:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">Tree <span class="number">1</span>                     Tree <span class="number">2</span>                  </span><br><span class="line">          <span class="number">1</span>                         <span class="number">2</span>                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        <span class="number">3</span>   <span class="number">2</span>                     <span class="number">1</span>   <span class="number">3</span>                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      <span class="number">5</span>                             <span class="number">4</span>   <span class="number">7</span>                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">     <span class="number">3</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">  / \   \ </span><br><span class="line"> <span class="number">5</span>   <span class="number">4</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 合并必须从两个树的根节点开始。</p><h4 id="题解：-12"><a href="#题解：-12" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>同样是递归。每个位置一共有三种情况：</p><ol><li>r1和r2都为空：返回NULL</li><li>r1、r2一个空，一个不空，返回非空那个节点</li><li>r1和r2都不空：将r2节点的值加到r1节点1的值，然后返回r1</li></ol></blockquote><h4 id="代码：-24"><a href="#代码：-24" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//情况1、2</span></span><br><span class="line">        <span class="keyword">if</span>(!t1)</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(!t2)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">//情况3</span></span><br><span class="line">        t1-&gt;val+=t2-&gt;val;</span><br><span class="line">        t1-&gt;left=mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class="line">        t1-&gt;right=mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一个树的子树</a></h3><h4 id="题目描述：-18"><a href="#题目描述：-18" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p><p>示例 1:<br>给定的树 s:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure><p>给定的树 t：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">4</span> </span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure><p>返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p><h4 id="题解：-13"><a href="#题解：-13" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>辅助函数：判断分别以两个节点为根节点的两棵树是否相同。</p><p>主函数：如果当前值等于子树的根节点的值，调用辅助函数，否则继续递归调用。</p></blockquote><h4 id="代码：-25"><a href="#代码：-25" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//判断分别以s和t的两棵的树是否结构相同</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* s,TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s&amp;&amp;!t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!s||!t||s-&gt;val!=t-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isSameTree(s-&gt;left,t-&gt;left)&amp;&amp;isSameTree(s-&gt;right,t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前节点值等于子树根节点t的值，调用辅助函数</span></span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val==t-&gt;val)</span><br><span class="line">            <span class="keyword">if</span>(isSameTree(s,t))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对左右子树递归调用</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(s-&gt;left,t)||isSubtree(s-&gt;right,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h3><h4 id="题目描述：-19"><a href="#题目描述：-19" class="headerlink" title="题目描述："></a>题目描述：</h4><p>计算给定二叉树的所有左叶子之和。</p><p>示例：</p><pre><code>    3   / \  9  20    /  \   15   7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</code></pre><h4 id="题解：-14"><a href="#题解：-14" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>采用一个变量lor来标记是否为左孩子。</p></blockquote><h4 id="代码：-26"><a href="#代码：-26" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">leftSum</span><span class="params">(TreeNode* root,<span class="keyword">int</span> lor,<span class="keyword">int</span>&amp; sum)</span> </span>&#123;<span class="comment">//先序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lor&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right)&#123;<span class="comment">//当前节点为左叶子节点</span></span><br><span class="line">            sum+=root-&gt;val;<span class="comment">//更新sum</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        leftSum(root-&gt;left,<span class="number">1</span>,sum);</span><br><span class="line">        leftSum(root-&gt;right,<span class="number">0</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        leftSum(root-&gt;left,<span class="number">1</span>,sum);</span><br><span class="line">        leftSum(root-&gt;right,<span class="number">0</span>,sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h3><h4 id="题目描述：-20"><a href="#题目描述：-20" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，在树的最后一行找到最左边的值。</p><p><strong>示例 1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="题解1：-1"><a href="#题解1：-1" class="headerlink" title="题解1："></a>题解1：</h4><blockquote><p>层次遍历，用一个变量记录二叉树每行的最左边的节点的值，每遍历一行更新一次。</p></blockquote><h4 id="代码：-27"><a href="#代码：-27" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span>=q.<span class="built_in">size</span>();</span><br><span class="line">            ans=q.front()-&gt;val;<span class="comment">//更新最左边节点的值</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">size</span>--)&#123;</span><br><span class="line">                TreeNode* t=q.front();q.pop();</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解2：-1"><a href="#题解2：-1" class="headerlink" title="题解2："></a>题解2：</h4><blockquote><p>上面的解法是从左到右的遍历每一行，我们可以反过来，从右到左的遍历每一行，那么最后一个节点的值就是答案了。</p></blockquote><h4 id="代码：-28"><a href="#代码：-28" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *t=root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(t);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            t=q.front();q.pop();</span><br><span class="line">            <span class="comment">//从右到左</span></span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解3："><a href="#题解3：" class="headerlink" title="题解3："></a>题解3：</h4><blockquote><p>上面两个解法都是bfs，其实也可以用dfs来解。我们用两个变量depth、maxdepth来记录当前节点的深度，maxdepth记录已经访问过节点的最大深度，ans记录最左节点的值。maxdepth要用<strong>引用传递</strong>。只有一种情况需要改变ans：当前节点深度大于maxdepth，此时同时修改ans和maxdepth。以上都是基于一个原理：<strong>当我们先序遍历一棵二叉树，最先改变maxdepth的肯定是下一层的最左节点</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> depth,<span class="keyword">int</span> &amp;maxdepth,<span class="keyword">int</span> &amp;ans)</span> </span>&#123;<span class="comment">//dfs或先序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(depth&gt;maxdepth)&#123;<span class="comment">//需要更改ans的情况</span></span><br><span class="line">            ans=root-&gt;val;</span><br><span class="line">            maxdepth=depth;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left,depth+<span class="number">1</span>,maxdepth,ans);</span><br><span class="line">        dfs(root-&gt;right,depth+<span class="number">1</span>,maxdepth,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxdepth=<span class="number">0</span>,ans=root-&gt;val;</span><br><span class="line">        dfs(root,<span class="number">0</span>,maxdepth,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h3><h4 id="题目描述：-21"><a href="#题目描述：-21" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p><p>例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 原始二叉搜索树:</span><br><span class="line">              <span class="number">5</span></span><br><span class="line">            /   \</span><br><span class="line">           <span class="number">2</span>     <span class="number">13</span></span><br><span class="line"></span><br><span class="line">输出: 转换为累加树:</span><br><span class="line">             <span class="number">18</span></span><br><span class="line">            /   \</span><br><span class="line">          <span class="number">20</span>     <span class="number">13</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="题解：-15"><a href="#题解：-15" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>三种情况：</p><ol><li><p>当前节点为根节点：大于根节点的值，都在其右子树，所以需要先将右子树的所有节点的值累加，再加上自身的值就是累加树根节点的值。</p></li><li><p>当前节点为右节点：大于右节点的值，都在其右子树，所以需要先将右子树的所有节点的值累加，再加上自身的值就是累加树右节点的值。</p><p><strong>可见：1和2可以合并</strong></p></li><li><p>当前节点为左节点：可知大于左节点的节点在除了其左子树的任何位置，基于1和2的基础上，我们此时只需将其父节点的值加上即可。</p></li></ol><p>其实上面三种情况可以总结为一点：每个累加树节点的值等于除了其左子树外整颗树其他节点的累加和。要计算左节点的值，首先要计算夫节点的还有右节点节点的值，这提示我们要改变遍历树的顺序：<strong>右子树 → 根 → 左子树</strong>。</p></blockquote><h4 id="代码：-29"><a href="#代码：-29" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//sum记录的是包括除了当前节点左子树的所有节点的值的累加总和</span></span><br><span class="line">            convertBST(root-&gt;right);</span><br><span class="line">            sum+=root-&gt;val;</span><br><span class="line">            root-&gt;val=sum;</span><br><span class="line">            convertBST(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="进阶练习："><a href="#进阶练习：" class="headerlink" title="进阶练习："></a>进阶练习：</h2><h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><h4 id="题目描述：-22"><a href="#题目描述：-22" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p></blockquote><p>示例 1:</p><blockquote><p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p></blockquote><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><h4 id="题解：-16"><a href="#题解：-16" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>N中情况：</p><ol><li>当我们在当前节点的左右子树分别找到两个节点p、q，则p、q的最近公共祖先则是当前节点。</li><li>如果仅在当前节点的左子树找到p或q，则p、q最近公共祖先则是当前节点的左孩子。</li><li>如果仅在当前节点的右子树找到p或q，则p、q最近公共祖先则是当前节点的右孩子。</li><li>如果当前节点的左右子树都找不p和q，证明p和q不在树里。</li></ol><p>注意：上面的操作都是要自底向上，否则无法满足“最近”这个条件。同时，如果p和q有一个在树里，一个不在树里，这个方法行不通，但是由于题目说明p和q均在树里，所以。。。</p></blockquote><h4 id="代码：-30"><a href="#代码：-30" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root||root==p||root==q)<span class="comment">//如果当前节点就是要找的两个节点之一或者当前节点为空</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自底向上，先查找子树</span></span><br><span class="line">        TreeNode *left=lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        TreeNode *right=lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!left)<span class="comment">//在右子树中找到p和q，又或者没找到</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(!right)<span class="comment">//在左子树中找到p和q，又或者没找到</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span>(left&amp;&amp;right)<span class="comment">//p和q分布在当前节点的左右子树</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h3><h4 id="题目描述：-23"><a href="#题目描述：-23" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p></blockquote><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><p>给定的有序链表： [-10, -3, 0, 5, 9],</p><p>一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</p><pre><code>     0    / \  -3   9  /   / -10  5</code></pre><h4 id="题解1：-2"><a href="#题解1：-2" class="headerlink" title="题解1："></a>题解1：</h4><blockquote><p>将链表转为数组，然后递归生成。由于要求树是高度平衡的，所以每次都已区间的中间点作为当前树的根节点，这样就可以确保生成的树是高度平衡的。典型的用空间换时间。</p></blockquote><h4 id="代码：-31"><a href="#代码：-31" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v,<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(v[l]);</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        TreeNode *root=<span class="keyword">new</span> TreeNode(v[mid]);</span><br><span class="line">        root-&gt;left=helper(v,l,mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=helper(v,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(;head;head=head-&gt;next)</span><br><span class="line">            v.push_back(head-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> helper(v,<span class="number">0</span>,v.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解2：-2"><a href="#题解2：-2" class="headerlink" title="题解2："></a>题解2：</h4><blockquote><p>直接在链表上递归建树，不过由于链表不能随机定位，需要一步一步找出链表的中间节点，这也是这个方法的主要耗时步骤。其实方法类似于二分查查找1.</p></blockquote><h4 id="代码：-32"><a href="#代码：-32" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(ListNode* head,ListNode *tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==tail)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *fast,*slow;</span><br><span class="line">        slow=head;fast=head;</span><br><span class="line">        <span class="comment">//快慢指针找[head,tail)范围的中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=tail&amp;&amp;fast-&gt;next!=tail)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(slow-&gt;val);</span><br><span class="line">        <span class="comment">//递归生成左右子树</span></span><br><span class="line">        root-&gt;left=buildTree(head,slow);</span><br><span class="line">        root-&gt;right=buildTree(slow-&gt;next,tail);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(head,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="897-递增顺序查找树"><a href="#897-递增顺序查找树" class="headerlink" title="897. 递增顺序查找树"></a><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序查找树</a></h3><h4 id="题目描述：-24"><a href="#题目描述：-24" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个树，请你 <strong>按中序遍历</strong> 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p><p><strong>示例 ：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">    <span class="number">3</span>    <span class="number">6</span></span><br><span class="line">   / \    \</span><br><span class="line">  <span class="number">2</span>   <span class="number">4</span>    <span class="number">8</span></span><br><span class="line"> /        / \ </span><br><span class="line"><span class="number">1</span>        <span class="number">7</span>   <span class="number">9</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span></span><br><span class="line">  \</span><br><span class="line">   <span class="number">2</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">3</span></span><br><span class="line">      \</span><br><span class="line">       <span class="number">4</span></span><br><span class="line">        \</span><br><span class="line">         <span class="number">5</span></span><br><span class="line">          \</span><br><span class="line">           <span class="number">6</span></span><br><span class="line">            \</span><br><span class="line">             <span class="number">7</span></span><br><span class="line">              \</span><br><span class="line">               <span class="number">8</span></span><br><span class="line">                \</span><br><span class="line">                 <span class="number">9</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="题解：-17"><a href="#题解：-17" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>先中序遍历得到序列，然后根据序列逐个节点建树。</p></blockquote><h4 id="代码：-33"><a href="#代码：-33" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        inorder(root-&gt;left,inorder_route);</span><br><span class="line">        inorder_route.push_back(root-&gt;val);</span><br><span class="line">        inorder(root-&gt;right,inorder_route);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_route;</span><br><span class="line">        inorder(root,inorder_route);</span><br><span class="line">        TreeNode *ans=<span class="keyword">new</span> TreeNode;</span><br><span class="line">        TreeNode *finalroot=ans;</span><br><span class="line">        <span class="comment">//逐个节点建树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder_route.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            ans-&gt;right=<span class="keyword">new</span> TreeNode(inorder_route[i]);</span><br><span class="line">            ans=ans-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalroot-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="653-两数之和-IV-输入-BST"><a href="#653-两数之和-IV-输入-BST" class="headerlink" title="653. 两数之和 IV - 输入 BST"></a><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></h4><h4 id="题目描述：-25"><a href="#题目描述：-25" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p><p><strong>案例 1:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> </span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">3</span>   <span class="number">6</span></span><br><span class="line"> <span class="string">/</span> <span class="string">\</span>   <span class="string">\</span></span><br><span class="line"><span class="number">2</span>   <span class="number">4</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="string">Target</span> <span class="string">=</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="string">输出:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="题解：-18"><a href="#题解：-18" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>利用bst的性质，其中序遍历序列是升序的。然后问题转化成在升序序列中查找是否存在两个值之和等于目标值的问题了。双指针解决。</p></blockquote><h4 id="代码：-34"><a href="#代码：-34" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            inorder(root-&gt;left,inorder_route);</span><br><span class="line">            inorder_route.push_back(root-&gt;val);</span><br><span class="line">            inorder(root-&gt;right,inorder_route);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_route;</span><br><span class="line">        inorder(root,inorder_route);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=inorder_route.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//双指针部分</span></span><br><span class="line">            <span class="keyword">if</span>(inorder_route[l]+inorder_route[r]&lt;k)</span><br><span class="line">                ++l;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(inorder_route[l]+inorder_route[r]&gt;k)</span><br><span class="line">                --r;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3><h4 id="题目描述：-26"><a href="#题目描述：-26" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li><p>首先找到需要删除的节点</p></li><li><p>如果找到了，删除它。</p></li></ol><p>   说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p><p><strong>示例:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">root</span> <span class="string">=</span> [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>]</span><br><span class="line"><span class="string">key</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">3</span>   <span class="number">6</span></span><br><span class="line"> <span class="string">/</span> <span class="string">\</span>   <span class="string">\</span></span><br><span class="line"><span class="number">2</span>   <span class="number">4</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="string">给定需要删除的节点值是</span> <span class="number">3</span><span class="string">，所以我们首先找到</span> <span class="number">3</span> <span class="string">这个节点，然后删除它。</span></span><br><span class="line"></span><br><span class="line"><span class="string">一个正确的答案是</span> [<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>]<span class="string">,</span> <span class="string">如下图所示。</span></span><br><span class="line"></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"> <span class="string">/</span>     <span class="string">\</span></span><br><span class="line"><span class="number">2</span>       <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="string">另一个正确答案是</span> [<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>]<span class="string">。</span></span><br><span class="line"></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">6</span></span><br><span class="line">   <span class="string">\</span>   <span class="string">\</span></span><br><span class="line">    <span class="number">4</span>   <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="题解：-19"><a href="#题解：-19" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>以下n种情况：</p><p>   0.当前节点为空返回NULL。</p><ol><li><p>当前节点小于目标值，对右子树递归调用。</p></li><li><p>当前节点大于目标值，对左子树递归调用。</p></li></ol><ol><li><p>当前节点等于目标值：</p><p>3.1.当前节点为叶子节点，直接删除当前节点，返回NULL</p><p>3.2.当前节点左子树为空，右子树不空，直接用当前节点的右孩子代替当前节点位置，返回root-&gt;right</p><p>3.3.当前节点右子树为空，左子树不空，直接用当前节点的左孩子代替当前节点位置，</p><p>返回root-&gt;left</p></li></ol><p>   3.4.当前节点左右不空，有两种选择办法：    </p><p>   ​    3.4.1.从左子树中找到值最大节点的位置，与交换当前节点交换值，然后对左子树                递归删除</p><p>   ​    3.4.2.从右子树中找到值最小节点的位置，与交换当前节点交换值，然后对右子树                递归删除</p></blockquote><h4 id="代码：-35"><a href="#代码：-35" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="comment">//情况0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;key)<span class="comment">//情况1</span></span><br><span class="line">            root-&gt;right=deleteNode(root-&gt;right,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&gt;key)<span class="comment">//情况2</span></span><br><span class="line">            root-&gt;left=deleteNode(root-&gt;left,key);</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//情况3</span></span><br><span class="line">            <span class="comment">//情况3.1</span></span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)&#123;<span class="comment">//root为叶子节点</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                root=<span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况3.3</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;right)&#123;<span class="comment">//如果root-&gt;left非空</span></span><br><span class="line">                TreeNode* t=root-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况3.2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left)&#123;</span><br><span class="line">                TreeNode* t=root-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//情况3.4</span></span><br><span class="line">                <span class="comment">//找到右子树的值最小的节点</span></span><br><span class="line">                TreeNode* temp=root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span>(temp-&gt;left)temp=temp-&gt;left；</span><br><span class="line">                swap(root-&gt;val,temp-&gt;val); <span class="comment">// 交换值</span></span><br><span class="line">                root-&gt;right=deleteNode(root-&gt;right,key); <span class="comment">// 进入遍历，删除key</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题---位运算</title>
      <link href="/2020/07/29/bit-operate/"/>
      <url>/2020/07/29/bit-operate/</url>
      
        <content type="html"><![CDATA[<h2 id="1-位运算符号"><a href="#1-位运算符号" class="headerlink" title="1.位运算符号"></a>1.位运算符号</h2><div class="table-container"><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>^</td><td>异或</td></tr><tr><td>&amp;</td><td>按位与</td></tr><tr><td>\</td><td>按位或</td></tr><tr><td>&gt;&gt;</td><td>算术右移</td></tr><tr><td>&lt;&lt;</td><td>算术左移</td></tr><tr><td>~</td><td>取反</td></tr></tbody></table></div><a id="more"></a><h2 id="2-位运算常见特性-1S代表全1的二进制数字，0S代表全0的二进制数字"><a href="#2-位运算常见特性-1S代表全1的二进制数字，0S代表全0的二进制数字" class="headerlink" title="2.位运算常见特性(1S代表全1的二进制数字，0S代表全0的二进制数字)"></a>2.位运算常见特性(1S代表全1的二进制数字，0S代表全0的二进制数字)</h2><div class="table-container"><table><thead><tr><th>X ^ 0S = X</th><th>X &amp; 0S = 0</th><th>X \</th><th>0S = X</th></tr></thead><tbody><tr><td>X ^ 1S = ~X</td><td>X &amp; 1S = X</td><td>X \</td><td>1S = 1S</td></tr><tr><td>X ^ X = 0</td><td>X &amp; X = X</td><td>X \</td><td>X =X</td></tr></tbody></table></div><p><code>另有</code>：</p><ul><li><strong>n&amp;(n-1)可以去除n中最低位的1（最右边的1）。例如对于二进制表示11110100<br>，减去 1 得到 11110011，这两个数按位与得到 11110000</strong></li><li><strong>n&amp;(-n)可以得出n中最低位的1（最右边的1）。例如对于二进制表示 11110100，取负得到 00001100，这两个数按位与得到 00000100</strong></li></ul><h2 id="基础题："><a href="#基础题：" class="headerlink" title="基础题："></a>基础题：</h2><h3 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p><p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p><p>注意：<br>0 ≤ x, y &lt; (2)^31</p><p>示例:</p><blockquote><p>输入: x = 1, y = 4</p><p>输出: 2</p><p>解释:<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>       ↑   ↑</p></blockquote><p>上面的箭头指出了对应二进制位不同的位置。</p><h4 id="题解：所谓“Hamming距离”就是两个数异或后1的个数。"><a href="#题解：所谓“Hamming距离”就是两个数异或后1的个数。" class="headerlink" title="题解：所谓“Hamming距离”就是两个数异或后1的个数。"></a>题解：所谓“Hamming距离”就是两个数异或后1的个数。</h4><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dif=x^y;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计x^y中1的个数</span></span><br><span class="line">        <span class="keyword">while</span>(dif)&#123;</span><br><span class="line">            ans+=dif&amp;<span class="number">1</span>;</span><br><span class="line">            dif&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a><a href="https://leetcode-cn.com/problems/reverse-bits/">190. 颠倒二进制位</a></h4><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p>颠倒给定的 32 位无符号整数的二进制位。</p><p>示例 1：</p><blockquote><p>输入: 00000010100101000001111010011100<br>输出: 00111001011110000010100101000000<br>解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</p></blockquote><p>题解：</p><blockquote><p><code>“逐位颠倒”</code>法：ans初始为0，每次用n&amp;1得出n的最低位，ans += n&amp;1,并且左移一位：ans &lt;&lt;= 1，这样n的最低位都是从ans的左边往右边加上的。</p></blockquote><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;++i)&#123;</span><br><span class="line">            ans&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            ans+=n&amp;<span class="number">1</span>;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></h3><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><blockquote><p>输入: [2,2,1]<br>输出: 1</p></blockquote><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>由上面提到的位运算特性可知，<strong>X &amp; X = 0</strong>和<strong>X ^ 0 = X</strong>，因为其他数字都是成对出现，所以他们异或得到0，然后0在与那个只出现一次的数字异或运算得到这个只出现了一次的数字。</p></blockquote><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            ans^=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a href="https://leetcode-cn.com/problems/single-number-ii/">137. 只出现一次的数字 II</a></h3><h4 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><blockquote><p>输入: [2,2,3,2]<br>输出: 3</p></blockquote><h4 id="题解：参考题解"><a href="#题解：参考题解" class="headerlink" title="题解：参考题解"></a>题解：<a href="https://leetcode-cn.com/problems/single-number-ii/solution/luo-ji-dian-lu-jiao-du-xiang-xi-fen-xi-gai-ti-si-l/">参考题解</a></h4><h3 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></h3><h4 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p><p><strong>示例 :</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>结果输出的顺序并不重要，对于上面的例子， <code>[5, 3]</code> 也是正确答案。</li><li>你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</li></ol><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>设两个只出现一次的元素为x和y，我们先得出整个数组异或的值mask，其实mask=x^y。</p><p>我们无法仅仅从mask分离出x和y。但是我们可以找出两者的区别。mask=mask^(-mask)来保留最右边的1，使其余位置置0，这个要么来自x，要么来自y。然后再遍历一次数组，找出x或者y，其中与mask中1的位置相同的都有可能，所以令x=0，如果<strong>num&amp;diff != 0</strong>,x^=num.因为其他元素都会出现两次，所以他们异或会得出0，最终x就会是x和y的其中一个。然后另一个可以用mask^x得出。</p></blockquote><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mask=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)</span><br><span class="line">            mask^=num;</span><br><span class="line">        <span class="keyword">int</span> diff=mask&amp;(-mask);</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)</span><br><span class="line">            <span class="keyword">if</span>(num&amp;diff)</span><br><span class="line">                x^=num;</span><br><span class="line">        <span class="keyword">return</span> &#123;x,mask^x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="342-4的幂"><a href="#342-4的幂" class="headerlink" title="342. 4的幂"></a><a href="https://leetcode-cn.com/problems/power-of-four/">342. 4的幂</a></h3><h4 id="题目描述：-5"><a href="#题目描述：-5" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>观察4的幂次方的二进制形式，4^0=1,4^1=100,4^2=10000,4^3=1000000,4^4=100000000,…..</p><p>可见4的幂次方的二进制只有一个1，可以用n&amp;(n-1)去掉最低位的1后，检测是否为0，然后再观察1的位置，全部都是在奇数位的位置。所以可以用与二进制10101010101…..01进行按位与操作，看是否不为0，若为0代表奇数位上没有0，否则代表奇数位上有0，再加上前面的只有一个0的结论可以得出该数就是4的幂次方。</p></blockquote><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num&gt;<span class="number">0</span> &amp;&amp; !(num&amp;(num<span class="number">-1</span>)) &amp;&amp; (num&amp;<span class="number">1431655765</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="318-最大单词长度乘积"><a href="#318-最大单词长度乘积" class="headerlink" title="318. 最大单词长度乘积"></a><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></h3><h4 id="题目描述：-6"><a href="#题目描述：-6" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p><p>示例 1:</p><blockquote><p>输入: [“abcw”,”baz”,”foo”,”bar”,”xtfn”,”abcdef”]<br>输出: 16<br>解释: 这两个单词为 “abcw”, “xtfn”。</p></blockquote><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>为每个单词建立一个记录其字符的存在情况的数组，这里用长度为26<strong>bitset</strong>记录，若存在某个字符，bitset对应位置置为1，否则为0。然后每次两个单词相乘时，先用bitset进行按位与运算看是否有相同字符。</p></blockquote><h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>=words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">bitset</span>&lt;26&gt;&gt; <span class="title">len</span><span class="params">(<span class="built_in">size</span>)</span></span>;<span class="comment">//每个单词的字符情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;++i)&#123;<span class="comment">//建立每个单词对应的bitset</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> CHAR:words[i])&#123;</span><br><span class="line">                len[i].<span class="built_in">set</span>(CHAR-<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">size</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="comment">//若两者没有公共字符，且两者长度之积比现有的记录还大，则更新maxlen</span></span><br><span class="line">                <span class="keyword">if</span>(!(len[i]&amp;len[j]).any()&amp;&amp;maxlen&lt;words[i].<span class="built_in">size</span>()*words[j].<span class="built_in">size</span>())&#123;</span><br><span class="line">                    maxlen=words[i].<span class="built_in">size</span>()*words[j].<span class="built_in">size</span>();</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></h3><h4 id="题目描述：-7"><a href="#题目描述：-7" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><p>示例 1:</p><blockquote><p>输入: 2<br>输出: [0,1,1]</p></blockquote><p>示例 2:</p><blockquote><p>输入: 5<br>输出: [0,1,1,2,1,2]</p></blockquote><p>进阶:</p><ul><li>给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？</li><li>要求算法的空间复杂度为O(n)。</li><li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</li></ul><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>经过观察，每一个数<strong>i</strong>比其一半<strong>i/2</strong>在最低位多了一位数，而这个数是0是1取决于i的奇偶，i为奇数，则多一个1，为偶数，则多一个0.</p><p>还有一种思路：</p><ol><li>如果当前数字i的最低位为1,则i为奇数，则前一位数i-1为偶数，i只比i-1多了一个1，所以<strong>dp[i]=dp[i-1]+1</strong>,</li><li>如果当前数字i的最低位为0,则i为偶数，则i只比i/2多了一个0，i与i-1中1的个数相同，所以<strong>dp[i]=dp[i/2]</strong>。</li></ol></blockquote><h4 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(num+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i)&#123;</span><br><span class="line">            ans[i]=ans[i&gt;&gt;<span class="number">1</span>]+(i%<span class="number">2</span>);</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a><a href="https://leetcode-cn.com/problems/missing-number/">268. 缺失数字</a></h3><h4 id="题目描述：-8"><a href="#题目描述：-8" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p><p>示例 1:</p><blockquote><p>输入: [3,0,1]<br>输出: 2</p></blockquote><p>示例 2:</p><blockquote><p>输入: [9,6,4,2,3,5,7,0,1]<br>输出: 8</p></blockquote><p><strong>说明</strong>:<br>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</p><h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><ul><li><h4 id="方法1：直接排序，在遍历一遍数组，如果该数与下标不匹配，则该数为缺失值。"><a href="#方法1：直接排序，在遍历一遍数组，如果该数与下标不匹配，则该数为缺失值。" class="headerlink" title="方法1：直接排序，在遍历一遍数组，如果该数与下标不匹配，则该数为缺失值。"></a>方法1：直接排序，在遍历一遍数组，如果该数与下标不匹配，则该数为缺失值。</h4></li><li><p>方法2：哈希表，遍历一次数组，将数置入哈希表中，第二次遍历[0..n]看是否在哈希表中，不在则为缺失值。</p></li><li><p>方法3：位运算，由位运算特性可知，一个数和自身进行异或运算等于0，一个数与0异或得出还是这个数自身。所以我们可以先求出[0..n]的异或值，再与数组中的数一一异或，最后得出的数组就是缺失值。</p></li><li><p>方法4：直接用高斯等差数列公式求[0..n]的总和，再减去数组总和，得出的差就是缺失值。</p></li></ul><div class="table-container"><table><thead><tr><th>方法</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>直接排序</td><td>N<em>logN+N     O(N </em> logN)</td><td>O(1)或O(N)  取决于使用的排序算法</td></tr><tr><td>哈希表</td><td>N次插入操作，最多N+1次查询 O(N) 查询和插入操作都是O(1)</td><td>O(N)</td></tr><tr><td>位运算</td><td>O(N)</td><td>O(1)</td></tr><tr><td>数列求和</td><td>O(N) ： 求数组总和</td><td>O(1)</td></tr></tbody></table></div><p><code>这里只给出位运算的解法：</code></p><h4 id="代码：-7"><a href="#代码：-7" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> miss=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            miss^=nums[i];</span><br><span class="line">            miss^=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> miss;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="693-交替位二进制数"><a href="#693-交替位二进制数" class="headerlink" title="693. 交替位二进制数"></a><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">693. 交替位二进制数</a></h3><h4 id="题目描述：-9"><a href="#题目描述：-9" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。</p><p>示例 1:</p><blockquote><p>输入: 5<br>输出: True<br>解释:<br>5的二进制数是: 101</p></blockquote><h4 id="题解：-6"><a href="#题解：-6" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>如果n是交替位二进制数，则n=n&amp;(n&gt;&gt;1)得到全1的二进制数字，所以n+1得出最高位为1，其余位为0的二进制数字，那么n&amp;n+1就得出全0。要注意的是为防止溢出n+1要用长整数类型。其实执行n&amp;(n+1)为了验证n=n&amp;(n&gt;&gt;1)是否为全1.</p><p><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/solution/binary-number-with-alternating-bits-by-ikaruga/">参考题解</a></p></blockquote><h4 id="代码：-8"><a href="#代码：-8" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n = (n ^ (n &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> (n &amp; ((<span class="keyword">long</span>)n + <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="476-数字的补数"><a href="#476-数字的补数" class="headerlink" title="476. 数字的补数"></a><a href="https://leetcode-cn.com/problems/number-complement/">476. 数字的补数</a></h3><h4 id="题目描述：-10"><a href="#题目描述：-10" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</p><p>示例 1:</p><blockquote><p>输入: 5<br>输出: 2<br>解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。</p></blockquote><h4 id="题解：-7"><a href="#题解：-7" class="headerlink" title="题解："></a>题解：</h4><blockquote><ol><li>当然也可以统计num除掉前导0后有多少位01，然后得出一个同样位数的全1串与num异或得出补数。</li><li>遍历数字num的每一位，若是0，就加上相应的权值，num每次右移一位直至为0.</li></ol></blockquote><h4 id="代码：-9"><a href="#代码：-9" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//第一种 </span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=num;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            num/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1&lt;&lt;cnt要取长整型防止溢出</span></span><br><span class="line">        <span class="keyword">return</span> n^(<span class="keyword">long</span>(<span class="number">1</span>&lt;&lt;cnt)<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二种</span></span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(num&amp;<span class="number">1</span>))</span><br><span class="line">                ans+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            ++i;</span><br><span class="line">            num/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcod刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题---二分查找</title>
      <link href="/2020/07/24/Binary-Search/"/>
      <url>/2020/07/24/Binary-Search/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode刷题—-二分查找"><a href="#leetcode刷题—-二分查找" class="headerlink" title="leetcode刷题—-二分查找"></a>leetcode刷题—-二分查找</h1><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h2><blockquote><p>二分查找也常被称为二分法或者折半查找，每次查找时通过将待查找区间分成两部分并只取一部分继续查找，将查找的复杂度大大减少。</p><p>二分查找也可以看作双指针的一种特殊情况，但我们一般会将二者区分。双指针类型的题，指针通常是一步一步移动的，而在二分查找里，指针每次移动半个区间长度。</p><p>具体到代码上，二分查找时区间的左右端取开区间还是闭区间在绝大多数时候都可以，因此，有时会容易搞不清楚如何定义区间开闭性。这里提供两个小诀窍，第一是尝试熟练使用一种写法，比如左闭右开（满足 C++、Python 等语言的习惯）或左闭右闭（便于处理边界条件），尽量只保持这一种写法；第二是在刷题时思考如果最后区间只剩下一个数或者两个数，自己的写法是否会陷入死循环，如果某种写法无法跳出死循环，则考虑尝试另一种写法。<br><a id="more"></a><br>例题：</p></blockquote><h4 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a><a href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a></h4><p>题目描述：</p><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:</p><blockquote><p>输入: 4<br>输出: 2</p></blockquote><p>示例 2:</p><blockquote><p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p></blockquote><p>题解：</p><p>我们需要在区间[0,x]中查找一个数mid，使得<strong>mid=x/mid</strong>。这里采用左闭右闭区间。</p><p>设左右指针<strong>l</strong>和<strong>r</strong>，初始时，l=1，r=x；三种情况</p><p>​                    <strong><code>mid=(l+r)/2</code></strong></p><ol><li>如果<strong>x/mid = mid</strong>, 返回mid</li><li>如果<strong>x/mid &gt; mid ， r = mid - 1</strong></li><li>如果<strong>x/mid &lt; mid ， l = mid + 1</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> l=<span class="number">1</span>,r=x,mid,<span class="built_in">sqrt</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">sqrt</span>=x/mid;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">sqrt</span>==mid)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(mid&lt;<span class="built_in">sqrt</span>)</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另解（牛顿迭代法）：</p><p>牛顿迭代法，</p><script type="math/tex; mode=display">X_(n+1)=X_n - f(X_n)/f^、(X_n)</script><script type="math/tex; mode=display">定义f(x) = x^2 - a = 0</script><script type="math/tex; mode=display">迭代公式为X_(n+1) = (X_n + a/X_n)/2</script><blockquote><p>注意 : 这里为了防止 int 超上界，我们使用 long 来存储乘法结果。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x = a;</span><br><span class="line">    <span class="keyword">while</span> (x * x &gt; a) &#123;</span><br><span class="line">    x = (x + a / x) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h4><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><p>示例 1:</p><blockquote><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: [-1,-1]</p></blockquote><p>题解：</p><blockquote><p>这道题可以看作是自己实现 C++ 里的 lower_bound 和 upper_bound 函数。这里我们尝试<br>使用左闭右开的写法，当然左闭右闭也可以。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//查找target在数组中的最小索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//此处是左闭右开区间</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>(),mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找target在数组中的最大索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//此处是左闭右开区间</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>(),mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lower=lower_bound(nums,target);</span><br><span class="line">        <span class="keyword">int</span> upper=upper_bound(nums,target)<span class="number">-1</span>;<span class="comment">//由于此处是左闭右开区间，所以upper要减一</span></span><br><span class="line">        <span class="keyword">if</span>(lower==nums.<span class="built_in">size</span>()||nums[lower]!=target)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            <span class="keyword">return</span> &#123;lower,upper&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a></h4><p>题目描述：</p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p><p>示例 1:</p><blockquote><p>输入: nums = [2,5,6,0,0,1,2], target = 0<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [2,5,6,0,0,1,2], target = 3<br>输出: false<br>进阶:</p></blockquote><ul><li>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。</li><li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</li></ul><p>题解：</p><p>由于是升序数组的旋转数组，那么有可能一半的区间为升序的。</p><p>注意，因为数组存在重复数字，如果中点和左端的数字相同，我们并不能确定是左区间全部<br>相同，还是右区间完全相同。在这种情况下，我们可以简单地将左端点右移一位，然后继续进行<br>二分查找</p><ol><li>当<strong>nums[mid] == nums[l]</strong>时，无法判断哪个区间是升序的，将左指针右移</li><li>当<strong>nums[mid] &lt;= nums[r]</strong>时，右区间是升序的，若<strong>nums[mid]&lt;target&lt;=nums[r] ,  l=mid+1,否则，在左区间，r=mid-1</strong></li><li>当<strong>nums[mid] &gt; nums[l]</strong>时，左区间是升序的，若<strong>nums[l]&lt;=target&lt;nums[mid] ,  r=mid-1,否则，在右区间，l=mid+1</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//线性搜索</span></span><br><span class="line">    <span class="comment">/*bool search(vector&lt;int&gt;&amp; nums, int target) &#123;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;nums.size();++i)</span></span><br><span class="line"><span class="comment">            if(nums[i]==target)</span></span><br><span class="line"><span class="comment">                return true;</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>,mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//无法区分哪个区间是升序的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[l]==nums[mid])</span><br><span class="line">                ++l;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//代表左边区间是升序的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;nums[l])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;=nums[l]&amp;&amp;target&lt;nums[mid])<span class="comment">//target落在[l,mid)区间</span></span><br><span class="line">                    r=mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//代表右边区间是升序的</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&lt;=nums[r])<span class="comment">//target落在(mid,r]区间</span></span><br><span class="line">                    l=mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a></h4><p>题目描述：</p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><p>示例 1：</p><blockquote><p>输入: [1,3,5]<br>输出: 1</p></blockquote><p>示例 2：</p><blockquote><p>输入: [2,2,2,0,1]<br>输出: 0</p></blockquote><p>题解：</p><p><img src="/2020/07/24/Binary-Search/1.png" alt="1"></p><p>观察图可得，设数组最右端的值为x，最小值为min，可知min右边的数一定小于等于x，左边的数一定大于等于x。左右指针l和r，中间指针mid。nums[mid]与nums[r]比较有三种情况。</p><ol><li><strong>nums[mid] &gt; nums[r]</strong>，表明nums[mid]为最小值min左边的数，此时，最小值在<strong>(mid,r]</strong>区间内，即右区间，左区间可以忽略，移动左指针<strong>l = mid + 1</strong>。</li><li><strong>nums[mid] &lt; nums[r]</strong>，表明nums[mid]为最小值min右边的数，此时，最小值在<strong>[l,mid]</strong>区间内，左区间，右区间可以忽略，移动右指针<strong>r = mid </strong>。</li><li><strong>nums[mid] = nums[r]</strong>，无法确定nums[mid]在min的左边还是右边，由于nums[mid]=nums[r]，所以可以移动右指针<strong>r=r-1</strong>来缩小范围。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//线性查找 O(n)</span></span><br><span class="line">    <span class="comment">/*int findMin(vector&lt;int&gt;&amp; nums) &#123;</span></span><br><span class="line"><span class="comment">        int Min=INT_MAX;</span></span><br><span class="line"><span class="comment">        for(int num:nums)</span></span><br><span class="line"><span class="comment">            Min=min(Min,num);</span></span><br><span class="line"><span class="comment">        return Min;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序 O(log N)</span></span><br><span class="line">    <span class="comment">/*int findMin(vector&lt;int&gt;&amp; nums) &#123;</span></span><br><span class="line"><span class="comment">        sort(nums.begin(),nums.end());</span></span><br><span class="line"><span class="comment">        return nums[0];</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>,mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;nums[r])</span><br><span class="line">                r=mid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;nums[r])</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                --r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a></p><p>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</p><p>示例 1:</p><blockquote><p>输入: [1,1,2,3,3,4,4,8,8]<br>输出: 2</p></blockquote><p>示例 2:</p><blockquote><p>输入: [3,3,7,7,10,11,11]<br>输出: 10<br>注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。</p></blockquote><p>题解：</p><p>注意索引的奇偶与独立数出现前后的关系。</p><ol><li>独立数出现之<strong>前</strong>，奇数索引与其<strong>前一位</strong>偶数索引的值相同或者偶数索引于其<strong>后一位</strong>奇数索引的值相同</li><li>独立数出现之<strong>后</strong>，奇数索引与其<strong>后一位</strong>偶数索引的值相同或者偶数索引于其<strong>前一位</strong>奇数索引的值相同</li></ol><p>此时，通过设左右指针和中间指针l、r、mid</p><ul><li>若mid指针满足<strong>情况1</strong>，则独立数出现在mid的右边，将左指针l根据mid的奇偶来移动</li><li>若mid指针满足<strong>情况2</strong>，则独立数出现在mid的左边，将右指针r根据mid的奇偶来移动</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>=nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="built_in">size</span><span class="number">-1</span>,mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mid%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]==nums[mid<span class="number">-1</span>])<span class="comment">//left</span></span><br><span class="line">                    r=mid<span class="number">-2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]==nums[mid+<span class="number">1</span>])<span class="comment">//right</span></span><br><span class="line">                    l=mid+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]==nums[mid<span class="number">-1</span>])<span class="comment">//right</span></span><br><span class="line">                    l=mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]==nums[mid+<span class="number">1</span>])<span class="comment">//left</span></span><br><span class="line">                    r=mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></p><p>题目描述：</p><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p>示例 1:</p><blockquote><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>则中位数是 2.0</p></blockquote><p>示例 2:</p><blockquote><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>则中位数是 (2 + 3)/2 = 2.5</p></blockquote><p>题解：</p><h4 id="方法1：直观的可以想到，开辟一个新数组，直接将两个数组归并，并根据长度的奇偶来返回结果"><a href="#方法1：直观的可以想到，开辟一个新数组，直接将两个数组归并，并根据长度的奇偶来返回结果" class="headerlink" title="方法1：直观的可以想到，开辟一个新数组，直接将两个数组归并，并根据长度的奇偶来返回结果"></a>方法1：直观的可以想到，开辟一个新数组，直接将两个数组归并，并根据长度的奇偶来返回结果</h4><p>假设两个数组长度分别为n和m</p><script type="math/tex; mode=display">时间复杂度=O(n+m)</script><script type="math/tex; mode=display">空间复杂度=O(n+m)</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> size1=nums1.<span class="built_in">size</span>(),size2=nums2.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">int</span> i,j,k;</span><br><span class="line">       i=j=k=<span class="number">0</span>;</span><br><span class="line">       <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(size1+size2,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(i&lt;size1&amp;&amp;j&lt;size2)</span><br><span class="line">           nums[k++]=nums1[i]&lt;=nums2[j]?nums1[i++]:nums2[j++];   </span><br><span class="line">       <span class="keyword">while</span>(i&lt;size1)</span><br><span class="line">           nums[k++]=nums1[i++];</span><br><span class="line">       <span class="keyword">while</span>(j&lt;size2)</span><br><span class="line">           nums[k++]=nums2[j++];</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>((size1+size2)%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> nums[(size1+size2)/<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">else</span>    </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">double</span>(nums[(size1+size2)/<span class="number">2</span><span class="number">-1</span>]+nums[(size1+size2)/<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="方法2：并不需要申请数组，并且合并两个数组，只需找到中位数位置即可（其实就是归并，但是不需要存储整个数组）"><a href="#方法2：并不需要申请数组，并且合并两个数组，只需找到中位数位置即可（其实就是归并，但是不需要存储整个数组）" class="headerlink" title="方法2：并不需要申请数组，并且合并两个数组，只需找到中位数位置即可（其实就是归并，但是不需要存储整个数组）"></a>方法2：并不需要申请数组，并且合并两个数组，只需找到中位数位置即可（其实就是归并，但是不需要存储整个数组）</h4><script type="math/tex; mode=display">时间复杂度=O(n+m)</script><script type="math/tex; mode=display">空间复杂度=O(1)</script><blockquote><p>当长度的奇偶性不同时，对应的代码也不同，将其分为两种情况。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,k,median_index;</span><br><span class="line">        <span class="keyword">double</span> median_value;</span><br><span class="line">        <span class="keyword">int</span> size1=nums1.<span class="built_in">size</span>(),size2=nums2.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((size1+size2)%<span class="number">2</span>==<span class="number">1</span>)<span class="comment">//两个数组总长度为奇数，中位数为第(size1+size2)/2+1个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            median_index=(size1+size2)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            i=j=<span class="number">0</span>;k=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;size1&amp;&amp;j&lt;size2&amp;&amp;k&lt;=median_index)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i]&lt;nums2[j])</span><br><span class="line">                    median_value=nums1[i++];</span><br><span class="line">                <span class="keyword">else</span>    </span><br><span class="line">                    median_value=nums2[j++];</span><br><span class="line">                ++k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=median_index&amp;&amp;i&lt;size1)</span><br><span class="line">                <span class="keyword">for</span>(;k&lt;=median_index;)</span><br><span class="line">                    median_value=nums1[i++],++k;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=median_index&amp;&amp;j&lt;size2)</span><br><span class="line">                <span class="keyword">for</span>(;k&lt;=median_index;)</span><br><span class="line">                    median_value=nums2[j++],++k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span><span class="comment">//总长度为偶数，中位数为中间两数之和的一半</span></span><br><span class="line">        &#123;</span><br><span class="line">            median_index=(size1+size2)/<span class="number">2</span>;</span><br><span class="line">            i=j=<span class="number">0</span>;k=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;size1&amp;&amp;j&lt;size2&amp;&amp;k&lt;=median_index)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i]&lt;nums2[j])</span><br><span class="line">                    median_value=nums1[i++];</span><br><span class="line">                <span class="keyword">else</span>    </span><br><span class="line">                    median_value=nums2[j++];</span><br><span class="line">                ++k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=median_index&amp;&amp;i&lt;size1)</span><br><span class="line">                <span class="keyword">for</span>(;k&lt;=median_index;)</span><br><span class="line">                    median_value=nums1[i++],++k;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=median_index&amp;&amp;j&lt;size2)</span><br><span class="line">                <span class="keyword">for</span>(;k&lt;=median_index;)</span><br><span class="line">                    median_value=nums2[j++],++k;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i&lt;size1&amp;&amp;(j&lt;size2&amp;&amp;nums1[i]&lt;=nums2[j]||j&gt;=size2))</span><br><span class="line">                median_value=<span class="keyword">double</span>(median_value+nums1[i])/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j&lt;size2&amp;&amp;(i&lt;size1&amp;&amp;nums2[j]&lt;=nums1[i]||i&gt;=size1))</span><br><span class="line">                median_value=<span class="keyword">double</span>(median_value+nums2[j])/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> median_value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>将以上奇偶情况合并为一种情况</p><p>1.当长度为奇数时，需要找到第<strong>(n+m)/2</strong>位元素（从0开始）</p><p>2.当长度为偶数时，需要找到第<strong>(n+m)/2-1和(n+m)/2</strong>位元素（从0开始）</p><p>所以奇偶情况都要找到第<strong>(n+m)/2</strong>位元素（从0开始），所以可以用两个变量now、past记录当前找的元素以及上次找的元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m=nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> index1=<span class="number">0</span>,index2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> past=<span class="number">0</span>,now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=(n+m)/<span class="number">2</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            past=now;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(index2&gt;=m||index1&lt;n&amp;&amp;nums1[index1]&lt;=nums2[index2])<span class="comment">//nums2数组遍历完，或则nums1数组当前元素比nums2当前元素要小</span></span><br><span class="line">                now=nums1[index1++];</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//其他情况</span></span><br><span class="line">                now=nums2[index2++];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据长度奇偶性返回结果</span></span><br><span class="line">        <span class="keyword">if</span>((n+m)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">double</span>(past+now)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">double</span>(now);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方法三：二分查找"><a href="#方法三：二分查找" class="headerlink" title="方法三：二分查找"></a>方法三：二分查找</h4><p>根据中位数定义：</p><ul><li><p>n+m为奇数时，中位数为第<strong>(n+m)/2</strong>位数（从0开始）</p></li><li><p>n+m为偶数时，中位数为第<strong>(n+m)/2-1和(n+m)/2</strong>位数（从0开始）</p><blockquote><p>因此问题可以转化为在两个数组中找第k小的数，其中k为<strong>(n+m)/2或者(n+m)/2+1</strong></p></blockquote></li></ul><blockquote><p>假设两个有序数组分别是 A 和 B。要找到第k个元素，我们可以比较 A[k/2-1]和 B[k/2−1]，其中/表示整数除法。由于 A[k/2−1] 和 B[k/2−1] 的前面分别有 A[0..k/2−2] 和 B[0..k/2−2]，即 k/2-1个元素，对于A[k/2−1] 和 B[k/2−1] 中的较小值，最多只会有 k/2-2(k/2−1)+(k/2−1)≤k/2−2 个元素比它小，那么它就不能是第 k 小的数了。</p></blockquote><p>A[k/2-1]与B[k/2-1]的三种比较情况</p><ul><li>当<strong>A[k/2-1] &lt; B[k/2-1]</strong>时，则比<strong>A[k/2-1]</strong>最多有A的前k/2-1个数和B的前k/2-1个数，最多只有k-2个数，因此A[k/2-1]不可能是第k个数，所以A[0]到A[k/2-1]也不可能是第k个数，可以全部排除</li><li>当<strong>A[k/2-1] &gt; B[k/2-1]</strong>时，则比<strong>B[k/2-1]</strong>最多有A的前k/2-1个数和B的前k/2-1个数，最多只有k-2个数，因此B[k/2-1]不可能是第k个数，所以B[0]到B[k/2-1]也不可能是第k个数，可以全部排除。</li><li>当<strong>A[k/2-1] = B[k/2-1]</strong>时，可以归为第一种情况</li></ul><p>三种特殊情况：</p><ul><li>当<strong>k=1</strong>时，只需找出两数组开头元素的最小值。</li><li>当其中一个数组为空时，只需找出另一个数组的第k个元素</li><li>当我们排除了一些元素时，k要减去被除元素的个数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助函数，查找两个数组中的第k小元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKthElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m=nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//越界情况</span></span><br><span class="line">            <span class="keyword">if</span>(i==n)<span class="comment">//nums1数组为空</span></span><br><span class="line">                <span class="keyword">return</span> nums2[j+k<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(j==m)<span class="comment">//nums2数组为空</span></span><br><span class="line">                <span class="keyword">return</span> nums1[i+k<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)<span class="comment">//k=1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[i],nums2[j]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//避免索引越界，若剩下的元素不够k/2-1个，则将索引置为数组最后一个索引</span></span><br><span class="line">            <span class="keyword">int</span> index1=<span class="built_in">min</span>(i+k/<span class="number">2</span><span class="number">-1</span>,n<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">int</span> index2=<span class="built_in">min</span>(j+k/<span class="number">2</span><span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums1[index1]&lt;=nums2[index2])<span class="comment">//情况1和3</span></span><br><span class="line">            &#123;</span><br><span class="line">                k-=index1-i+<span class="number">1</span>;<span class="comment">//k减去排除元素个数</span></span><br><span class="line">                i=index1+<span class="number">1</span>;<span class="comment">//排除nums1数组中index1左边的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span><span class="comment">//情况2</span></span><br><span class="line">            &#123;</span><br><span class="line">                k-=index2-j+<span class="number">1</span>;<span class="comment">//k减去排除元素个数</span></span><br><span class="line">                j=index2+<span class="number">1</span>;<span class="comment">//排除nums1数组中index2左边的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据长度奇偶性返回结果</span></span><br><span class="line">        <span class="keyword">int</span> size1=nums1.<span class="built_in">size</span>(),size2=nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>((size1+size2)%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> getKthElement(nums1,nums2,(size1+size2)/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">double</span>( getKthElement(nums1,nums2,(size1+size2)/<span class="number">2</span>) + getKthElement(nums1,nums2,(size1+size2)/<span class="number">2</span>+<span class="number">1</span>) )/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题---双指针</title>
      <link href="/2020/07/23/double-pointer/"/>
      <url>/2020/07/23/double-pointer/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcod刷题—-双指针"><a href="#leetcod刷题—-双指针" class="headerlink" title="leetcod刷题—-双指针"></a>leetcod刷题—-双指针</h1><h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h3><blockquote><p><code>双指针</code>有可能用于遍历数组（或者链表），通常有两种形式：</p><ol><li>两个指针指向同一个数组中不同的元素（两指针遍历方向可能相同也可能不同）</li><li>两个指针指向不同的数组<a id="more"></a><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2></li></ol></blockquote><h3 id="指向同一数组不同元素："><a href="#指向同一数组不同元素：" class="headerlink" title="指向同一数组不同元素："></a>指向同一数组不同元素：</h3><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167.两数之和</a></p><p>题目描述：</p><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><ol><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ol><p>示例:</p><blockquote><p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><p>题解：</p><p>因为数组已经排序，可以用两个指针l、r分别从数组两边出发，遍历搜索，</p><ol><li>若两数之和大于目标值，则可以将<code>r</code>指针左移；</li><li>若两数之和小于目标值，则可以将<code>l</code>指针右移；</li><li>若两数之和等目标值，返回两元素结束函数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[l]+numbers[r]&gt;target)</span><br><span class="line">                --r;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[l]+numbers[r]&lt;target)</span><br><span class="line">                ++l;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;l+<span class="number">1</span>,r+<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="指向不同数组："><a href="#指向不同数组：" class="headerlink" title="指向不同数组："></a>指向不同数组：</h3><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></p><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><p>说明:</p><ul><li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。</li><li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</li></ul><p>示例:</p><blockquote><p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p></blockquote><p>输出: [1,2,2,3,5,6]</p><p>题解：</p><p>两个数组已经排好序，只需要将两个指针指向两个数组，按顺序放入对应元素即可。有两中方法：</p><ol><li>从两个数组左边开始（需要额外空间，因为不能直接放入nums1数组，可能会覆盖原来的元素）</li><li>从两个数组右边开始</li></ol><p>这里采取第二中方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = m-- + n-- - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) </span><br><span class="line">            nums1[pos--] = nums1[m] &gt; nums2[n]? nums1[m--]: nums2[n--];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) </span><br><span class="line">            nums1[pos--] = nums2[n--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>指向链表：</p><h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><p>题目描述：</p><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p>示例 1：</p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p><img src="/2020/07/23/double-pointer/circularlinkedlist.png" alt="circularlinkedlist"></p><p>题解：</p><p><code>快慢指针</code>两个指针<code>fast</code>,<code>slow</code>,从链表头出发，每次<code>fast</code>指针走两步，<code>slow</code>走一步，若<code>fast</code>指针能走到链表尾，则说明链表无环，否则fast可以无限走下去，会在某时刻与<code>slow</code>相遇，代表有环。我们将<code>slow</code>指针重新指向链表头，让<code>fast</code>和<code>slow</code>指针每次都走一步。当<code>fast</code>和<code>slow</code>第二次相遇时，此时这个节点为环的起点。具体代码如下：</p><p>链表结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow,*fast;</span><br><span class="line">        slow=fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;<span class="comment">//fast走两步</span></span><br><span class="line">            slow=slow-&gt;next; <span class="comment">//slow走一步</span></span><br><span class="line">            <span class="keyword">if</span>(slow==fast)<span class="comment">//第一次相遇</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!fast||!fast-&gt;next)<span class="comment">//fast走到链表尾</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        slow=head;<span class="comment">//将slow重新移到链表头</span></span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)<span class="comment">//slow和fast每次都走一步</span></span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次相遇</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="指向同一数组，且两指针移动方向相同"><a href="#指向同一数组，且两指针移动方向相同" class="headerlink" title="指向同一数组，且两指针移动方向相同"></a>指向同一数组，且两指针移动方向相同</h3><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><p>题目描述：</p><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><p>示例：</p><blockquote><p>输入: S = “ADOBECODEBANC”, T = “ABC”<br>输出: “BANC”<br>说明：</p></blockquote><ul><li>如果 S 中不存这样的子串，则返回空字符串 “”。</li><li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p>题解：</p><p><strong>滑动窗口求解</strong> ，两个指针<strong>l</strong>和<strong>r</strong>都是从最左端向最右端移动</p><p>用数组chars和flag记录字符串t的字符情况</p><ol><li>移动右指针，根据字符来处理chars和flag数组，cnt记录已经包含字符串t的字符个数</li><li>当cnt等于t.size(),尝试移动左指针<strong>l</strong>，缩小范围，min_size, min_l 用于记录最优解</li><li>若min_size &gt; s.size()返回空串，否则返回s.substr(min_l , min_size)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> chars[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> flag[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计字符串t中的字符情况        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();++i)</span><br><span class="line">            flag[t[i]]=<span class="number">1</span>,++chars[t[i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,cnt=<span class="number">0</span>,min_l,min_size=s.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(;r&lt;s.<span class="built_in">size</span>();++r)<span class="comment">//遍历字符串s</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[s[r]])</span><br><span class="line">                <span class="keyword">if</span>(--chars[s[r]]&gt;=<span class="number">0</span>)</span><br><span class="line">                    ++cnt;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//仅当字符串t中所有字符被包含时</span></span><br><span class="line">            <span class="comment">//才尝试移动左指针l</span></span><br><span class="line">            <span class="keyword">while</span>(cnt==t.<span class="built_in">size</span>())<span class="comment">//如果字符串t中所有字符已包含</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//尝试移动左指针</span></span><br><span class="line">                <span class="keyword">if</span>(r-l+<span class="number">1</span>&lt;min_size)</span><br><span class="line">                &#123;</span><br><span class="line">                    min_l=l;</span><br><span class="line">                    min_size=r-l+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//因为左指针移动，导致t中字符缺失</span></span><br><span class="line">                <span class="keyword">if</span>(flag[s[l]]&amp;&amp;++chars[s[l]]&gt;<span class="number">0</span>)</span><br><span class="line">                    --cnt;</span><br><span class="line">                <span class="comment">//移动左指针</span></span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不存在就返回空字符串</span></span><br><span class="line">        <span class="comment">//否则返回</span></span><br><span class="line">        <span class="keyword">return</span> min_size&gt;s.<span class="built_in">size</span>()?<span class="string">&quot;&quot;</span>:s.substr(min_l,min_size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="巩固练习："><a href="#巩固练习：" class="headerlink" title="巩固练习："></a>巩固练习：</h2><h4 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633. 平方数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/">633. 平方数之和</a></h4><p>题目描述：</p><p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。</p><p>示例1:</p><blockquote><p>输入: 5<br>输出: True<br>解释: 1 <em> 1 + 2 </em> 2 = 5</p></blockquote><p>示例2:</p><blockquote><p>输入: 3<br>输出: False</p></blockquote><p>题解：</p><p>双指针，<strong>l</strong>和<strong>r</strong>分别指向0和sqrt(c)从两边向中间移动（细节：需要用long存l和r，否则会溢出）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l=<span class="number">0</span>,r=<span class="built_in">sqrt</span>(c),total;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            total=l*l+r*r;</span><br><span class="line">            <span class="keyword">if</span>(total&gt;c)</span><br><span class="line">                --r;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(total&lt;c)</span><br><span class="line">                ++l;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l&lt;=r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">680. 验证回文字符串 Ⅱ</a></h4><p>题目描述：</p><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><p>示例 1:</p><blockquote><p>输入: “aba”<br>输出: True</p></blockquote><p>示例 2:</p><blockquote><p>输入: “abca”<br>输出: True<br>解释: 你可以删除c字符。</p></blockquote><p>题解：</p><p><strong>双指针</strong>，左右指针l和r，如果两个指针所指字符相同，则两指针往中间移动，否则，只能移动其中一侧的指针，此时对应两种情况，移动l和移动r（借助辅助函数实现）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//检测去掉其中一个字符后，剩下的字符串是否为回文串</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l]!=s[r])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ++l;--r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>=s.<span class="built_in">size</span>(),l=<span class="number">0</span>,r=<span class="built_in">size</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l]==s[r])<span class="comment">//左右两个字符相同</span></span><br><span class="line">                ++l,--r;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//去掉左指针所指字符或者去掉右指针所指字符</span></span><br><span class="line">                <span class="keyword">return</span> helper(s,l+<span class="number">1</span>,r)||helper(s,l,r<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a></h4><p>题目描述：</p><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p><p>示例 1:</p><blockquote><p>输入:<br>s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]</p><p>输出:<br>“apple”</p></blockquote><p>题解：</p><p>遍历vector<string> d,每次调用辅助函数，检测s是否可以通过删除字符得到对应字符串，若可以则用ans记录，辅助函数，简单的双指针应用，类似于合并数组。</string></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s1,<span class="built_in">string</span> s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s1.<span class="built_in">size</span>()&amp;&amp;j&lt;s2.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==s2[j])</span><br><span class="line">                ++i,++j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j==s2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findLongestWord</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:d)</span><br><span class="line">            <span class="keyword">if</span>(helper(s,str)&amp;&amp;(str.<span class="built_in">size</span>()&gt;ans.<span class="built_in">size</span>()||str.<span class="built_in">size</span>()==ans.<span class="built_in">size</span>()&amp;&amp;str&lt;ans))</span><br><span class="line">                ans=str;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h4><p>题目描述：</p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p>示例：</p><blockquote><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p><p>返回链表 4-&gt;5.</p></blockquote><p>题解：</p><p>倒数第k个，也就是第n-k个（n为链表长度），问题是如何得到这个n，可以先遍历一次链表，得到n，再走n-k步，第二种方法是，先让first走k步，然后second从链表头开始和first一起走到first为链表尾为止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *first=head;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//first先走k步</span></span><br><span class="line">        <span class="keyword">while</span>(++i&lt;=k&amp;&amp;first)</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果链表没有k个节点，返回NULL</span></span><br><span class="line">        <span class="keyword">if</span>(!first&amp;&amp;i&lt;k)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *second=head;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">//接下来first和second一起走n-k步（n为链表长度）</span></span><br><span class="line">        <span class="keyword">while</span>(first)</span><br><span class="line">        &#123;</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0-1背包及其扩展</title>
      <link href="/2020/07/14/0-1-knapsack/"/>
      <url>/2020/07/14/0-1-knapsack/</url>
      
        <content type="html"><![CDATA[<h1 id="0-1背包及其扩展"><a href="#0-1背包及其扩展" class="headerlink" title="0-1背包及其扩展"></a>0-1背包及其扩展</h1><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><blockquote><p>现有n件物品和一个容量为c的背包。第i件物品的重量是重量为w[i]，价值是v[i]。已知对于一件物品必须选择取（用1表示）或者不取（用0表示），且每件物品只能被取一次（这就是“0-1”的含义）。求放置哪些物品进背包，可使这些物品的重量总和不超过背包容量，且价值总和最大。<br><a id="more"></a></p><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h3></blockquote><p>动态规划。用一个矩阵L来保存结果。L[ i ] [ j ] 代表用序号不大于i的物品，背包容量最大为j，所能存储的物品的最大价值。L[ n ] [ c ]就是问题所求的最大值。</p><h3 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h3><script type="math/tex; mode=display">L[i][j]=\begin{cases}0,& \text{i=0 or j=0} \\L[i-1][j],& \text{w[i]>j(第i个物品放不下)}\\\max(L[i-1][j],L[i-1][j-w[i]]+v[i]),&\text{w[i]<=j(放与不放选取价值最大者)} \end{cases}</script><h3 id="主要代码："><a href="#主要代码：" class="headerlink" title="主要代码："></a>主要代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Knapsack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c + <span class="number">1</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">L[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (weight[i - <span class="number">1</span>] &lt;= j)</span><br><span class="line">L[i][j] = <span class="built_in">max</span>(value[i - <span class="number">1</span>] + L[i - <span class="number">1</span>][j - weight[i - <span class="number">1</span>]], L[i - <span class="number">1</span>][j]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">L[i][j] = L[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;max value:&quot;</span>&lt;&lt;L[n][c]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;how to choose:&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">Print(n,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0-1背包 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">int</span> L[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> weight[maxn];</span><br><span class="line"><span class="keyword">int</span> value[maxn];</span><br><span class="line"><span class="keyword">int</span> n,c; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><span class="comment">//输出选择物品的方案 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(L[i][j]==L[i<span class="number">-1</span>][j])</span><br><span class="line">Print(i<span class="number">-1</span>,j);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Print(i<span class="number">-1</span>,j-weight[i]);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No.&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;,weight:&quot;</span>&lt;&lt;weight[i]&lt;&lt;<span class="string">&quot;,value:&quot;</span>&lt;&lt;value[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Knapsack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c + <span class="number">1</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">L[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (weight[i - <span class="number">1</span>] &lt;= j)</span><br><span class="line">L[i][j] = <span class="built_in">max</span>(value[i - <span class="number">1</span>] + L[i - <span class="number">1</span>][j - weight[i - <span class="number">1</span>]], L[i - <span class="number">1</span>][j]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">L[i][j] = L[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;max value:&quot;</span>&lt;&lt;L[n][c]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;how to choose:&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">Print(n,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter number of items: &quot;</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter weights: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; weight[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter values: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; value[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter capacity: &quot;</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">Knapsack();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展1：0-x背包（x为整数）"><a href="#扩展1：0-x背包（x为整数）" class="headerlink" title="扩展1：0-x背包（x为整数）"></a>扩展1：0-x背包（x为整数）</h2><h3 id="问题描述：-1"><a href="#问题描述：-1" class="headerlink" title="问题描述："></a>问题描述：</h3><blockquote><p>与上面0-1背包问题类似，不过每个物品可以放的数量不受限制，从0到x个（只要放得下），通要求所放物品的最大价值。</p></blockquote><h3 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a>算法思路：</h3><blockquote><p>同样是动态规划，同样的算法，只不过递推公式有点不一样。</p></blockquote><h3 id="递归公式："><a href="#递归公式：" class="headerlink" title="递归公式："></a>递归公式：</h3><script type="math/tex; mode=display">L[i][j]=\begin{cases}0,& \text{i=0 or j=0} \\max_{0\leq k \leq \lfloor \frac{j}{weight[i]} \rfloor }(L[i-1][j],L[i-1][j-k*w[i]]+k*v[i]),&\text{others} \end{cases}</script><h3 id="主要代码：-1"><a href="#主要代码：-1" class="headerlink" title="主要代码："></a>主要代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Knapsack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c + <span class="number">1</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">L[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> MAX=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=j/weight[i<span class="number">-1</span>];++k)</span><br><span class="line">MAX=<span class="built_in">max</span>(MAX,L[i<span class="number">-1</span>][j-k*weight[i<span class="number">-1</span>]]+k*value[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L[i][j]=MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;max value:&quot;</span>&lt;&lt;L[n][c]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;how to choose:&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">Print(n,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><span class="comment">//输出选择物品的方案 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;=j/weight[i<span class="number">-1</span>];++k)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(L[i][j]==L[i<span class="number">-1</span>][j-k*weight[i<span class="number">-1</span>]]+k*value[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">Print(i<span class="number">-1</span>,j-k*weight[i<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">if</span>(k!=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No.&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;,how many:&quot;</span>&lt;&lt;k&lt;&lt;<span class="string">&quot;,weight:&quot;</span>&lt;&lt;weight[i<span class="number">-1</span>]&lt;&lt;<span class="string">&quot;,value:&quot;</span>&lt;&lt;value[i<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展2：背包问题"><a href="#扩展2：背包问题" class="headerlink" title="扩展2：背包问题"></a>扩展2：背包问题</h2><h3 id="问题描述：-2"><a href="#问题描述：-2" class="headerlink" title="问题描述："></a>问题描述：</h3><blockquote><p>同样是n个物品，c容量，不过物品可以选择放一部分，用分数k表示（0&lt;=k&lt;=1）,求所有存储物品的最大值。</p></blockquote><h3 id="算法思路：-2"><a href="#算法思路：-2" class="headerlink" title="算法思路："></a>算法思路：</h3><p>贪心法，计算每个物品的value与weight的比值，先把比值高的放完，再放比值次高的，直到背包放满。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求树的高度（不限于二叉树）——动态规划</title>
      <link href="/2020/07/14/tree-height/"/>
      <url>/2020/07/14/tree-height/</url>
      
        <content type="html"><![CDATA[<h1 id="求树的高度（不限于二叉树）——动态规划"><a href="#求树的高度（不限于二叉树）——动态规划" class="headerlink" title="求树的高度（不限于二叉树）——动态规划"></a>求树的高度（不限于二叉树）——动态规划</h1><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>每个节点的高度都是其所有子节点中最大的高度加一。所以，我们可以用动态规划，自底向上求高度。</p><h3 id="递推公式："><a href="#递推公式：" class="headerlink" title="递推公式："></a>递推公式：</h3><script type="math/tex; mode=display">height[u]=max(height[v])+1;(v为所有与u的邻接点)</script><a id="more"></a><h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_depth</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//求以u为根结点的树高</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> child_height=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v:adj[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])<span class="comment">//选取子节点中高度最高的 </span></span><br><span class="line">&#123;</span><br><span class="line">get_depth(v);</span><br><span class="line">child_height=<span class="built_in">max</span>(child_height,dp[v]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[u]=child_height; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划求树高</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>;<span class="comment">//最大节点数 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[MAXN];<span class="comment">//邻接表存树 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_depth</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//求以u为根结点的树高</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> child_height=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v:adj[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])<span class="comment">//选取子节点中高度最高的 </span></span><br><span class="line">&#123;</span><br><span class="line">get_depth(v);</span><br><span class="line">child_height=<span class="built_in">max</span>(child_height,dp[v]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[u]=child_height; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num_of_nodes;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入节点个数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num_of_nodes;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入树边：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num_of_nodes;++i)<span class="comment">//输入num_of_nodes-1条边 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//无向边（u,v） </span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">adj[u].push_back(v);</span><br><span class="line">adj[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化dp和访问标志数组 </span></span><br><span class="line">vis.assign(num_of_nodes+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">dp.assign(num_of_nodes+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">get_depth(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;树高：&quot;</span>&lt;&lt;dp[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共子序列（LCS)</title>
      <link href="/2020/07/14/longest-common-subsquence/"/>
      <url>/2020/07/14/longest-common-subsquence/</url>
      
        <content type="html"><![CDATA[<h1 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h1><p>参考：<a href="https://blog.csdn.net/v_july_v/article/details/6695482#">最长公共子序列（LCS）</a></p><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>  什么是最长公共子序列呢?好比一个数列 S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则S 称为已知序列的最长公共子序列。</p><pre><code>举个例子，如：有两条随机序列，如 1 3 4 5 5 ，and 2 4 5 5 7 6，则它们的最长公共子序列便是：4 5 5。注意最长公共子串（Longest CommonSubstring）和最长公共子序列（LongestCommon Subsequence, LCS）的区别：子串（Substring）是串的一个连续的部分，子序列（Subsequence）则是从不改变序列的顺序，而从序列中去掉任意的元素而获得的新序列；更简略地说，前者（子串）的字符的位置必须连续，后者（子序列LCS）则不必。比如字符串acdfg同akdfc的最长公共子串为df，而他们的最长公共子序列是adf。LCS可以使用动态规划法解决。下文具体描述。</code></pre><a id="more"></a><h3 id="递推公式："><a href="#递推公式：" class="headerlink" title="递推公式："></a>递推公式：</h3><script type="math/tex; mode=display">L(i,j)= \begin{cases} 0, & \text {i=0 or j=0} \\ max(L(i-1,j),L(i,j-1)), & \text{str1[i]}\neq\text{str2[j]} \\L[i-1,j-1]+1, &\text{str1[i]=str2[j]} \end{cases}</script><h3 id="主要代码："><a href="#主要代码：" class="headerlink" title="主要代码："></a>主要代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longest_common_subsquence</span><span class="params">(<span class="built_in">string</span> str1,<span class="built_in">string</span> str2)</span><span class="comment">//最长公共子序列 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=str1.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> c=str2.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">L[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str1[i<span class="number">-1</span>]==str2[j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">direct[i][j]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(L[i<span class="number">-1</span>][j]&gt;L[i][j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i<span class="number">-1</span>][j];</span><br><span class="line">direct[i][j]=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(L[i<span class="number">-1</span>][j]&lt;L[i][j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i][j<span class="number">-1</span>];</span><br><span class="line">direct[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i][j<span class="number">-1</span>];</span><br><span class="line">direct[i][j]=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="string">&quot;和&quot;</span>&lt;&lt;str2&lt;&lt;<span class="string">&quot;最长公共子序列长度：&quot;</span>&lt;&lt;L[r<span class="number">-1</span>][c<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;所有最长公共子序列为：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">get_lcs(r<span class="number">-1</span>,c<span class="number">-1</span>,str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出所有公共子序列 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p:s)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="但是只借助上面这个函数只能得到最优值，为了得到最优解，我们还需要一个direct数组和函数"><a href="#但是只借助上面这个函数只能得到最优值，为了得到最优解，我们还需要一个direct数组和函数" class="headerlink" title="但是只借助上面这个函数只能得到最优值，为了得到最优解，我们还需要一个direct数组和函数"></a>但是只借助上面这个函数只能得到最优值，为了得到最优解，我们还需要一个direct数组和函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_lcs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="built_in">string</span> &amp;str)</span><span class="comment">//根据direct数组得到所有最长公共子序列 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str.<span class="built_in">size</span>()==L[str1.<span class="built_in">size</span>()][str2.<span class="built_in">size</span>()])</span><br><span class="line">s.insert(str);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(direct[i][j]==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">str=str1[i<span class="number">-1</span>]+str;</span><br><span class="line">get_lcs(i<span class="number">-1</span>,j<span class="number">-1</span>,str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(direct[i][j]==<span class="number">1</span>)</span><br><span class="line">get_lcs(i,j<span class="number">-1</span>,str);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(direct[i][j]==<span class="number">3</span>) </span><br><span class="line">get_lcs(i<span class="number">-1</span>,j,str);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span>  s1,s2;</span><br><span class="line">s1=s2=str;</span><br><span class="line">get_lcs(i,j<span class="number">-1</span>,s1);</span><br><span class="line">get_lcs(i<span class="number">-1</span>,j,s2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下面是完整代码："><a href="#下面是完整代码：" class="headerlink" title="下面是完整代码："></a>下面是完整代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">子串（Substring）是串的一个连续的部分</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">子序列（Subsequence）则是从不改变序列的顺序，</span></span><br><span class="line"><span class="comment">而从序列中去掉任意的元素而获得的新序列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>;<span class="comment">//字符串最大长度 </span></span><br><span class="line"><span class="keyword">int</span> L[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> direct[maxn][maxn];<span class="comment">/*direct[i][j]=1代表L[i][j]=L[i][j-1];</span></span><br><span class="line"><span class="comment">direct[i][j]=2代表L[i][j]=L[i-1][j-1]+1;</span></span><br><span class="line"><span class="comment">direct[i][j]=3代表L[i][j]=L[i-1][j];</span></span><br><span class="line"><span class="comment">direct[i][j]=4代表L[i][j]=L[i][j-1]=L[i-1][j];*/</span> </span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s;<span class="comment">//存储所有最长公共子序列 </span></span><br><span class="line"><span class="built_in">string</span> str1,str2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_lcs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="built_in">string</span> &amp;str)</span><span class="comment">//根据direct数组得到所有最长公共子序列 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str.<span class="built_in">size</span>()==L[str1.<span class="built_in">size</span>()][str2.<span class="built_in">size</span>()])</span><br><span class="line">s.insert(str);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(direct[i][j]==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">str=str1[i<span class="number">-1</span>]+str;</span><br><span class="line">get_lcs(i<span class="number">-1</span>,j<span class="number">-1</span>,str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(direct[i][j]==<span class="number">1</span>)</span><br><span class="line">get_lcs(i,j<span class="number">-1</span>,str);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(direct[i][j]==<span class="number">3</span>) </span><br><span class="line">get_lcs(i<span class="number">-1</span>,j,str);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span>  s1,s2;</span><br><span class="line">s1=s2=str;</span><br><span class="line">get_lcs(i,j<span class="number">-1</span>,s1);</span><br><span class="line">get_lcs(i<span class="number">-1</span>,j,s2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longest_common_subsquence</span><span class="params">(<span class="built_in">string</span> str1,<span class="built_in">string</span> str2)</span><span class="comment">//最长公共子序列 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=str1.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> c=str2.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">L[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str1[i<span class="number">-1</span>]==str2[j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">direct[i][j]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(L[i<span class="number">-1</span>][j]&gt;L[i][j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i<span class="number">-1</span>][j];</span><br><span class="line">direct[i][j]=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(L[i<span class="number">-1</span>][j]&lt;L[i][j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i][j<span class="number">-1</span>];</span><br><span class="line">direct[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i][j<span class="number">-1</span>];</span><br><span class="line">direct[i][j]=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="string">&quot;和&quot;</span>&lt;&lt;str2&lt;&lt;<span class="string">&quot;最长公共子序列长度：&quot;</span>&lt;&lt;L[r<span class="number">-1</span>][c<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;所有最长公共子序列为：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">get_lcs(r<span class="number">-1</span>,c<span class="number">-1</span>,str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出所有公共子序列 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p:s)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入字符串st1:&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str1;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入字符串str2:&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str2;</span><br><span class="line"></span><br><span class="line">longest_common_subsquence(str1,str2); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于图的有关算法</title>
      <link href="/2020/05/19/graph/"/>
      <url>/2020/05/19/graph/</url>
      
        <content type="html"><![CDATA[<h1 id="关于图的有关算法"><a href="#关于图的有关算法" class="headerlink" title="关于图的有关算法"></a>关于图的有关算法</h1><blockquote><p>前言：本文所指的图皆以一个全局二维数组存储，即邻接矩阵，且为<code>有向带权图</code><br>    设int G[maxn][maxn]为邻接矩阵，其中maxn为图能存储的最大顶点数<br>    <code>n：顶点数</code><br>    <code>m：边数</code><br>    <code>借助于一个全局数组visited[maxn]标记顶点是否已经访问</code></p></blockquote><a id="more"></a><h2 id="本文对顶点的访问操作"><a href="#本文对顶点的访问操作" class="headerlink" title="本文对顶点的访问操作"></a>本文对顶点的访问操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问顶点，为了方便简单的输出 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">visited[n]=<span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="图的输入"><a href="#图的输入" class="headerlink" title="图的输入"></a>图的输入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入图 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入图的顶点数和边数</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依次为边的起点，终点，边长</span></span><br><span class="line"><span class="keyword">int</span> start,<span class="built_in">end</span>,len;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依次输入m条边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;start&gt;&gt;<span class="built_in">end</span>&gt;&gt;len;</span><br><span class="line">G[start][<span class="built_in">end</span>]=len;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若为无向图加上下面一句，因为无向图的对称性</span></span><br><span class="line"><span class="comment">//G[end][start]=len; </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常见的算法"><a href="#常见的算法" class="headerlink" title="常见的算法"></a>常见的算法</h1><h2 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以顶点start为起点，广度优先搜索 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(start);</span><br><span class="line">visit(start);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=q.front();q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[i]&amp;&amp;G[t][i]!=INF)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">visit(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以start顶点为起点，深度优先搜索 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visit(start);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[i]&amp;&amp;G[start][i]!=INF)</span><br><span class="line">&#123;</span><br><span class="line">DFS(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑遍历"><a href="#拓扑遍历" class="headerlink" title="拓扑遍历"></a>拓扑遍历</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓扑搜索</span></span><br><span class="line"><span class="built_in">void</span> Topo()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//统计已经访问的顶点</span></span><br><span class="line"><span class="built_in">int</span> num=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">queue&lt;<span class="built_in">int</span>&gt; q; </span><br><span class="line"></span><br><span class="line"><span class="comment">//各个顶点的入度数 </span></span><br><span class="line"><span class="built_in">int</span> index[maxn]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计各个顶点的入度数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(G[i][j]!=INF)</span><br><span class="line">&#123;</span><br><span class="line">++index[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//入度数为0，放入队列 </span></span><br><span class="line"><span class="keyword">if</span>(index[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> t=q.front();q.pop();</span><br><span class="line"></span><br><span class="line">visit(t);++num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(G[t][i]!=INF&amp;&amp;index[i]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//删除边t-&gt;i</span></span><br><span class="line">--index[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//若i入度为0，将i置于队列中</span></span><br><span class="line"><span class="keyword">if</span>(index[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="最小生成树（Prim）"><a href="#最小生成树（Prim）" class="headerlink" title="最小生成树（Prim）"></a>最小生成树（Prim）</h2><blockquote><p>算法思想：贪心法<br>设图的顶点集为V，已组成连通图的顶点集为X，通过一系列放缩直到<br>当X==V时，算法结束，或者当X！=V时，仍然存在dist【i】==INF，即顶点i无法连接到X，同样结束算法，此时图为非连通图<br>算法中三个数组的作用<br>vis【i】:标志顶点i是否在X中，1：是 0：否<br>prev【i】：X中离顶点i最近的顶点，其中prev【0】=-1（因为初始时，X={0}）<br>dist【i】：顶点i连接prev【i】的最短距离 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//最小生成树的耗费 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> prev[maxn];</span><br><span class="line"><span class="keyword">int</span> dist[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化三个数组 </span></span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(prev,<span class="number">-1</span>,<span class="keyword">sizeof</span>(prev));</span><br><span class="line"><span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(G[<span class="number">0</span>][i]!=INF)</span><br><span class="line">&#123;</span><br><span class="line">prev[i]=<span class="number">0</span>;</span><br><span class="line">dist[i]=G[<span class="number">0</span>][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prev[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">vis[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行n-1轮放缩，因为顶点0一开始就加入到X了 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t=INF,u=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找V-X中的一点u，其中dist【u】最小， </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j]&amp;&amp;dist[j]&lt;t)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">t=dist[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若无法找到上述u点，即V-X中的所有dist【i】都为INF，提前结束算法，返回-1代表该图不是连通图 </span></span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将u加入到X </span></span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line">ans+=dist[u];</span><br><span class="line"></span><br><span class="line"><span class="comment">//对每个和顶点u邻接的顶点j </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果j不属于X且边（u，j）小于dist【j】，更新dist【j】 </span></span><br><span class="line"><span class="keyword">if</span>(!vis[j]&amp;&amp;G[u][j]&lt;dist[j])</span><br><span class="line">&#123;</span><br><span class="line">dist[j]=G[u][j];</span><br><span class="line">prev[j]=u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回最小生成树的耗费 </span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路径（Dijkstra）"><a href="#最短路径（Dijkstra）" class="headerlink" title="最短路径（Dijkstra）"></a>最短路径（Dijkstra）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traceback</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> prev[],<span class="keyword">int</span> dist[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==start)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t=i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">t=prev[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;distance:&quot;</span>&lt;&lt;dist[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> prev[maxn];</span><br><span class="line"><span class="keyword">int</span> dist[maxn];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(prev,<span class="number">-1</span>,<span class="keyword">sizeof</span>(prev));</span><br><span class="line"><span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(G[start][i]!=INF)</span><br><span class="line">&#123;</span><br><span class="line">dist[i]=G[start][i];</span><br><span class="line">prev[i]=start;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prev[start]=<span class="number">-1</span>;</span><br><span class="line">dist[start]=<span class="number">0</span>;</span><br><span class="line">vis[start]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==start)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t=INF,u=start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j]&amp;&amp;dist[j]&lt;t)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">t=dist[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j]&amp;&amp;G[u][j]+dist[u]&lt;dist[j])</span><br><span class="line">&#123;</span><br><span class="line">dist[j]=G[u][j]+dist[u];</span><br><span class="line">prev[j]=u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">traceback(start,prev,dist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡二叉树</title>
      <link href="/2020/05/19/AVL/"/>
      <url>/2020/05/19/AVL/</url>
      
        <content type="html"><![CDATA[<h1 id="AVL-平衡二叉树"><a href="#AVL-平衡二叉树" class="headerlink" title="AVL(平衡二叉树)"></a>AVL(平衡二叉树)</h1><blockquote><p>AVL树的定义<br>平衡因子 : 树中某结点其左子树的高度和右子树的高度之差<br>AVL树中的任意一个结点, 其平衡因子的绝对值小于2<br>AVL树是一种特殊的二叉搜索树 (BST树), 相对于数据极端情况下, 二叉搜索树会退化成为单链表,<br> AVL树定义了旋转操作, 在平衡因子大于等于2时, AVL树会旋转来调整树的结构, 来重新满足平衡因子小于2<br><a id="more"></a></p><h2 id="单右旋"><a href="#单右旋" class="headerlink" title="单右旋"></a>单右旋</h2><p>若初始A的平衡因子为1，左子树的平衡因子为0，此时插入若导致A左子树的左子树变高，此时就需要单右旋，通过单右旋会使这棵树重新平衡，平衡后的树高度会恢复为原来的高度。<br><img src="/2020/05/19/AVL/RR.jpg" alt="RR"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入右子树的右子树（RR）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RR</span><span class="params">(TreeNode *&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">TreeNode *temp=t-&gt;right;</span><br><span class="line">t-&gt;right=temp-&gt;left;</span><br><span class="line">temp-&gt;left=t;</span><br><span class="line">t=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="单左旋"><a href="#单左旋" class="headerlink" title="单左旋"></a>单左旋</h2><blockquote><p>若初始A的平衡因子为-1，A的右子树平衡因子为0，若此时插入导致A的右子树的右子树高度增加，此时就需要单左旋。旋转之后A的高度恢复为原来的高度。<br><img src="/2020/05/19/AVL/LL.jpg" alt="LL"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//插入左子树的左子树（LL）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LL</span><span class="params">(TreeNode *&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">TreeNode *temp=t-&gt;left;</span><br><span class="line">t-&gt;left=temp-&gt;right;</span><br><span class="line">temp-&gt;right=t;</span><br><span class="line">t=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="先左后右旋转"><a href="#先左后右旋转" class="headerlink" title="先左后右旋转"></a>先左后右旋转</h2><blockquote><p>若初始A的平衡因子为1，左子树的平衡因子为0，此时插入若导致A左子树的右子树变高，此时就需要先左后右双旋转，通过双旋转会使这棵树重新平衡，平衡后的树高度会恢复为原来的高度。<br><img src="/2020/05/19/AVL/LR.jpg" alt="LR"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入左子树的右子树（LR）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LR</span><span class="params">(TreeNode *&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">RR(t-&gt;left);</span><br><span class="line">LL(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p><h2 id="先右后左双旋转"><a href="#先右后左双旋转" class="headerlink" title="先右后左双旋转"></a>先右后左双旋转</h2><p>若初始A的平衡因子为-1，A的右子树平衡因子为0，若此时插入导致A的右子树的左子树高度增加，此时就需要做先右后左旋转。旋转之后A的高度恢复为原来的高度。<br><img src="/2020/05/19/AVL/RL.jpg" alt="RL"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入右子树的左子树（RL）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RL</span><span class="params">(TreeNode *&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">LL(t-&gt;right);</span><br><span class="line">RR(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p></blockquote><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树的删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_AVL</span><span class="params">(TreeNode *&amp;root,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x&gt;root-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">delete_AVL(root-&gt;right,x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否失衡,删了右子树一个结点,所以判断左子树高度是否过高</span></span><br><span class="line"><span class="keyword">if</span>(getHeight(root-&gt;left)-getHeight(root-&gt;right))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(getHeight(root-&gt;left-&gt;right)&lt;getHeight(root-&gt;left-&gt;left))</span><br><span class="line">LL(root);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LR(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">delete_AVL(root-&gt;left,x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> leftHeight=getHeight(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> rightHeight=getHeight(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否失衡,删了左子树一个结点,所以判断右子树高度是否过高</span></span><br><span class="line"><span class="keyword">if</span>(rightHeight-leftHeight&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(getHeight(root-&gt;right-&gt;left)&gt;getHeight(root-&gt;right-&gt;right))</span><br><span class="line">RL(root);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">RR(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x==root-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//删除左右子树都为空 </span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line">root=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点的左子树为空，右子树不为空 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>) </span><br><span class="line">root=root-&gt;right;</span><br><span class="line"><span class="comment">//删除结点的左子树不为空，右子树为空</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">root=root-&gt;left;</span><br><span class="line"><span class="comment">//删除结点左右子树都不为空</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TreeNode *prev=root;</span><br><span class="line">TreeNode *t=root-&gt;left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">prev=t;</span><br><span class="line">t=t-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(prev!=root)</span><br><span class="line">&#123;</span><br><span class="line">TreeNode *delete_node=prev-&gt;right;</span><br><span class="line">root-&gt;val=t-&gt;val;</span><br><span class="line">prev-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> delete_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TreeNode *delete_node=root;</span><br><span class="line">root=t;</span><br><span class="line">root-&gt;right=prev-&gt;right;</span><br><span class="line"><span class="keyword">delete</span> delete_node;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树的插入 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_AVL</span><span class="params">(TreeNode *&amp;root,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">root=<span class="keyword">new</span> TreeNode(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x&gt;root-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">insert_AVL(root-&gt;right,x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> leftHeight=getHeight(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> rightHeight=getHeight(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果右节点与左节点高度的差大于1，root失衡 </span></span><br><span class="line"><span class="keyword">if</span>(rightHeight-leftHeight&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;root-&gt;right-&gt;val)</span><br><span class="line">RR(root);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">RL(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">insert_AVL(root-&gt;left,x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> leftHeight=getHeight(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> rightHeight=getHeight(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果左节点与右节点高度的差大于1，root失衡 </span></span><br><span class="line"><span class="keyword">if</span>(leftHeight-rightHeight&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;root-&gt;left-&gt;val)</span><br><span class="line">LL(root);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LR(root); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BST</title>
      <link href="/2020/05/19/BST/"/>
      <url>/2020/05/19/BST/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树搜索树"><a href="#二叉树搜索树" class="headerlink" title="二叉树搜索树"></a>二叉树搜索树</h1><p>即BST：binary searching tree 或者 binary sort tree</p><h2 id="树结点定义"><a href="#树结点定义" class="headerlink" title="树结点定义"></a>树结点定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">TreeNode *left,*right;</span><br><span class="line"></span><br><span class="line">TreeNode(<span class="keyword">int</span> x):val(x),left(<span class="literal">NULL</span>),right(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索二叉树的插入 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_BST</span><span class="params">(TreeNode *&amp;root,<span class="keyword">int</span> x)</span><span class="comment">//引用很重要，不能去掉 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//插入当前结点 </span></span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">root=<span class="keyword">new</span> TreeNode(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//插入的值比当前结点的值大，递归调用插入当前结点的右子树 </span></span><br><span class="line"><span class="keyword">if</span>(x&gt;root-&gt;val)insert_BST(root-&gt;right,x);</span><br><span class="line"><span class="comment">//插入的值比当前结点的值小，递归调用插入当前结点的左子树</span></span><br><span class="line"><span class="keyword">if</span>(x&lt;root-&gt;val)insert_BST(root-&gt;left,x);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索二叉树的删除 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_BST</span><span class="params">(TreeNode *&amp;root,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//删除的值比当前结点的值大，递归调用插入当前结点的右子树  </span></span><br><span class="line"><span class="keyword">if</span>(x&gt;root-&gt;val)delete_BST(root-&gt;right,x); </span><br><span class="line"><span class="comment">//删除的值比当前结点的值小，递归调用插入当前结点的左子树</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;val)delete_BST(root-&gt;left,x);</span><br><span class="line"><span class="comment">//删除的值等于当前的结点</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TreeNode *delete_node=root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点左右子树都为空 ，将当前结点置空 </span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">root=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点左子树为空，右子树不为空</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">root=root-&gt;right;</span><br><span class="line"><span class="comment">//删除结点 </span></span><br><span class="line"><span class="keyword">delete</span> delete_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点左子树不为空，右子树为空</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">root=root-&gt;left;</span><br><span class="line"><span class="comment">//删除结点 </span></span><br><span class="line"><span class="keyword">delete</span> delete_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点左右都不为空</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TreeNode *prev=root;</span><br><span class="line">TreeNode *t=root-&gt;left;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到左子树中最大的结点 </span></span><br><span class="line"><span class="keyword">while</span>(t-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">prev=t; </span><br><span class="line">t=t-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">swap(t-&gt;val,root-&gt;val);</span><br><span class="line">delete_BST(root-&gt;left,root-&gt;val);</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否为BST"><a href="#判断是否为BST" class="headerlink" title="判断是否为BST"></a>判断是否为BST</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_BST</span><span class="params">(TreeNode *root,<span class="keyword">long</span> <span class="keyword">long</span> <span class="built_in">min</span>,<span class="keyword">long</span> <span class="keyword">long</span> <span class="built_in">max</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)<span class="comment">//当前结点为空结点 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(root-&gt;val&lt;=<span class="built_in">min</span>||root-&gt;val&gt;=<span class="built_in">max</span>)<span class="comment">//当前结点不在范围内 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归调用1 </span></span><br><span class="line"><span class="keyword">return</span> is_BST(root-&gt;left,<span class="built_in">min</span>,root-&gt;val)&amp;&amp;is_BST(root-&gt;right,root-&gt;val,<span class="built_in">max</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/2020/05/19/travel-binaryTree/"/>
      <url>/2020/05/19/travel-binaryTree/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><blockquote><p>前言：本文将所有对节点的访问操作简化为简单的输出</p></blockquote><a id="more"></a><h2 id="树结点定义"><a href="#树结点定义" class="headerlink" title="树结点定义"></a>树结点定义</h2><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct TreeNode</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> val;</span><br><span class="line"></span><br><span class="line">TreeNode *<span class="built_in">left</span>,*<span class="built_in">right</span>;</span><br><span class="line"></span><br><span class="line">TreeNode(<span class="built_in">int</span> x):val(x),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="前序遍历-（根-左-右）"><a href="#前序遍历-（根-左-右）" class="headerlink" title="[前序遍历]（根-左-右）"></a>[前序遍历]（根-左-右）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历（递归）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_recursion</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//访问结点 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">pre_order_recursion(root-&gt;left);</span><br><span class="line"></span><br><span class="line">pre_order_recursion(root-&gt;right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历（迭代） </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_iteration</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//空树 </span></span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line"></span><br><span class="line">TreeNode *t=root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t||!s.empty())</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">s.push(t);</span><br><span class="line"></span><br><span class="line">t=t-&gt;left; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t=s.top();s.pop();t=t-&gt;right; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历-（左-根-右）"><a href="#中序遍历-（左-根-右）" class="headerlink" title="[中序遍历]（左-根-右）"></a>[中序遍历]（左-根-右）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历（递归）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_recursion</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root)</span><br><span class="line">&#123;</span><br><span class="line">in_order_recursion(root-&gt;left);</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">in_order_recursion(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历（迭代）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_iteration</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//空树 </span></span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">TreeNode *t=root;</span><br><span class="line"><span class="keyword">while</span>(!s.empty()||t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(t)</span><br><span class="line">&#123;</span><br><span class="line">s.push(t);</span><br><span class="line">t=t-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">t=s.top();s.pop();<span class="built_in">cout</span>&lt;&lt;t-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">t=t-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历-（左-右-根）"><a href="#后序遍历-（左-右-根）" class="headerlink" title="[后序遍历]（左-右-根）"></a>[后序遍历]（左-右-根）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历（递归）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">last_order_recursion</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root)</span><br><span class="line">&#123;</span><br><span class="line">last_order_recursion(root-&gt;left);</span><br><span class="line"></span><br><span class="line">last_order_recursion(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历（迭代） </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 后续遍历关键在于，当节点的  右子树存在且被访问后  或者是  右子树为空  才能访问自身。</span></span><br><span class="line"><span class="comment"> 在遍历过程中，先将节点从的左孩子到最左节点压栈， 设置标志变量 flag 来判断是否访问过左孩子， pre指针来指向先前访问过的节点。</span></span><br><span class="line"><span class="comment"> 所有左孩子压栈后， 最后一个节点的左孩子为空，已被访问p = NULL ， 令flag=1</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 当左孩子被访问时，进入循环，取栈顶节点。</span></span><br><span class="line"><span class="comment"> 1. 当栈顶节点的右孩子 等于 空  或  前一个被访问的节点  时， 访问该节点， 令pre 等于当前节点，pre = p， 当前节点出栈。</span></span><br><span class="line"><span class="comment"> 2. 当栈顶节点的右孩子不为空时， 继续遍历以右孩子为根节点的右子树。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">last_order_iteration</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//空树 </span></span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">TreeNode *pre=<span class="literal">NULL</span>,*p=root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.push(p);</span><br><span class="line">p=p-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!s.empty()&amp;&amp;flag==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">p=s.top();</span><br><span class="line"></span><br><span class="line"><span class="comment">//当栈中结点的右结点访问了或者为空时，访问结点 </span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;right==<span class="literal">NULL</span>||p-&gt;right==pre)</span><br><span class="line">&#123;</span><br><span class="line">s.pop();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">pre=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则访问当前结点的右子树 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;right;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(!s.empty()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="[层次遍历]"></a>[层次遍历]</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">level_order</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//空树</span></span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line"></span><br><span class="line">q.push(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">TreeNode *t=q.front();q.pop();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆的相关算法</title>
      <link href="/2020/05/19/heap/"/>
      <url>/2020/05/19/heap/</url>
      
        <content type="html"><![CDATA[<h1 id="堆的存储结构"><a href="#堆的存储结构" class="headerlink" title="堆的存储结构"></a>堆的存储结构</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Heap(<span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">10</span>);</span><br><span class="line">~Heap();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift_down</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift_up</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">int</span> *heap;<span class="comment">//用于存放数据，索引从1开始到size</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;<span class="comment">//堆的大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*无关紧要的函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 </span></span><br><span class="line">Heap::Heap(<span class="keyword">int</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">heap=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*<span class="built_in">size</span>];</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">size</span>=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数 </span></span><br><span class="line">Heap::~Heap()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> [] heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示heap数组 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Heap:&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">size</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;heap[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="堆的相关算法"><a href="#堆的相关算法" class="headerlink" title="堆的相关算法"></a>堆的相关算法</h1><h2 id="上溯"><a href="#上溯" class="headerlink" title="上溯"></a>上溯</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从第i个点下沉 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::sift_up</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> done=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i!=<span class="number">1</span>&amp;&amp;done==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果i的父节点比i大，交换，否则sift_up完成 </span></span><br><span class="line"><span class="keyword">if</span>(heap[i/<span class="number">2</span>]&gt;heap[i])</span><br><span class="line">swap(heap[i/<span class="number">2</span>],heap[i]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">done=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向上迭代 </span></span><br><span class="line">i=i/<span class="number">2</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下沉"><a href="#下沉" class="headerlink" title="下沉"></a>下沉</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从第i个点上溯 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::sift_down</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> done=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(done==<span class="literal">false</span>&amp;&amp;<span class="number">2</span>*i&lt;=<span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//向下迭代 </span></span><br><span class="line">i=<span class="number">2</span>*i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选i子节点中最小的节点 </span></span><br><span class="line"><span class="keyword">if</span>(i+<span class="number">1</span>&lt;=<span class="built_in">size</span>&amp;&amp;heap[i+<span class="number">1</span>]&lt;heap[i])</span><br><span class="line">i=i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果i比其子节点的最大值还大，交换节点，否则完成sift_down </span></span><br><span class="line"><span class="keyword">if</span>(heap[i/<span class="number">2</span>]&gt;heap[i])</span><br><span class="line">swap(heap[i/<span class="number">2</span>],heap[i]); </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">done=<span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">++<span class="built_in">size</span>;</span><br><span class="line">heap[<span class="built_in">size</span>]=x;</span><br><span class="line">sift_up(<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除第i个点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::Delete</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=heap[i],y=heap[<span class="built_in">size</span>];</span><br><span class="line"></span><br><span class="line">--<span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">heap[i]=y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(y&lt;x)</span><br><span class="line">sift_up(i);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sift_down(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote><p>因为heap[1]是最小的，所以swap(heap[1],heap[size])可以将最小的元素放到数组最后，然后sift_down(1)对heap[1…size-1]维持最小堆，直到size为1<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将heap按降序排序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::heapsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Size=<span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">size</span>!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">swap(heap[<span class="number">1</span>],heap[<span class="built_in">size</span>]);</span><br><span class="line">--<span class="built_in">size</span>;</span><br><span class="line">sift_down(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>=Size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于测试 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Heap h;</span><br><span class="line"><span class="keyword">int</span> op;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;1:insert 2:delete 3:heapsort 4:quit&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;op&amp;&amp;op!=<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;the element you want to insert:&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">h.Insert(x);</span><br><span class="line">h.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;the index of the elemnet you want to delete:&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">h.Delete(x);</span><br><span class="line">h.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">h.heapsort();</span><br><span class="line">h.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统概念</title>
      <link href="/2020/04/29/concept-of-database/"/>
      <url>/2020/04/29/concept-of-database/</url>
      
        <content type="html"><![CDATA[<h1 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h1><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><blockquote><p>设R（U）是属性U上的一个关系模式，X和Y均为U={A1，A2，…，An}的子集，r为R的任一关系，<br>如果对于r中的任意两个元组u，v，只要有u[X]=v[X]，就有u[Y]=v[Y]，<br>则称X函数决定Y，或称Y函数依赖于X，记为X→Y<br><a id="more"></a><br><strong>例如：</strong><br><em>(sno-学生ID，tno-教师ID，cno-课程ID，sname-学生姓名，tname-教师姓名，cname-课程名称,grade-成绩）</em><br>1、sno→sname, cno→cname,(sno,cno)→grade √<br>2、sname→sno, tno→cno, sno→tname ×</p></blockquote><h2 id="函数依赖分为完全函数依赖和部分函数依赖"><a href="#函数依赖分为完全函数依赖和部分函数依赖" class="headerlink" title="函数依赖分为完全函数依赖和部分函数依赖"></a>函数依赖分为完全函数依赖和部分函数依赖</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><blockquote><p> 在R(U)中，如果X→Y，并且对于X的任何真子集X’都有X’Y’，则称Y完全依赖于X，记作X→Y；否则，如果X→Y，且X中存在一个真子集X’，使得X’→Y成立，则称Y部分依赖于X。</p></blockquote><p><strong>例如：</strong><br><code>学生ID，学生姓名，所修课程ID，课程名称成绩</code><br>（学生ID，所修课程ID）→成绩 <br>成绩不能单独依赖与学生ID，也不能单独依赖于课程ID，因此成绩完全函数依赖于关键字。<br>（学生ID，所修课程ID）→学生姓名<br>学生姓名能单独依赖于关键字的一个属性学生ID，因此学生姓名部分函数依赖于（学生ID，所修课程ID）</p><h2 id="平凡函数依赖和非平凡函数依赖"><a href="#平凡函数依赖和非平凡函数依赖" class="headerlink" title="平凡函数依赖和非平凡函数依赖"></a>平凡函数依赖和非平凡函数依赖</h2><p>设X，Y均为某关系上的属性集，且X→Y</p><ol><li>Y是X的子集，则称X→Y为：平凡函数依赖</li><li>Y不是X的子集，则称X→Y为：非平凡函数依赖</li></ol><h1 id="六个范式"><a href="#六个范式" class="headerlink" title="六个范式"></a>六个范式</h1><h2 id="一些基础概念"><a href="#一些基础概念" class="headerlink" title="一些基础概念"></a>一些基础概念</h2><blockquote><ul><li><p><strong>超码（superkey）</strong>：是一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地标识一个元组。</p></li><li><p><strong>候选码（candidate key）</strong>：超码中可能包含无关紧要的属性。当一些超码的任意真子集不能成为超码，我们称这些最小超码为<code>候选码</code>。</p></li><li><p><strong>主码（primary key）</strong>：被我们选中的主要用来在一个关系中区分不同元组的候选码</p></li><li><p><strong>外码（foreign key）</strong>：一个关系模式（r1）可能在它的属性中包括另一个关系模式（r2）的<code>主码</code>。这个属性在r1上称作参照r2的<code>外码</code>。关系r1也称为外码依赖的<code>参照关系（referencing relation）</code>，r2叫做外码的<code>被参照关系（referenced relation）</code></p></li></ul></blockquote><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="第一范式（1NF）：关系模式中所有属性都是不可分的。"><a href="#第一范式（1NF）：关系模式中所有属性都是不可分的。" class="headerlink" title="第一范式（1NF）：关系模式中所有属性都是不可分的。"></a>第一范式（1NF）：<strong>关系模式中<code>所有属性</code>都是<code>不可分的</code>。</strong></h3><h3 id="第二范式（2NF）：符合1NF，并且每一个非主属性完全依赖于候选码。"><a href="#第二范式（2NF）：符合1NF，并且每一个非主属性完全依赖于候选码。" class="headerlink" title="第二范式（2NF）：符合1NF，并且每一个非主属性完全依赖于候选码。"></a>第二范式（2NF）：<strong>符合1NF，并且<code>每一个非主</code>属性<code>完全</code>依赖于候选码</strong>。</h3><h3 id="第三范式（3NF）：符合2NF，且消除依赖传递。"><a href="#第三范式（3NF）：符合2NF，且消除依赖传递。" class="headerlink" title="第三范式（3NF）：符合2NF，且消除依赖传递。"></a>第三范式（3NF）：<strong>符合2NF，且消除依赖传递。</strong></h3><blockquote><p>若R∈3NF，则R的每一个非主属性既不部分函数依赖于候选码也不传递函数依赖于候选码。——若R∈3NF，则R的每一个<code>非主属性</code>既不部分函数依赖于候选码也不传递函数依赖于候选码。</p></blockquote><h3 id="BC范式（BCNF）：符合3NF，且主属性不依赖于主属性。"><a href="#BC范式（BCNF）：符合3NF，且主属性不依赖于主属性。" class="headerlink" title="BC范式（BCNF）：符合3NF，且主属性不依赖于主属性。"></a>BC范式（BCNF）：符合3NF，且主属性不依赖于主属性。</h3><blockquote><p>设关系模式R<U，F>∈1NF，如果对于R的每个函数依赖X→Y，若Y不属于X，则X必含有候选码，那么R∈BCNF。</U，F></p></blockquote><p>若R∈BCNF </p><blockquote><ul><li>每一个决定属性集（因素）都包含（候选）码</li><li>R中的所有属性（主，非主属性）都完全函数依赖于码</li><li>R∈3NF</li></ul></blockquote><h3 id="第四范式（4NF）：要求把同一表内多对多的关系删除"><a href="#第四范式（4NF）：要求把同一表内多对多的关系删除" class="headerlink" title="第四范式（4NF）：要求把同一表内多对多的关系删除"></a>第四范式（4NF）：<strong>要求把同一表内多对多的关系删除</strong></h3><h3 id="第五范式（5NF）：从最终结构重新建立原始结构"><a href="#第五范式（5NF）：从最终结构重新建立原始结构" class="headerlink" title="第五范式（5NF）：从最终结构重新建立原始结构"></a>第五范式（5NF）：<strong>从最终结构重新建立原始结构</strong></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大基础排序</title>
      <link href="/2020/04/26/sort/"/>
      <url>/2020/04/26/sort/</url>
      
        <content type="html"><![CDATA[<h1 id="八大基础排序"><a href="#八大基础排序" class="headerlink" title="八大基础排序"></a>八大基础排序</h1><p>[TOC]</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>思路：俩俩交换，大的放在后面，第一次排序后最大值已在数组末尾。因为俩俩交换，需要<code>n-1</code>趟排序（比如10个数，需要9趟排序）</strong></p><p><strong>代码实现要点：两个for循环，外层循环控制排序的趟数，内层循环控制比较的次数。每趟过后，比较的次数都应该要减1</strong><br><a id="more"></a><br>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//记录是否发生了置换，0表示没有发生置换，反之为1</span></span><br><span class="line"><span class="keyword">int</span> ischange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每次比较一趟就重新初始化为0</span></span><br><span class="line">isChange=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a.<span class="built_in">size</span>()-i<span class="number">-1</span>;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//前一位与后一位比较，如果前一位比后一位大，就交换</span></span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">swap(a[j],a[j+<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//标志发生置换</span></span><br><span class="line">isChange=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//这趟比较没有置换，说明数组已经排好序，不需要在执行下去 </span></span><br><span class="line"><span class="keyword">if</span>(isChange==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>思路：找到数组中最大的元素，与数组最后一位元素交换。当只有一个数时，则不需要选择了，因此需要<code>n-1</code>趟排序</strong></p><p><strong>代码实现要点：两个for循环，外层循环控制排序的趟数，内层循环找到当前趟数的最大值，随后与当前趟数组最后的一位元素交换</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//记录当前趟最大数的坐标 </span></span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>()<span class="number">-1</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每次比较一趟就重新初始化为0</span></span><br><span class="line">pos=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内层循环找到当前趟的最大值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a.<span class="built_in">size</span>()-i;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;a[pos])</span><br><span class="line">&#123;</span><br><span class="line">pos=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果最大值坐标不在当前位置，交换 </span></span><br><span class="line">swap(a[pos],a[a.<span class="built_in">size</span>()-i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>思路：将一个元素插入到已有序的数组中，在初始时未知是否存在有序的数据，因此将元素第一个元素看成是有序的。与有序的数组进行比较，比它大则直接放入，比它小则移动数组元素的位置，找到个合适的位置插入。当只有一个数时，则不需要插入了，因此需要<code>n-1</code>趟排序</strong></p><p><strong>代码实现：一个for循环内嵌一个while循环实现，外层for循环控制需要排序的趟数，while循环找到合适的插入位置(并且插入的位置不能小于0)</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//临时变量 </span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.<span class="built_in">size</span>();++i)</span><br><span class="line">&#123;</span><br><span class="line">temp=a[i]; </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果前一位比当前数据大，就进入while循环进行移动 </span></span><br><span class="line"><span class="keyword">int</span> j=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;a[j]&gt;temp)</span><br><span class="line">&#123;</span><br><span class="line">a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">--j;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//退出循环时，插入位置为j+1(因为a[j]&lt;=temp)</span></span><br><span class="line">a[j+<span class="number">1</span>]=temp; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>思路：在数组中找一个元素(节点)，比它小的放在节点的左边，比它大的放在节点右边。一趟下来，比节点小的在左边，比节点大的在右边。不断执行这个操作….</strong></p><p><strong>代码实现：支点取中间，使用L和R表示数组的最小和最大位置。不断进行比较，直到找到比支点小(大)的数，随后交换，不断减小范围。递归L到支点前一个元素(j)。递归支点后一个元素(i)到R元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//L指向数组当前区间的第一个元素，R为最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//临时变量，用来当划分数组的界点 </span></span><br><span class="line"><span class="keyword">int</span> temp=a[L];</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(j=L+<span class="number">1</span>;j&lt;=R;++j)<span class="comment">//将所有小于等于a[i]的放在数组左边，大于的放在数组右边</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;=temp)</span><br><span class="line">&#123;</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span>(i!=j)</span><br><span class="line">swap(a[i],a[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(a[L],a[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//当前范围无需再排序 </span></span><br><span class="line"><span class="keyword">if</span>(L&gt;=R)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数组划分 </span></span><br><span class="line"><span class="keyword">int</span> w=split(a,L,R); </span><br><span class="line"></span><br><span class="line"><span class="comment">//递归调用，将a[i]两边排序 </span></span><br><span class="line">quick_sort(a,L,w<span class="number">-1</span>); </span><br><span class="line">quick_sort(a,w+<span class="number">1</span>,R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>思路：将两个已排好序的数组合并成一个有序的数组。将元素分隔开来，看成是有序的数组，进行比较合并。不断拆分和合并，直到只有一个元素</strong></p><p><strong>代码实现：在第一趟排序时实质是两个元素(看成是两个已有序的数组)来进行合并，不断执行这样的操作，最终数组有序，拆分左边，右边，合并…</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(mid-L)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(R-mid+<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往两个数组填充数据 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L;i&lt;mid;++i)</span><br><span class="line">v1[i-L]=a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=mid;i&lt;=R;++i)</span><br><span class="line">v2[i-mid]=a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a数组的第一个元素 </span></span><br><span class="line"><span class="keyword">int</span> K=L;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并数组 </span></span><br><span class="line"><span class="keyword">while</span>(i&lt;v1.<span class="built_in">size</span>()&amp;&amp;j&lt;v2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(v1[i]&lt;v2[i])</span><br><span class="line">a[k++]=v1[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">a[k++]=v2[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;v1.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">a[k++]=v1[i++];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(j&lt;v2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">a[k++]=v2[j++];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//当前范围无需再排序 </span></span><br><span class="line"><span class="keyword">if</span>(L&gt;=R)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取中间的数进行拆分 </span></span><br><span class="line"><span class="keyword">int</span> mid=(L+R)/<span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//将左右数组不断拆分 </span></span><br><span class="line">merge_sort(a,L,mid<span class="number">-1</span>); </span><br><span class="line">merge_sort(a,mid,R);</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并左右数组 </span></span><br><span class="line">merge(a,L,mid,R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>思路：堆排序使用到了完全二叉树的一个特性，根节点比左孩子和右孩子都要大，完成一次建堆的操作实质上是比较根节点和左孩子、右孩子的大小，大的交换到根节点上，直至最大的节点在树顶。随后与数组最后一位元素进行交换</strong></p><p><strong>代码实现：只要左子树或右子树大于当前根节点，则替换。替换后会导致下面的子树发生了变化，因此同样需要进行比较，直至各个节点实现父&gt;子这么一个条件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift_down</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> cur,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cur&lt;<span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当前结点左右子树的位置</span></span><br><span class="line"><span class="keyword">int</span> left=<span class="number">2</span>*cur+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right=<span class="number">2</span>*cur+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把当前结点位置看成是最大的 </span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span>=cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(left&lt;<span class="built_in">size</span>&amp;&amp;a[<span class="built_in">max</span>]&lt;a[left])</span><br><span class="line"><span class="built_in">max</span>=left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(right&lt;<span class="built_in">size</span>&amp;&amp;a[<span class="built_in">max</span>]&lt;a[right])</span><br><span class="line"><span class="built_in">max</span>=right;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果最大的不是cur，就交换</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">max</span>!=cur)</span><br><span class="line">&#123;</span><br><span class="line">swap(a[<span class="built_in">max</span>],a[cur]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续比较，直到完成一次建堆 </span></span><br><span class="line">sift_down(a,<span class="built_in">max</span>,<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//完成一次建堆 </span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>=a.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=(<span class="built_in">size</span><span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i)<span class="comment">//从最后一个非叶子结点建堆 </span></span><br><span class="line">sift_down(a,i,<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="built_in">size</span><span class="number">-1</span>;j&gt;<span class="number">0</span>;--j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//a[0]为最大值，与最后一个元素交换，缩小调整范围 </span></span><br><span class="line">swap(a[<span class="number">0</span>],a[j]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整位置 </span></span><br><span class="line">sift_down(a,<span class="number">0</span>,j);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><strong>思路：希尔排序实质上就是插入排序的增强版，希尔排序将数组分隔成n组来进行插入排序，直至该数组宏观上有序，最后再进行插入排序时就不用移动那么多次位置了～</strong></p><p><strong>代码思路：希尔增量一般是gap = gap / 2，只是比普通版插入排序多了这么一个for循环而已。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>=a.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//增量每次都除以二 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">step</span>=<span class="built_in">size</span>/<span class="number">2</span>;<span class="built_in">step</span>&gt;<span class="number">0</span>;<span class="built_in">step</span>/=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">step</span>;i&lt;<span class="built_in">size</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j=i;</span><br><span class="line"><span class="keyword">int</span> temp=a[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//j-step就是代表与j同组的前一位元素 </span></span><br><span class="line"><span class="keyword">while</span>(j-<span class="built_in">step</span>&gt;=<span class="number">0</span>&amp;&amp;a[j-<span class="built_in">step</span>]&gt;temp)&#123;</span><br><span class="line">a[j]=a[j-<span class="built_in">step</span>];</span><br><span class="line">j-=<span class="built_in">step</span>;</span><br><span class="line">&#125;</span><br><span class="line">a[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序（桶排序）"><a href="#基数排序（桶排序）" class="headerlink" title="基数排序（桶排序）"></a>基数排序（桶排序）</h2><p><strong>思路：基数排序(桶排序)：将数字切割成个、十、百、千位放入到不同的桶子里，放一次就按桶子顺序回收一次，直至最大位数的数字放完～那么该数组就有序了</strong></p><p><strong>代码实现：先找到数组的最大值，然后根据最大值/10来作为循环的条件(只要&gt;0，那么就说明还有位数)。将个位、十位、…分配到桶子上，每分配一次就回收一次</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*求数据的最大位数,决定排序次数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxbit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1</span>; <span class="comment">//保存最大的位数</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;=p)</span><br><span class="line">        &#123;</span><br><span class="line">            p *= <span class="number">10</span>;</span><br><span class="line">            ++d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> <span class="comment">//基数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = maxbit(a);</span><br><span class="line">    <span class="keyword">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> tmp[n];</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">10</span>]; <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= d; i++) <span class="comment">//进行d次排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = <span class="number">0</span>; <span class="comment">//每次分配前清空计数器</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k = (a[j] / radix) % <span class="number">10</span>; <span class="comment">//统计每个桶中的记录数</span></span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j]; <span class="comment">//将tmp中的位置依次分配给每个桶</span></span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) <span class="comment">//将所有桶中记录依次收集到tmp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = (a[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = a[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) <span class="comment">//将临时数组的内容复制到data中</span></span><br><span class="line">            a[j] = tmp[j];</span><br><span class="line">        radix = radix * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
