<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>信号</title>
      <link href="/2020/10/18/signal/"/>
      <url>/2020/10/18/signal/</url>
      
        <content type="html"><![CDATA[<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>Linux标准信号：</p><p><img src="/2020/10/18/signal/jian/桌面/20180513185711893.png" alt="20180513185711893"></p><p>发送信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数把信号sig发送给pid指定的目的进程，pid的取值及其含义：</p><div class="table-container"><table><thead><tr><th>pid参数</th><th>含义</th></tr></thead><tbody><tr><td>pid &gt; 0</td><td>信号发送给PID为pid的进程</td></tr><tr><td>pid = 0</td><td>信号发送给本进程组内的其他进程</td></tr><tr><td>pid = -1</td><td>信号发送给除了init进程外的所有进程，但需要相应的权限</td></tr><tr><td>pid &lt; -1</td><td>信号发送给组ID为-pid的进程组的所有成员</td></tr></tbody></table></div><p>Linux定义信号值都大于0，如果sig取值为0，kill函数不发送任何信号。</p><p>函数成功返回0，失败返回-1，并设置errno</p><div class="table-container"><table><thead><tr><th>errno</th><th>含义</th></tr></thead><tbody><tr><td>EINVAL</td><td>无效的信号</td></tr><tr><td>EPERM</td><td>该进程没有权限发送信号给任何一个进程</td></tr><tr><td>ESRCH</td><td>目标进程或者进程组不存在</td></tr></tbody></table></div><p>信号处理方式：</p><p>目标进程在收到信号时，需要定义一个接收函数来处理。信号处理函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">_sighandler_t</span>)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>处理自定义信号处理函数外，还有系统定义了两种方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/signum.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_DEL((_sighandler_t) 0)  <span class="comment">/*使用默认处理方式*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_IGN((_sighandler_t) 1)  <span class="comment">/*忽略目标信号*/</span></span></span><br></pre></td></tr></table></figure><p>为一个信号设置处理函数，可以使用下面signal系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">_sighandler_t</span>  <span class="title">signal</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">_sighandler_t</span> _handler)</span></span></span><br></pre></td></tr></table></figure><p>sig指定信号类型，handler指定对应处理函数，函数返回上一次调用signal函数时传入的函数指针，如果第一次调用，则返回默认处理函数</p><p>或者调用以下接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">const</span> struct sigaction* act, struct sigaction* oact)</span></span></span><br></pre></td></tr></table></figure><p>和上面的signal函数类似，sig指定信号类型，act指定对应处理函数，oact指定上一次的处理函数。sigaction结构体详见手册。</p><p>信号默认处理有：</p><ul><li>结束进程（Term）</li><li>忽略信号（Ign）</li><li>结束进程并生成核心转储文件（Core）</li><li>暂停进程（Stop）</li><li>继续进程（Cont）</li></ul><p>信号集：</p><p>Linux使用sigset_t结构体来表示信号集：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/sigset.h&gt;</span></span></span><br><span class="line"><span class="meta">#defind _SIGSET_NWORDS  (1024 / (8 * sizeof(unsigned long int)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> __val[_SIGSET_NWORDS]</span><br><span class="line">&#125;<span class="keyword">__sigset_t</span>;</span><br></pre></td></tr></table></figure><p>sigset_t其实就是一个长整型数组，数组的每个元素的每一位就代表一个信号。与fd_set的定义类似。</p><p>以下函数是用来设置、修改、删除和查询信号集：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span>* _set)</span><span class="comment">/*清空信号集*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span>* _set)</span>   <span class="comment">/*在信号集中设置所有信号*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span>* _set, <span class="keyword">int</span> _signo)</span> <span class="comment">/*将信号_signo添加至信号集中*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span>* _set, <span class="keyword">int</span> _signo)</span>  <span class="comment">/*将信号_signo从信号集中删除*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(_const <span class="keyword">sigset_t</span>* _set, <span class="keyword">int</span> _signo)</span><span class="comment">/*测试信号_signo是否在信号集中*/</span></span></span><br></pre></td></tr></table></figure><p>进程信号掩码：</p><blockquote><p>先说一下信号掩码的作用：在POSIX下，每个进程有一个信号掩码(signal mask)。简单地说，信号掩码是一个“位图”，其中每一位都对应着一种信号。如果位图中的某一位为1，就表示在执行当前信号的处理程序期间相应的信号暂时被“屏蔽”，使得在执行的过程中不会嵌套地响应那种信号。</p></blockquote><p>我们除了用sigaction结构体的sa_mask成员来设置进程的信号掩码。还可以用以下函数设置或者查看进程的信号掩码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpromask</span><span class="params">(<span class="keyword">int</span> _how, _const sigset* _set, sigset* _oset)</span></span>;</span><br></pre></td></tr></table></figure><p>_ set参数指定新的信号掩码，_ oset参数输出原来的信号掩码，_how指定设置进程信号掩码的方式。</p><p>_how的可选值</p><div class="table-container"><table><thead><tr><th>_how参数</th><th>含义</th></tr></thead><tbody><tr><td>SIG_BLOCK</td><td>将_set信号集所指信号屏蔽</td></tr><tr><td>SIG_UNBLOCK</td><td>将_set信号集所指信号设置为不屏蔽</td></tr><tr><td>SIG_SETMASK</td><td>直接将信号掩码设置为_set</td></tr></tbody></table></div><p>被挂起的信号：</p><p>设置信号掩码后，并屏蔽的信号不能被进程接收.如果给进程发送一个被屏蔽的信号，则操作系统将该信号设置为进程的一个被挂起的信号。如果我们取消对被挂起的信号的屏蔽，则它能被进程立即收到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>set参数用于保存被挂起的信号集。</p><h2 id="网络编程相关信号："><a href="#网络编程相关信号：" class="headerlink" title="网络编程相关信号："></a>网络编程相关信号：</h2><ul><li><p>SIGHUP：当挂起进程的控制终端时，SIGHUP信号将被触发。对于没有控制终端的网络后台程序而言，它们通常利用SIGHUP信号来强制服务器重读配置文件。</p></li><li><p>SIGPIPE：往一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号</p></li><li>SIGURG：socket连接上收到紧急数据（带外数据）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux高性能服务器编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_46</title>
      <link href="/2020/09/28/jzof-46/"/>
      <url>/2020/09/28/jzof-46/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h1><h2 id="递归解决这个问题："><a href="#递归解决这个问题：" class="headerlink" title="递归解决这个问题："></a>递归解决这个问题：</h2><p>就拿<strong>12258</strong>做例子（设i为指向12258的索引，从左到右，从0开始）</p><p>我们设立一个函数f，f(i)表示从第i位开始的数字一共有多少种不同的翻译方法</p><p>有以下几种情况：</p><ul><li>当i所指的数字为1：<ul><li>如果i不是指向数字的末尾，则此时f(i) = f(i + 1) + f(i + 2)，f(i + 1)表示将1当作一个数字翻译， f(i + 2)表示将1和其后面的一个数字当作一个整体来翻译</li><li>否则，f(i) = f(i + 1) </li></ul></li><li>当i所指的数字为2：<ul><li>如果i不是指向数字的末尾，并且i+1所指的数字小于等于5，此时f(i) = f(i + 1) + f(i + 2)，f(i + 1)表示将2当作一个数字翻译， f(i + 2)表示将2和其后面的一个数字当作一个整体来翻译</li><li>否则，否则，f(i) = f(i + 1) </li></ul></li><li>其他情况：<ul><li>f(i) = f(i + 1) </li></ul></li></ul><p>终止条件：</p><p>当i超出范围，返回0，当i刚好达到数字末尾返回1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> NUM;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == NUM.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; NUM.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(NUM[index] == <span class="string">&#x27;1&#x27;</span> || (NUM[index] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; NUM[index + <span class="number">1</span>] &lt;= <span class="string">&#x27;5&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span> helper(index + <span class="number">1</span>) + helper(index + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> helper(index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        NUM = to_string(num);</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_45</title>
      <link href="/2020/09/28/jzof-45/"/>
      <url>/2020/09/28/jzof-45/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h1><h2 id="由于数组里所有的数字都要用上，任何组合的答案数值的长度都是一样的。设两个数n1、n2，如果n1-lt-n2，同样n1的字符串-lt-n2的字符串。我们先将nums数组排序，排序规则，当to-string-n1-to-string-n2-lt-to-string-n2-to-string-n1-时，我们知道，需要将n1的放在n2的前面。这样我们可以自定义一个比较函数，来作为sort函数的第三参数。这样sort之后，只需组装就行了。"><a href="#由于数组里所有的数字都要用上，任何组合的答案数值的长度都是一样的。设两个数n1、n2，如果n1-lt-n2，同样n1的字符串-lt-n2的字符串。我们先将nums数组排序，排序规则，当to-string-n1-to-string-n2-lt-to-string-n2-to-string-n1-时，我们知道，需要将n1的放在n2的前面。这样我们可以自定义一个比较函数，来作为sort函数的第三参数。这样sort之后，只需组装就行了。" class="headerlink" title="由于数组里所有的数字都要用上，任何组合的答案数值的长度都是一样的。设两个数n1、n2，如果n1&lt;n2，同样n1的字符串&lt;n2的字符串。我们先将nums数组排序，排序规则，当to_string(n1)+to_string(n2) &lt; to_string(n2)+to_string(n1)时，我们知道，需要将n1的放在n2的前面。这样我们可以自定义一个比较函数，来作为sort函数的第三参数。这样sort之后，只需组装就行了。"></a>由于数组里所有的数字都要用上，任何组合的答案数值的长度都是一样的。设两个数n1、n2，如果n1&lt;n2，同样n1的字符串&lt;n2的字符串。我们先将nums数组排序，排序规则，当to_string(n1)+to_string(n2) &lt; to_string(n2)+to_string(n1)时，我们知道，需要将n1的放在n2的前面。这样我们可以自定义一个比较函数，来作为sort函数的第三参数。这样sort之后，只需组装就行了。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str1 = to_string(n1);</span><br><span class="line">        <span class="built_in">string</span> str2 = to_string(n2);</span><br><span class="line">        <span class="keyword">return</span> (str1 + str2) &lt; (str2 + str1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), comp);</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)ans += to_string(num);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_40</title>
      <link href="/2020/09/28/jzof-40/"/>
      <url>/2020/09/28/jzof-40/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h1><p>题解：</p><div class="table-container"><table><thead><tr><th></th><th>排序法</th><th>堆算法</th></tr></thead><tbody><tr><td>时间复杂度</td><td>O(N*logN)</td><td>O(N*logK)</td></tr><tr><td>空间复杂度</td><td>O(1)</td><td>O(K)</td></tr></tbody></table></div><p>排序法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">begin</span>() + k)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ans;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>堆：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//大根堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">size</span>() &lt; k)q.push(arr[i]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &lt; q.top())&#123;<span class="comment">//如果比堆顶小的就入堆，并且把原来的堆顶pop</span></span><br><span class="line">                    q.pop();</span><br><span class="line">                    q.push(arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时堆中的k个元素都是最小的k个数</span></span><br><span class="line">        <span class="comment">//将堆中的元素“倒”出来</span></span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            ans.push_back(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_39</title>
      <link href="/2020/09/28/jzof-39/"/>
      <url>/2020/09/28/jzof-39/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></h1><div class="table-container"><table><thead><tr><th></th><th>哈希表法</th><th>排序法</th><th>摩尔投票法</th></tr></thead><tbody><tr><td>时间复杂度</td><td>O(N)</td><td>O(N*logN)</td><td>O(N)</td></tr><tr><td>空间复杂度</td><td>O(N)</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><h2 id="哈希表法和排序法：略"><a href="#哈希表法和排序法：略" class="headerlink" title="哈希表法和排序法：略"></a>哈希表法和排序法：略</h2><h2 id="摩尔投票法：如果一个数字出现的次数超过数组长度的一半，则除掉一个这样的树和其他的数，这个数依然是剩下数组的多数元素。设置两个变量num和count，num用来记录当前统计的数字，count用来记录num出现过的次数，如果出现不是num的数字则会抵消（也就是count减一）。"><a href="#摩尔投票法：如果一个数字出现的次数超过数组长度的一半，则除掉一个这样的树和其他的数，这个数依然是剩下数组的多数元素。设置两个变量num和count，num用来记录当前统计的数字，count用来记录num出现过的次数，如果出现不是num的数字则会抵消（也就是count减一）。" class="headerlink" title="摩尔投票法：如果一个数字出现的次数超过数组长度的一半，则除掉一个这样的树和其他的数，这个数依然是剩下数组的多数元素。设置两个变量num和count，num用来记录当前统计的数字，count用来记录num出现过的次数，如果出现不是num的数字则会抵消（也就是count减一）。"></a>摩尔投票法：如果一个数字出现的次数超过数组长度的一半，则除掉一个这样的树和其他的数，这个数依然是剩下数组的多数元素。设置两个变量num和count，num用来记录当前统计的数字，count用来记录num出现过的次数，如果出现不是num的数字则会抵消（也就是count减一）。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>, num = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            count = num != nums[i] ? count - <span class="number">1</span> : count + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)count = <span class="number">1</span>, num = nums[i];  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_38</title>
      <link href="/2020/09/28/jzof-38/"/>
      <url>/2020/09/28/jzof-38/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h1><h2 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h2><ol><li>“所有排列”</li><li>“任意顺序返回”</li><li>“不能有重复元素”</li></ol><h2 id="假设这道题给的字符串中各个字符不相同，则可以用算法课上学的perm1（基于交换的），就算字符串中有相同字符，也可以通过set去重，但是这样效率贼低。下面先贴用set去重的代码："><a href="#假设这道题给的字符串中各个字符不相同，则可以用算法课上学的perm1（基于交换的），就算字符串中有相同字符，也可以通过set去重，但是这样效率贼低。下面先贴用set去重的代码：" class="headerlink" title="假设这道题给的字符串中各个字符不相同，则可以用算法课上学的perm1（基于交换的），就算字符串中有相同字符，也可以通过set去重，但是这样效率贼低。下面先贴用set去重的代码："></a>假设这道题给的字符串中各个字符不相同，则可以用算法课上学的perm1（基于交换的），就算字符串中有相同字符，也可以通过set去重，但是这样效率贼低。下面先贴用set去重的代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; SET;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> index, <span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == s.<span class="built_in">size</span>())SET.insert(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            swap(s[i], s[index]);</span><br><span class="line">            helper(index + <span class="number">1</span>, s);</span><br><span class="line">            swap(s[i], s[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        helper(<span class="number">0</span>, s);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">ans</span><span class="params">(SET.<span class="built_in">begin</span>(), SET.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>排列方案数量： 对于一个长度为 n的字符串（假设字符互不重复），其排列共有n!种方案。</p><p>排列方案的生成方法： 根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 1 位字符（ n 种情况）、再固定第 2 位字符（ n−1 种情况）、… 、最后固定第 n 位字符（ 1 种情况</p><p>当字符串出现重复字符时，会出现相同的方案，我们可以通过剪枝操作，就说如果当前位置，已经固定了某个字符时，接下来在其后面寻找代替字符时（通过交换），如果这个字符已经在之前固定了一次，则不用在固定多一次（交换）。可以用在每个位置可以用set来达到这效果。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/mian-shi-ti-38-zi-fu-chuan-de-pai-lie-hui-su-fa-by/">参考链接</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> index, <span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == s.<span class="built_in">size</span>())ans.push_back(s);</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; SET;<span class="comment">//用set来记录当前位置已经出现过的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(SET.count(s[i]))<span class="keyword">continue</span>;<span class="comment">//已经出现过的话，则直接跳过</span></span><br><span class="line">            <span class="keyword">else</span> SET.insert(s[i]);<span class="comment">//否则加入set</span></span><br><span class="line">            <span class="comment">//通过交换，来遍历在此位置所有放的字符</span></span><br><span class="line">            swap(s[i], s[index]);</span><br><span class="line">            helper(index + <span class="number">1</span>, s);</span><br><span class="line">            swap(s[i], s[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        helper(<span class="number">0</span>, s);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_37</title>
      <link href="/2020/09/28/jzof-37/"/>
      <url>/2020/09/28/jzof-37/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer 37. 序列化二叉树</a></h1><h2 id="一共有两个工作："><a href="#一共有两个工作：" class="headerlink" title="一共有两个工作："></a>一共有两个工作：</h2><ul><li><h2 id="序列化：就是层次遍历，然后用字符串记录节点的值，还有加入“null”的时机，只有当前节点所在深度小于树的深度时才需要加入“null”，还有一个非常重要的点：字符串拼接。就如serialize函数中-ans-“-”-to-string-tmp-gt-left-gt-val-如果改为ans-ans-“-”-to-string-tmp-gt-left-gt-val-的话，无论是时间或空间消耗都会上升一个数量级。leetcode上别人的解释-、常见字符串拼接方法效率比较-、csdn上的解释"><a href="#序列化：就是层次遍历，然后用字符串记录节点的值，还有加入“null”的时机，只有当前节点所在深度小于树的深度时才需要加入“null”，还有一个非常重要的点：字符串拼接。就如serialize函数中-ans-“-”-to-string-tmp-gt-left-gt-val-如果改为ans-ans-“-”-to-string-tmp-gt-left-gt-val-的话，无论是时间或空间消耗都会上升一个数量级。leetcode上别人的解释-、常见字符串拼接方法效率比较-、csdn上的解释" class="headerlink" title="序列化：就是层次遍历，然后用字符串记录节点的值，还有加入“null”的时机，只有当前节点所在深度小于树的深度时才需要加入“null”，还有一个非常重要的点：字符串拼接。就如serialize函数中 ans += (“,” + to_string(tmp-&gt;left-&gt;val)); 如果改为ans = ans + “,” + to_string(tmp-&gt;left-&gt;val);的话，无论是时间或空间消耗都会上升一个数量级。leetcode上别人的解释   、常见字符串拼接方法效率比较  、csdn上的解释"></a>序列化：就是层次遍历，然后用字符串记录节点的值，还有加入“null”的时机，只有当前节点所在深度小于树的深度时才需要加入“null”，还有一个<strong>非常重要的点：字符串拼接</strong>。就如serialize函数中 ans += (“,” + to_string(tmp-&gt;left-&gt;val)); 如果改为ans = ans + “,” + to_string(tmp-&gt;left-&gt;val);的话，无论是时间或空间消耗都会上升一个数量级。<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/zha-zha-fa-xian-de-wen-ti-xi-wang-geng-duo-ren-kan/">leetcode上别人的解释</a>   、<a href="https://www.cnblogs.com/james6176/p/3222671.html">常见字符串拼接方法效率比较</a>  、<a href="https://blog.csdn.net/xiaobaismiley/article/details/25962483?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-25962483.nonecase&amp;utm_term=c++%20%E5%8A%A0%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5">csdn上的解释</a></h2></li><li><h2 id="反序列化：同样是层次遍历，根据字符串来建树，难点就是对substr取子串和stoi（字符串转整数）的运用，序列化则是对to-string的运用。"><a href="#反序列化：同样是层次遍历，根据字符串来建树，难点就是对substr取子串和stoi（字符串转整数）的运用，序列化则是对to-string的运用。" class="headerlink" title="反序列化：同样是层次遍历，根据字符串来建树，难点就是对substr取子串和stoi（字符串转整数）的运用，序列化则是对to_string的运用。"></a>反序列化：同样是层次遍历，根据字符串来建树，难点就是对substr取子串和stoi（字符串转整数）的运用，序列化则是对to_string的运用。</h2></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> getDepth(TreeNode *root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> max(getDepth(root-&gt;left), getDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">string</span> serialize(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> level = getDepth(root);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">string</span> ans = <span class="string">&quot;[&quot;</span> + to_string(root-&gt;val);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="keyword">empty</span>())&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">                TreeNode *tmp = q.front(); q.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    ans += (<span class="string">&quot;,&quot;</span> + to_string(tmp-&gt;left-&gt;val));</span><br><span class="line">                    q.push(tmp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != level)ans += <span class="string">&quot;,null&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    ans += (<span class="string">&quot;,&quot;</span> + to_string(tmp-&gt;right-&gt;val));</span><br><span class="line">                    q.push(tmp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != level)ans += <span class="string">&quot;,null&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    TreeNode* deserialize(<span class="keyword">string</span> data) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data.size() == <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找到根节点的值</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span> &lt;= data[j] &amp;&amp; data[j] &lt;= <span class="string">&#x27;9&#x27;</span>)++j;</span><br><span class="line">        <span class="keyword">int</span> rootValue = stoi(data.substr(i, j - i));</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(rootValue);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//bfs建树</span></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(data[j] != <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            TreeNode *tmp = q.front(); q.pop();</span><br><span class="line"></span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[i] == <span class="string">&#x27;n&#x27;</span>)&#123;</span><br><span class="line">                j += <span class="number">5</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span> &lt;= data[j] &amp;&amp; data[j] &lt;= <span class="string">&#x27;9&#x27;</span>)++j; </span><br><span class="line">                <span class="keyword">int</span> val =  stoi(data.substr(i, j - i));</span><br><span class="line">                TreeNode *node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                tmp-&gt;left = node;</span><br><span class="line">                q.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[i] == <span class="string">&#x27;n&#x27;</span>)&#123;</span><br><span class="line">                j += <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span> &lt;= data[j] &amp;&amp; data[j] &lt;= <span class="string">&#x27;9&#x27;</span>)++j;</span><br><span class="line">                <span class="keyword">int</span> val =  stoi(data.substr(i, j - i));</span><br><span class="line">                TreeNode *node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                tmp-&gt;right = node;</span><br><span class="line">                q.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec;</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_36</title>
      <link href="/2020/09/28/jzof-36/"/>
      <url>/2020/09/28/jzof-36/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></h1><h2 id="题解"><a href="#题解" class="headerlink" title="题解:"></a>题解:</h2><blockquote><p>因为题目中链表的节点值的顺序是从小到大的，符合BST的中序遍历序列，所以我们采用中序遍历来将树来变成一个双向链表。下面是用栈来模拟中序遍历，然后逐个节点连接起来。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Node *head, *cur, *tmp, *prev;</span><br><span class="line">        head = cur  = prev = <span class="literal">NULL</span>;</span><br><span class="line">        tmp = root;</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(tmp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                s.push(tmp);</span><br><span class="line">                tmp = tmp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = s.top(); s.pop();</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">NULL</span>)head = tmp;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">            <span class="comment">//以下两步就是连接cur和pre节点</span></span><br><span class="line">            cur-&gt;left = prev;</span><br><span class="line">            <span class="keyword">if</span>(prev != <span class="literal">NULL</span>)prev-&gt;right = cur;</span><br><span class="line">            </span><br><span class="line">            tmp = tmp-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">while</span>(!s.empty() || tmp);</span><br><span class="line">        <span class="comment">//将头尾节点连接起来</span></span><br><span class="line">        head-&gt;left = cur;</span><br><span class="line">        cur-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归版的中序遍历，只需要几个全局变量来记录头尾节点以及前一个节点就可以了。"><a href="#递归版的中序遍历，只需要几个全局变量来记录头尾节点以及前一个节点就可以了。" class="headerlink" title="递归版的中序遍历，只需要几个全局变量来记录头尾节点以及前一个节点就可以了。"></a>递归版的中序遍历，只需要几个全局变量来记录头尾节点以及前一个节点就可以了。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *head, *prev, *tail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        inorder(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//连接root和prev两个节点</span></span><br><span class="line">        root-&gt;left = prev;</span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="literal">NULL</span>)prev-&gt;right = root;</span><br><span class="line">        <span class="keyword">else</span> head = root;<span class="comment">//记录头结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接完成后将prev指向当前节点</span></span><br><span class="line">        prev = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录尾节点</span></span><br><span class="line">        tail = root;</span><br><span class="line">   </span><br><span class="line">        inorder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        head = tail = prev = <span class="literal">NULL</span>;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="comment">//连接头尾节点</span></span><br><span class="line">        head-&gt;left = tail;</span><br><span class="line">        tail-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_34</title>
      <link href="/2020/09/28/jzof-34/"/>
      <url>/2020/09/28/jzof-34/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指 Offer 34. 二叉树中和为某一值的路径</a></h1><h2 id="先序遍历和路径记录，路径记录用一个vector即可"><a href="#先序遍历和路径记录，路径记录用一个vector即可" class="headerlink" title="先序遍历和路径记录，路径记录用一个vector即可"></a>先序遍历和路径记录，路径记录用一个vector即可</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//其实就是先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="keyword">int</span> s, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        <span class="comment">//将当前节点的值加上</span></span><br><span class="line">        s += root-&gt;val;</span><br><span class="line">        <span class="comment">//如果当前路径和与目标值相等且当前节点为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(s == sum &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            ans.push_back(path);</span><br><span class="line">        dfs(root-&gt;left, s, sum);</span><br><span class="line">        dfs(root-&gt;right, s, sum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_33</title>
      <link href="/2020/09/28/jzof-33/"/>
      <url>/2020/09/28/jzof-33/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h1><h2 id="观察BST后序遍历的特性，最后一个为根节点，比根节点小的节点都是属于左子树，比根节点大的节点都是属于右子树。违背上面规则的话就不是BST。"><a href="#观察BST后序遍历的特性，最后一个为根节点，比根节点小的节点都是属于左子树，比根节点大的节点都是属于右子树。违背上面规则的话就不是BST。" class="headerlink" title="观察BST后序遍历的特性，最后一个为根节点，比根节点小的节点都是属于左子树，比根节点大的节点都是属于右子树。违背上面规则的话就不是BST。"></a>观察BST后序遍历的特性，最后一个为根节点，比根节点小的节点都是属于左子树，比根节点大的节点都是属于右子树。违背上面规则的话就不是BST。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;postorder, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果当前区间没有元素或只有一个元素返回true</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= <span class="built_in">end</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//当前区间最后一个元素为根节点的值</span></span><br><span class="line">        <span class="keyword">int</span> rootValue = postorder[<span class="built_in">end</span>];</span><br><span class="line">        <span class="comment">//比根节点小的都是左子树的节点</span></span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; <span class="built_in">end</span> &amp;&amp; postorder[i] &lt;= rootValue)</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="comment">//除了左子树外剩下的应该都是右子树的节点，应该都比根节点大</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; <span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">if</span>(postorder[j++] &lt; rootValue)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果上面没有出错，接下来递归调用</span></span><br><span class="line">        <span class="keyword">return</span> helper(postorder, start, i - <span class="number">1</span>) &amp;&amp; helper(postorder, i, <span class="built_in">end</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_32</title>
      <link href="/2020/09/28/jzof-32/"/>
      <url>/2020/09/28/jzof-32/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指 Offer 32 - I. 从上到下打印二叉树</a></h1><p>题解：直接用bfs遍历二叉树，因为要求从左到右，所以入队时也是按照从左到右的顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *t=q.front();q.pop();</span><br><span class="line">            ans.push_back(t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h1><p>题解：在上面的代码的基础上稍作修改，就可以达到一层一层的打印效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        TreeNode *t;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="comment">//这就是比上面代码多出的步骤</span></span><br><span class="line">            <span class="comment">//用于表示当前层有多少个节点</span></span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span>=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">size</span>--)&#123;</span><br><span class="line">                t=q.front();q.pop();</span><br><span class="line">                v.push_back(t-&gt;val);</span><br><span class="line">                <span class="comment">//将下一层的节点入队</span></span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h1><p>思路：和第二题一样，如果需要从右到左的话，就在遍历完每层的节点后，将得到的序列逆序即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">bool</span> left_to_right = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">                TreeNode *tmp = q.front(); q.pop();</span><br><span class="line">                v.push_back(tmp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;left)q.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(tmp-&gt;right)q.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!left_to_right)&#123;</span><br><span class="line">                reverse(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">                left_to_right = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left_to_right = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="当然还可以使用双端队列来完成"><a href="#当然还可以使用双端队列来完成" class="headerlink" title="当然还可以使用双端队列来完成"></a>当然还可以使用双端队列来完成</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        q.push_back(root);</span><br><span class="line">        <span class="keyword">bool</span> left_to_right = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            TreeNode *t;</span><br><span class="line">            <span class="keyword">if</span>(left_to_right)&#123;<span class="comment">//从左到右</span></span><br><span class="line">                <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">                    t = q.front(); q.pop_front();</span><br><span class="line">                    v.push_back(t-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(t-&gt;left)q.push_back(t-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(t-&gt;right)q.push_back(t-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//从右到左</span></span><br><span class="line">                <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">                    t = q.back(); q.pop_back();</span><br><span class="line">                    v.push_back(t-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(t-&gt;right)q.push_front(t-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span>(t-&gt;left)q.push_front(t-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(v);</span><br><span class="line">            left_to_right = left_to_right ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_31</title>
      <link href="/2020/09/28/jzof-31/"/>
      <url>/2020/09/28/jzof-31/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 栈的压入、弹出序列</a></h1><p>先将第一个序列入栈，然后再根据第二个序列出栈。</p><h2 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : pushed)&#123;</span><br><span class="line">            s.push(num);</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() == popped[i])&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法2：与上面的类似，不过用来原来的数组作为栈"><a href="#方法2：与上面的类似，不过用来原来的数组作为栈" class="headerlink" title="方法2：与上面的类似，不过用来原来的数组作为栈"></a>方法2：与上面的类似，不过用来原来的数组作为栈</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//i所指的就是栈顶的上一个位置，即push新元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : pushed)&#123;</span><br><span class="line">            pushed[i] = num;<span class="comment">//相当于栈push</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; pushed[i] == popped[j])&#123;</span><br><span class="line">                ++j;</span><br><span class="line">                --i;<span class="comment">//pop</span></span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//i等于0表示栈为空</span></span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_30</title>
      <link href="/2020/09/28/jzof-30/"/>
      <url>/2020/09/28/jzof-30/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></h1><h2 id="普通的栈有push和pop操作，题目增添了一个min操作，且要求这三个操作的时间复杂度为O-1"><a href="#普通的栈有push和pop操作，题目增添了一个min操作，且要求这三个操作的时间复杂度为O-1" class="headerlink" title="普通的栈有push和pop操作，题目增添了一个min操作，且要求这三个操作的时间复杂度为O(1)"></a>普通的栈有push和pop操作，题目增添了一个min操作，且要求这三个操作的时间复杂度为O(1)</h2><p>我们可以将当前栈中最小的元素用另一个栈储存，此时就详细的分析三个操作</p><p>（设用来存储元素的栈称为a，辅助栈称为b）</p><ul><li>push：新元素直接加入到a栈，而对b栈来说，如果b栈为空，直接加入b栈（因为此时a栈在加入新元素前也肯定为空的，此时这个新元素就是a栈中的最小元素）；如果b栈不为空，就要将新元素与b栈的栈顶比较，如果新元素比b栈栈顶元素小或者相等则加入b栈。（总之，我们要b栈的栈顶元素为a栈的最小元素）</li><li>pop：a栈直接pop，b栈的话要看a栈pop出来的元素是否与b栈的栈顶元素相等，如果相等，则b栈也pop（此时a栈的最小元素为b栈pop后的栈顶元素）；相等的话，则b栈不操作</li><li>min：直接返回b栈的栈顶元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        a.push(x);</span><br><span class="line">        <span class="keyword">if</span>(b.empty() || x &lt;= b.top())b.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a.top();</span><br><span class="line">        a.pop();</span><br><span class="line">        <span class="keyword">if</span>(!b.empty() &amp;&amp; x == b.top())b.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_29</title>
      <link href="/2020/09/28/jzof-29/"/>
      <url>/2020/09/28/jzof-29/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h1><blockquote><p>分四个方向去打印：→、↓、←、↑，每打印一个方向后需要改变边界值。难点就在于边界值的确定以及确定终止条件。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> left, right, up, down, i, j, sum = matrix.<span class="built_in">size</span>()*matrix[<span class="number">0</span>].<span class="built_in">size</span>(), num = <span class="number">0</span>;</span><br><span class="line">        left = <span class="number">0</span>; right = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>; up = <span class="number">0</span>; down = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &lt; sum)&#123;</span><br><span class="line">            i = up; j = left;</span><br><span class="line">            <span class="comment">//从左到右</span></span><br><span class="line">            <span class="keyword">while</span>(num &lt; sum &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">                ans.push_back(matrix[i][j]);</span><br><span class="line">                ++j;</span><br><span class="line">                ++num;</span><br><span class="line">            &#125;</span><br><span class="line">            ++up; --j; ++i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从上到下</span></span><br><span class="line">            <span class="keyword">while</span>(num &lt; sum &amp;&amp; i &lt;= down)&#123;</span><br><span class="line">                ans.push_back(matrix[i][j]);</span><br><span class="line">                ++i;</span><br><span class="line">                ++num;</span><br><span class="line">            &#125;</span><br><span class="line">            --right; --i; --j;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从右到左</span></span><br><span class="line">            <span class="keyword">while</span>(num &lt; sum &amp;&amp; j &gt;= left)&#123;</span><br><span class="line">                ans.push_back(matrix[i][j]);</span><br><span class="line">                --j;</span><br><span class="line">                ++num;</span><br><span class="line">            &#125;</span><br><span class="line">            --down; ++j; --i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从下到上</span></span><br><span class="line">            <span class="keyword">while</span>(num &lt; sum &amp;&amp; i &gt;= up)&#123;</span><br><span class="line">                ans.push_back(matrix[i][j]);</span><br><span class="line">                --i;</span><br><span class="line">                ++num;</span><br><span class="line">            &#125; </span><br><span class="line">            ++left; ++i; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_28</title>
      <link href="/2020/09/28/jzof-28/"/>
      <url>/2020/09/28/jzof-28/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指 Offer 28. 对称的二叉树</a></h1><p>对称二叉树是关于以过根节点的垂线为轴的轴对称树。将这棵树的左右子树看为两棵树，先比较当前节点的值是否相同，然后是两棵树的子树比较，左子树的右子树与右子树的左子树比较、左子树的左子树与右子树的右子树比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(TreeNode *p, TreeNode *q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p &amp;&amp; !q)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((p &amp;&amp; !q) || (!p &amp;&amp; q) || (p-&gt;val != q-&gt;val))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSame(p-&gt;left, q-&gt;right) &amp;&amp; isSame(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSame(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_27</title>
      <link href="/2020/09/28/jzof-27/"/>
      <url>/2020/09/28/jzof-27/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></h1><p>所谓镜像就是将每个节点的左右子树调换。直接上代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode *t = root-&gt;left;</span><br><span class="line">        root-&gt;left = mirrorTree(root-&gt;right);</span><br><span class="line">        root-&gt;right = mirrorTree(t);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_26</title>
      <link href="/2020/09/28/jzof-26/"/>
      <url>/2020/09/28/jzof-26/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h1><h2 id="思路1："><a href="#思路1：" class="headerlink" title="思路1："></a>思路1：</h2><p>先用bfs在A树中找到与B树根节点值相同的节点，找到，就用判断两个点是否有相同子结构。</p><p>判断规则：</p><ol><li>如果B为空，返回true</li><li>如果A为空或者A和B节点不同，返回false；</li><li>不满足1、2点，则返回对左右子树的递归判断。</li></ol><h2 id="思路2："><a href="#思路2：" class="headerlink" title="思路2："></a>思路2：</h2><p>与思路1类似，只是不是通过bfs来准确找到某个点，而是全部点都试一试，1、判读以A为根节点的树与b树是否满足条件；2、判断以A的左孩子为根节点的树与b树是否满足条件；3、判断以A的右孩子为根节点的树与b树是否满足条件。以上三个节点满足其中之一即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode *p,TreeNode *B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>||B-&gt;val!=p-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left,B-&gt;left) &amp;&amp; isSameTree(p-&gt;right,B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode* A, TreeNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (A&amp;&amp;B) &amp;&amp; (isSameTree(A,B) || isSubStructure(A-&gt;left,B) || isSubStructure(A-&gt;right,B));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_25</title>
      <link href="/2020/09/28/jzof-25/"/>
      <url>/2020/09/28/jzof-25/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a></h1><h2 id="简单的归并排序"><a href="#简单的归并排序" class="headerlink" title="简单的归并排序"></a>简单的归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *head=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *rear=head;</span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&gt;l2-&gt;val)&#123;</span><br><span class="line">                rear-&gt;next=l2;</span><br><span class="line">                rear=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                rear-&gt;next=l1;</span><br><span class="line">                rear=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rear-&gt;next = l1 == <span class="literal">NULL</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_24</title>
      <link href="/2020/09/28/jzof-24/"/>
      <url>/2020/09/28/jzof-24/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 24. 反转链表</a></h1><h2 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode *tail = reverseList(head-&gt;next);<span class="comment">//先找到最后一个节点</span></span><br><span class="line">        head-&gt;next-&gt;next = head;<span class="comment">//将当前节点的下一个节点的next指向当前节点</span></span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;<span class="comment">//将当前节点的next断掉，否则会出现环</span></span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代："><a href="#迭代：" class="headerlink" title="迭代："></a>迭代：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = <span class="literal">NULL</span>, *pre = head;<span class="comment">//pre指向的cur节点在新链表顺序中的前一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (pre != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ListNode* t = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            cur = pre;</span><br><span class="line">            pre = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_23</title>
      <link href="/2020/09/28/jzof-23/"/>
      <url>/2020/09/28/jzof-23/</url>
      
        <content type="html"><![CDATA[<h1 id="23、链表中环的入口节点"><a href="#23、链表中环的入口节点" class="headerlink" title="23、链表中环的入口节点"></a>23、链表中环的入口节点</h1><h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h1><h2 id="双指针（快慢指针-）：先用快慢指针来检查链表中是否有环，如果有再寻找环的入口。"><a href="#双指针（快慢指针-）：先用快慢指针来检查链表中是否有环，如果有再寻找环的入口。" class="headerlink" title="双指针（快慢指针 ）：先用快慢指针来检查链表中是否有环，如果有再寻找环的入口。"></a>双指针（快慢指针 ）：先用快慢指针来检查链表中是否有环，如果有再寻找环的入口。</h2><ol><li>检查是否有环：快慢指针，慢指针每次走一步，快指针每次走两步，如果两个指针相遇，则链表中有环；如果快指针走到为空指针，则链表无环。</li><li>若第一步检查出有环，则将慢指针重新指向链表头，然后快慢指针以同样的速度（每次走一步）来走，直到两个指针相遇，此时相遇初就是链表环的入口节点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast-&gt;next == <span class="literal">NULL</span> || fast-&gt;next-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="当然快慢指针除了上面这个解决方法，还有其他。如果我知道环中有n个节点，我们可以先让快指针走n步，然后慢指针指向链表头，然后以相同速度（每次走一步），直到两者相遇，则相遇处为环的入口节点。（当然应该还是第一种更快吧？！）"><a href="#当然快慢指针除了上面这个解决方法，还有其他。如果我知道环中有n个节点，我们可以先让快指针走n步，然后慢指针指向链表头，然后以相同速度（每次走一步），直到两者相遇，则相遇处为环的入口节点。（当然应该还是第一种更快吧？！）" class="headerlink" title="当然快慢指针除了上面这个解决方法，还有其他。如果我知道环中有n个节点，我们可以先让快指针走n步，然后慢指针指向链表头，然后以相同速度（每次走一步），直到两者相遇，则相遇处为环的入口节点。（当然应该还是第一种更快吧？！）"></a>当然快慢指针除了上面这个解决方法，还有其他。如果我知道环中有n个节点，我们可以先让快指针走n步，然后慢指针指向链表头，然后以相同速度（每次走一步），直到两者相遇，则相遇处为环的入口节点。（当然应该还是第一种更快吧？！）</h2><h2 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h2><blockquote><p>已知环中节点有n个，设不在环中的节点有m个（m可以为任意值），所以链表一共有n+m个节点。所以从链表头走n+m-1步刚好走到链表的“尾部”；从链表头走n+m步刚好走到链表中环的入口节点。我们设第一个先走的指针为p1，第二个为p2。p1走了n步，p2开始指向链表头，此时p1和p2以每次走一步的速度前进，当走了m步后，p1和p2相遇，相遇处就是环入口节点。（因为p1走了n+m步，到了环入口节点；p2走了m步，同样走到环入口节点）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="comment">//先检查链表中是否有环</span></span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有环</span></span><br><span class="line">        <span class="keyword">if</span>(fast-&gt;next == <span class="literal">NULL</span> || fast-&gt;next-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//统计环中有多少个节点</span></span><br><span class="line">        ListNode *tmp = slow;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;<span class="keyword">while</span>(tmp != slow);</span><br><span class="line">        <span class="comment">//快慢指针以相同速度移动直至相遇</span></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_22</title>
      <link href="/2020/09/28/jzof-22/"/>
      <url>/2020/09/28/jzof-22/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h1><ul><li><h2 id="方法1：第一次遍历一次链表统计节点个数n，第二次遍历到第n-k个节点返回。"><a href="#方法1：第一次遍历一次链表统计节点个数n，第二次遍历到第n-k个节点返回。" class="headerlink" title="方法1：第一次遍历一次链表统计节点个数n，第二次遍历到第n-k个节点返回。"></a>方法1：第一次遍历一次链表统计节点个数n，第二次遍历到第n-k个节点返回。</h2></li><li><h2 id="方法2：双指针（first和second），first先走k步，然后second指针指向链表头，此时两个指针同时走，直到first指针为空-其实有三个方面需要注意：1、先检查head指针是否为空指针；2、防止链表节点个数小于k"><a href="#方法2：双指针（first和second），first先走k步，然后second指针指向链表头，此时两个指针同时走，直到first指针为空-其实有三个方面需要注意：1、先检查head指针是否为空指针；2、防止链表节点个数小于k" class="headerlink" title="方法2：双指针（first和second），first先走k步，然后second指针指向链表头，此时两个指针同时走，直到first指针为空.(其实有三个方面需要注意：1、先检查head指针是否为空指针；2、防止链表节点个数小于k)"></a>方法2：双指针（first和second），first先走k步，然后second指针指向链表头，此时两个指针同时走，直到first指针为空.(其实有三个方面需要注意：1、先检查head指针是否为空指针；2、防止链表节点个数小于k)</h2></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *first=head;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//first先走k步</span></span><br><span class="line">        <span class="keyword">while</span>(++i&lt;=k&amp;&amp;first)</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果链表没有k个节点，返回NULL</span></span><br><span class="line">        <span class="keyword">if</span>(!first&amp;&amp;i&lt;k)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *second=head;</span><br><span class="line">        <span class="comment">//接下来first和second一起走n-k步（n为链表长度）</span></span><br><span class="line">        <span class="keyword">while</span>(first)</span><br><span class="line">        &#123;</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_21</title>
      <link href="/2020/09/28/jzof-21/"/>
      <url>/2020/09/28/jzof-21/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h1><h2 id="双指针：用两个指针（left指针和right指针），left初始时指向第一个元素，right初始时指向最后一个元素。然后两个指针向中间移动，移动规则：1、左指针：若left所指的元素为奇数，则右移一位（直至指针所指元素为偶数或者left与right相遇）；2、右指针：若right所指的元素为偶数，则左移一位（直至指针所指元素为奇数或者right与left相遇）。这个解法复杂度为O-N-。"><a href="#双指针：用两个指针（left指针和right指针），left初始时指向第一个元素，right初始时指向最后一个元素。然后两个指针向中间移动，移动规则：1、左指针：若left所指的元素为奇数，则右移一位（直至指针所指元素为偶数或者left与right相遇）；2、右指针：若right所指的元素为偶数，则左移一位（直至指针所指元素为奇数或者right与left相遇）。这个解法复杂度为O-N-。" class="headerlink" title="双指针：用两个指针（left指针和right指针），left初始时指向第一个元素，right初始时指向最后一个元素。然后两个指针向中间移动，移动规则：1、左指针：若left所指的元素为奇数，则右移一位（直至指针所指元素为偶数或者left与right相遇）；2、右指针：若right所指的元素为偶数，则左移一位（直至指针所指元素为奇数或者right与left相遇）。这个解法复杂度为O(N)。"></a>双指针：用两个指针（left指针和right指针），left初始时指向第一个元素，right初始时指向最后一个元素。然后两个指针向中间移动，移动规则：1、左指针：若left所指的元素为奇数，则右移一位（直至指针所指元素为偶数或者left与right相遇）；2、右指针：若right所指的元素为偶数，则左移一位（直至指针所指元素为奇数或者right与left相遇）。这个解法复杂度为O(N)。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; (nums[left]&amp;<span class="number">1</span>))</span><br><span class="line">                ++left;</span><br><span class="line">            <span class="keyword">while</span>(right &gt; left &amp;&amp; !(nums[right]&amp;<span class="number">1</span>))</span><br><span class="line">                --right;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; right)swap(nums[left], nums[right]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>考虑扩展性：</p><p>如果</p><ul><li>要将正数和负数放到数字的两边</li><li>要将能被3整除或者不能被3整除的放在两边</li><li>。。。。。</li></ul><p>这时，我们可以将我中间两个while语句中的判断条件抽象为一个函数，然后通过函数指针调用，来扩展不同的判断标准。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_18</title>
      <link href="/2020/09/28/jzof-18/"/>
      <url>/2020/09/28/jzof-18/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h1><p>直接上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val==val)<span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="comment">//由于不是双链表，需要一个指针记录删除节点的前节点</span></span><br><span class="line">        ListNode *pre=head;</span><br><span class="line">        ListNode *t=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(t-&gt;val!=val)&#123;</span><br><span class="line">            t=t-&gt;next;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时t为删除节点</span></span><br><span class="line">        <span class="comment">//所谓删除就是将删除节点跳过</span></span><br><span class="line">        pre-&gt;next=t-&gt;next;</span><br><span class="line">        <span class="comment">//delete t;</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而剑指offer上的要求不是这样的，其要求在O(1)时间内完成删除节点操作。</p><p>上面的解法是顺序查找，复杂度为O(N) </p>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_17</title>
      <link href="/2020/09/28/jzof-17/"/>
      <url>/2020/09/28/jzof-17/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">剑指 Offer 17. 打印从1到最大的n位数</a></h1><p>这题如果是如leetcode上面考的话没有难度，我们需要考虑的是如果我们需要打印的数超过了int，long，甚至long long的范围，如何处理，这是需要用字符串来解决。</p><ul><li><h2 id="方法1：用字符串模拟数字加法"><a href="#方法1：用字符串模拟数字加法" class="headerlink" title="方法1：用字符串模拟数字加法"></a>方法1：用字符串模拟数字加法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increase</span><span class="params">(<span class="built_in">string</span> &amp;num)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = num.<span class="built_in">size</span>(), i = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> carry = <span class="number">1</span>;<span class="comment">//进位 </span></span><br><span class="line"><span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> sum = num[i] - <span class="string">&#x27;0&#x27;</span> + carry;</span><br><span class="line">num[i] = sum % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">carry = sum / <span class="number">10</span>;<span class="comment">//计算当前位之和是否有进1 </span></span><br><span class="line">--i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(carry)num = <span class="string">&quot;1&quot;</span> + num;<span class="comment">//如果有进位，则在num的最左边加一个1 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Max</span><span class="params">(n, <span class="string">&#x27;9&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">num</span><span class="params">(<span class="number">1</span>, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(num &lt; Max)&#123;<span class="comment">//逐个数字输出 </span></span><br><span class="line">Increase(num);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Max&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">printNumbers(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><h2 id="方法2：全排列"><a href="#方法2：全排列" class="headerlink" title="方法2：全排列"></a>方法2：全排列</h2></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_e</span><span class="params">(<span class="keyword">char</span> *number, <span class="keyword">int</span> length)</span></span>&#123;<span class="comment">//自定义打印函数</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; length &amp;&amp; number[i] == <span class="string">&#x27;0&#x27;</span>)++i;<span class="comment">//忽略前缀0 </span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; length)<span class="built_in">cout</span>&lt;&lt;number[i++];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumbersRecurisely</span><span class="params">(<span class="keyword">char</span> *number, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span></span>&#123;<span class="comment">//递归生成数字 </span></span><br><span class="line">    <span class="keyword">if</span>(index == length - <span class="number">1</span>)&#123;<span class="comment">//如果数字位数已经够了 </span></span><br><span class="line">        print_e(number, length);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">        number[index + <span class="number">1</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        printNumbersRecurisely(number, length, index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    number[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">        number[<span class="number">0</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        printNumbersRecurisely(number, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> [] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">printNumbers(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_16</title>
      <link href="/2020/09/28/jzof-16/"/>
      <url>/2020/09/28/jzof-16/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h1><script type="math/tex; mode=display">pow(x,n)=\begin{cases}pow(x,n/2)^{2}& \text{n为偶数}\\pow(x,n/2)^{2}*x& \text{n是奇数}\end{cases}</script><p>唯一需要注意的是，要检查n是否为正数，不是的话就将其转为相反数，x转为其倒数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">double</span> sum = helper(x, n/<span class="number">2</span>);</span><br><span class="line">        sum *= sum;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> ==<span class="number">1</span>)sum *= x;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span>(N &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1.0</span> / x;</span><br><span class="line">            N = -N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(x, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_15</title>
      <link href="/2020/09/28/jzof-15/"/>
      <url>/2020/09/28/jzof-15/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h1><p>两种方法：</p><ul><li><h2 id="第一种：逐位统计"><a href="#第一种：逐位统计" class="headerlink" title="第一种：逐位统计"></a>第一种：逐位统计</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>)++ans;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="上面这种解法在这条题目是可行的，因为输入的是无符号数。但是一旦输入的是有符号数且为负数，就会出现意料之外的事情。"><a href="#上面这种解法在这条题目是可行的，因为输入的是无符号数。但是一旦输入的是有符号数且为负数，就会出现意料之外的事情。" class="headerlink" title="上面这种解法在这条题目是可行的，因为输入的是无符号数。但是一旦输入的是有符号数且为负数，就会出现意料之外的事情。"></a>上面这种解法在这条题目是可行的，因为输入的是无符号数。但是一旦输入的是有符号数且为负数，就会出现意料之外的事情。</h3><blockquote><p>我们先来复习一下数字左移、右移的步骤</p><p>首先是左移：m&lt;&lt;n表示m左移n位，将m最左边的n位弃掉，然后在最右边补n个0</p><p>再接这是右移：m&gt;&gt;n表示m右移n位，如果m是无符号数，则将m的最右n位弃掉，然后在最左边补n个0，如果m不是无符号数的话，则将m的右n位弃掉，然后在最左边补n个与符号位相同的值。</p></blockquote><p>有了这个知识后，我们可知如果负数右移的话，补的是1，这样移动的话，最终n是不会变为0的，也成了死循环。所以有了一下这种解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n&amp;(<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>先用1与n作位于操作，统计最低位是否为1，然后1左移一位，统计左数第二位是否为1，以此类推。</p></blockquote><ul><li><h2 id="位运算："><a href="#位运算：" class="headerlink" title="位运算："></a>位运算：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="comment">//n&amp;(n−1) 解析： 二进制数字 nn 最右边的 11 变成 00 ，其余不变。</span></span><br><span class="line">            n&amp;=(n<span class="number">-1</span>);</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们观察可知n-1就是将n的最右边的1变为0，这个位右边的0变为1，n&amp;(n-1)就是将n的最右边1及其右边全部位变为0，这样可以减少迭代次数。</p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_14</title>
      <link href="/2020/09/28/jzof-14/"/>
      <url>/2020/09/28/jzof-14/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h1><h1 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></h1><ul><li><h2 id="第一题：我们观察求解过程，每一步都有一个最优解，每一部分都是可以分为规模更小的题目来解答，满足动态规划的求解特征。回到问题：一段绳子可以减为两段，然后剪出来的两段绳子可以继续剪。由于我们不止那种剪法是最优的，所以要检查所有剪法，求其中乘积最大值。至于证明，不会！参考其他人的证明："><a href="#第一题：我们观察求解过程，每一步都有一个最优解，每一部分都是可以分为规模更小的题目来解答，满足动态规划的求解特征。回到问题：一段绳子可以减为两段，然后剪出来的两段绳子可以继续剪。由于我们不止那种剪法是最优的，所以要检查所有剪法，求其中乘积最大值。至于证明，不会！参考其他人的证明：" class="headerlink" title="第一题：我们观察求解过程，每一步都有一个最优解，每一部分都是可以分为规模更小的题目来解答，满足动态规划的求解特征。回到问题：一段绳子可以减为两段，然后剪出来的两段绳子可以继续剪。由于我们不止那种剪法是最优的，所以要检查所有剪法，求其中乘积最大值。至于证明，不会！参考其他人的证明："></a>第一题：我们观察求解过程，每一步都有一个最优解，每一部分都是可以分为规模更小的题目来解答，满足动态规划的求解特征。回到问题：一段绳子可以减为两段，然后剪出来的两段绳子可以继续剪。由于我们不止那种剪法是最优的，所以要检查所有剪法，求其中乘积最大值。至于证明，不会！参考其他人的证明：</h2></li></ul><h3 id="贪心法证明"><a href="#贪心法证明" class="headerlink" title="贪心法证明"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/">贪心法证明</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]代表integerBreak(i)</span></span><br><span class="line">        <span class="comment">//i至少由两个数(x,y)之和组成，(x,y)可以进行同样的操作（分成两个数）</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">3</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//将前面小的值先写入</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;dp[<span class="number">2</span>]=<span class="number">2</span>;dp[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">        <span class="comment">//从长度为4的绳子开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i/<span class="number">2</span>;++j)&#123;<span class="comment">//检查所有剪法，求其中乘积最大值</span></span><br><span class="line">                Max = <span class="built_in">max</span>(Max, dp[j]*dp[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = Max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><h2 id="第二题：其实第一题和第二题几乎一样，就是输入n的范围不同，第二题的范围更大，如果我们同样使用动态规划来解决第二题会发现超时，因为动态规划的复杂度为O-N-2-所以要寻求更高效的办法—贪心法。我们需要尽量剪出长度为3的绳子，这样最后得出乘积最大。"><a href="#第二题：其实第一题和第二题几乎一样，就是输入n的范围不同，第二题的范围更大，如果我们同样使用动态规划来解决第二题会发现超时，因为动态规划的复杂度为O-N-2-所以要寻求更高效的办法—贪心法。我们需要尽量剪出长度为3的绳子，这样最后得出乘积最大。" class="headerlink" title="第二题：其实第一题和第二题几乎一样，就是输入n的范围不同，第二题的范围更大，如果我们同样使用动态规划来解决第二题会发现超时，因为动态规划的复杂度为O(N^2).所以要寻求更高效的办法—贪心法。我们需要尽量剪出长度为3的绳子，这样最后得出乘积最大。"></a>第二题：其实第一题和第二题几乎一样，就是输入n的范围不同，第二题的范围更大，如果我们同样使用动态规划来解决第二题会发现超时，因为动态规划的复杂度为O(N^2).所以要寻求更高效的办法—贪心法。我们需要尽量剪出长度为3的绳子，这样最后得出乘积最大。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果n&lt;3，直接返回n-1</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)<span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//尽量减出长度为3的绳子</span></span><br><span class="line">        <span class="keyword">int</span> timesOf3 = n / <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//如果减了若干个长度为三大绳子后，还剩一个1，这样的话，就是有一个4</span></span><br><span class="line">        <span class="comment">//如果长度为4的话分为2、2比3、1好，所以此时要将长度为3的绳子段数减一</span></span><br><span class="line">        <span class="keyword">if</span>(n - timesOf3*<span class="number">3</span> == <span class="number">1</span>)timesOf3--;</span><br><span class="line">        <span class="comment">//如果绳子减了若干段长度为3的绳子后，还剩下的要乘上</span></span><br><span class="line">        <span class="keyword">if</span>(n - timesOf3*<span class="number">3</span>)ans *= n - timesOf3*<span class="number">3</span>; </span><br><span class="line">        <span class="comment">//本来可以直接用pow(3,timesOf3),但是这样会溢出，所以用while</span></span><br><span class="line">        <span class="keyword">while</span>(timesOf3--)ans = (ans*<span class="number">3</span>%<span class="number">1000000007</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_13</title>
      <link href="/2020/09/28/jzof-13/"/>
      <url>/2020/09/28/jzof-13/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h1><p>见到题目的时候，你可能回想直接遍历二维数组的每个坐标看有几个左边是满足和小于等于k的，那这个数就是答案。但是仔细一想，有没有这种可能一个坐标是满足和小于等于k，但是它无法有其他满足条件的点走过来。答案是有的。所以我们只能从[0,0]进行bfs，将其周围满足条件的点入队，同时也要标记以入队的点，防止一个点重复入队。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//检查[x,y]之“和&quot;是否小于等于k</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            sum += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(y)&#123;</span><br><span class="line">            sum += y % <span class="number">10</span>;</span><br><span class="line">            y /= <span class="number">10</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &lt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//上下左右四个方向</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; direction = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//访问标志矩阵</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>; </span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(<span class="number">0</span>);q.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">int</span> y = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> newx = x + direction[<span class="number">2</span>*i], newy = y + direction[<span class="number">2</span>*i + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//如果坐标越界或者已经访问过的话就跳过该点</span></span><br><span class="line">                <span class="keyword">if</span>(newx == m || newx &lt; <span class="number">0</span> || newy == n || newy &lt; <span class="number">0</span> || visited[newx][newy])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(check(newx, newy, k))&#123;</span><br><span class="line">                    ++ans;</span><br><span class="line">                    visited[newx][newy] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(newx); q.push(newy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_12</title>
      <link href="/2020/09/28/jzof-12/"/>
      <url>/2020/09/28/jzof-12/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h1><h2 id="回溯法："><a href="#回溯法：" class="headerlink" title="回溯法："></a>回溯法：</h2><blockquote><p>见题“路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格”我们可得知每一个位置有四个方向可以走，如果走不通在回溯到上一个节点尝试其他方向。同时由于要标记已走过的路径，需要一个矩阵visited来标记位置是否已经走过。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果走完了字符串</span></span><br><span class="line">        <span class="keyword">if</span>(pos == WORD.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//判断位置是否越界或者是否已经访问过</span></span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x == row || y &lt; <span class="number">0</span> || y == col || visited[x][y] || WORD[pos] != board[x][y])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//标记位置已访问</span></span><br><span class="line">        visited[x][y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//四个方向中只要有一个走通就行</span></span><br><span class="line">        flag = dfs(board , visited, x - <span class="number">1</span>, y, pos + <span class="number">1</span>) || dfs(board , visited, x + <span class="number">1</span>, y, pos + <span class="number">1</span>) || dfs(board , visited, x, y - <span class="number">1</span>, pos + <span class="number">1</span>) || dfs(board , visited, x, y + <span class="number">1</span>, pos + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//恢复原状</span></span><br><span class="line">        visited[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        row = board.<span class="built_in">size</span>();</span><br><span class="line">        col = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        WORD = <span class="keyword">word</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">visited</span><span class="params">(row , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col , <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;<span class="comment">//遍历矩阵</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="keyword">word</span>[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dfs(board, visited, i , j , <span class="number">0</span>))&#123;<span class="comment">//如果字符与字符串第一个字符相同，就以该点为起点作dfs</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line">    <span class="built_in">string</span> WORD;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_11</title>
      <link href="/2020/09/28/jzof-11/"/>
      <url>/2020/09/28/jzof-11/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a></h1><p>观察旋转数组的特性，我们可知数组一共有两个递增序列组成，可能第二个递增序列的元素个数为0。</p><ol><li>如果中间元素比最后一个元素要小的话，证明最小元素是在第一个递增序列里。移动右指针。</li><li>如果中间元素比最后一个元素要大的话，证明最小元素是在第二个递增序列里。移动左指针。</li><li>如果中间元素和最后一个元素相等的话，证明最小元素是在第一个递增序列里。将右指针左移一位。</li></ol><blockquote><p>相信前面两点很容易理解，问题是第三点，为何要“将右指针左移一位”。由于第三种情况我们不能判断最小元素是位于前半段还是后半段，所以不能随便忽略某一部分。最右元素与中间元素相等，无论最右元素是否为最小元素，我们都可以将右指针左移动一位来缩小范围。因为最右元素有中间元素代替。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(left &lt;right)&#123;    </span><br><span class="line">     mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[right] &lt; numbers[mid])</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">if</span>(numbers[mid] &lt; numbers[right])  </span><br><span class="line">        right = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        --right;          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_10</title>
      <link href="/2020/09/28/jzof-10/"/>
      <url>/2020/09/28/jzof-10/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h1><h1 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h1><h3 id="问题三：用一个2×1的小矩形去覆盖一个大矩形，小矩形可以横着或竖着去覆盖，问有多少种想法。"><a href="#问题三：用一个2×1的小矩形去覆盖一个大矩形，小矩形可以横着或竖着去覆盖，问有多少种想法。" class="headerlink" title="问题三：用一个2×1的小矩形去覆盖一个大矩形，小矩形可以横着或竖着去覆盖，问有多少种想法。"></a>问题三：用一个2×1的小矩形去覆盖一个大矩形，小矩形可以横着或竖着去覆盖，问有多少种想法。</h3><p>题解：</p><blockquote><p>以上问题都是斐波那契数列的变式。</p></blockquote><h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划：由于递归重复计算很多，计算效率极低，我们将中间结果存储起来，可以避免重复计算。"><a href="#动态规划：由于递归重复计算很多，计算效率极低，我们将中间结果存储起来，可以避免重复计算。" class="headerlink" title="动态规划：由于递归重复计算很多，计算效率极低，我们将中间结果存储起来，可以避免重复计算。"></a>动态规划：由于递归重复计算很多，计算效率极低，我们将中间结果存储起来，可以避免重复计算。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    d.resize(<span class="number">101</span>);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[n]!=<span class="number">0</span>)<span class="keyword">return</span> d[n];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> r=(fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>))%<span class="number">1000000007</span>;</span><br><span class="line">            d[n]=r;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数学方法："><a href="#数学方法：" class="headerlink" title="数学方法："></a>数学方法：</h3><p>其实fib(n)</p><script type="math/tex; mode=display">fib(n) = \left[ \begin{matrix}1&1\\1&0 \end{matrix} \right]^{n-1}</script><p>其中求矩阵的n-1次方可以用求pow的相同方式去求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_9</title>
      <link href="/2020/09/28/jzof-9/"/>
      <url>/2020/09/28/jzof-9/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h1><p>队列主要有三个功能，</p><ul><li>front()：返回队首元素</li><li>pop()：在队首删除元素</li><li>push()：在队尾插入元素</li></ul><ul><li><h2 id="push操作复杂度为O-1-pop-操作复杂度为O-N"><a href="#push操作复杂度为O-1-pop-操作复杂度为O-N" class="headerlink" title="push操作复杂度为O(1),pop()操作复杂度为O(N)"></a>push操作复杂度为O(1),pop()操作复杂度为O(N)</h2></li></ul><blockquote><p>我们先来看看栈的特性，（如果入栈期间不出栈）出栈序列和入栈序列互为逆序，而对于队列来说，（如果入队期间不出队）入队序列和出队序列相同。所以要想用栈来模拟队列，栈从栈顶到栈底的顺序应该就是队列的出序序列，也就是说要将先入栈的元素的位置比后入栈的位置要高，这单凭一个栈是无法完成的。所以需要两个栈，一个用于存储“队列”元素（称为A），另一个用于辅助<strong>入队</strong>操作（称为B）：先将把新入队元素加入A栈，然后再把已经入队的元素加入到这个辅助的栈（直至A栈空），然后再将B栈的元素按序倒入A栈。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;<span class="comment">//先将已经入队的元素加入到这个辅助的栈（直至A栈空）</span></span><br><span class="line">    <span class="keyword">while</span>(!a.empty())&#123;</span><br><span class="line">        b.push(a.top());</span><br><span class="line">        a.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    a.push(val);<span class="comment">//将新元素加入A栈</span></span><br><span class="line">    <span class="keyword">while</span>(!b.empty())&#123;<span class="comment">//再将B栈所有元素按序倒入到a栈</span></span><br><span class="line">        a.push(b.top());</span><br><span class="line">        b.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> front = a.top(); a.pop();</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="push操作复杂度为O-N-pop-操作复杂度为O-1"><a href="#push操作复杂度为O-N-pop-操作复杂度为O-1" class="headerlink" title="push操作复杂度为O(N),pop()操作复杂度为O(1)"></a>push操作复杂度为O(N),pop()操作复杂度为O(1)</h2></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; a, b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接将新元素加入到A栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    a.push(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其实就是利用B栈作辅助，取出A栈栈底元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">while</span>(!a.empty())&#123;</span><br><span class="line">        b.push(a.top());</span><br><span class="line">        a.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    ans = b.top(); b.pop();</span><br><span class="line">    <span class="keyword">while</span>(!b.empty())&#123;</span><br><span class="line">        a.push(b.top());</span><br><span class="line">        b.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_8</title>
      <link href="/2020/09/28/jzof-8/"/>
      <url>/2020/09/28/jzof-8/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的下一个节点，给定二叉树中的一个节点，请找出中序遍历的下一个节点。（节点包含：左右指针以及父指针）"><a href="#二叉树的下一个节点，给定二叉树中的一个节点，请找出中序遍历的下一个节点。（节点包含：左右指针以及父指针）" class="headerlink" title="二叉树的下一个节点，给定二叉树中的一个节点，请找出中序遍历的下一个节点。（节点包含：左右指针以及父指针）"></a>二叉树的下一个节点，给定二叉树中的一个节点，请找出中序遍历的下一个节点。（节点包含：左右指针以及父指针）</h1><blockquote><p>由于leetcode上没有第8题，所以根据题目意思自己写函数。</p></blockquote><p>节点结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">treeNode *left, *right, *parent;</span><br><span class="line">treeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), parent(<span class="literal">NULL</span>); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>分析情况：</p><ol><li>若给出节点的父节点为空，则给出节点为根节点，则其下一节点为其右孩子。</li><li>若父节点的不为空<ol><li>若给出节点是父节点的左孩子,则下一节点就是其父节点</li><li>若给出节点是父节点的右孩子<ol><li>若当前节点的右孩子不为空，则下一节点就是其右子树的最左那个节点</li><li>若当前节点的右孩子为空，则下一节点需要沿着父节点一直往搜寻，直到找到一个这样的节点：它是其夫节点的左孩子（如果这样的节点存在，则这就是我们要找的下一个节点）</li></ol></li></ol></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">treeNode* <span class="title">getNext</span><span class="params">(treeNode* pNode)</span></span>&#123;</span><br><span class="line">    treeNode *nextNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">NULL</span>)<span class="comment">//情况0</span></span><br><span class="line">nextNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;parent == <span class="literal">NULL</span>)<span class="comment">//情况1</span></span><br><span class="line">        nextNode = pNode-&gt;right;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;parent-&gt;left == pNode)<span class="comment">//情况2.1</span></span><br><span class="line">            nextNode = pNode-&gt;parent;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//情况2.2</span></span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;right != <span class="literal">NULL</span>)&#123;<span class="comment">//情况2.2.1</span></span><br><span class="line">                pNode = pNode-&gt;right;</span><br><span class="line">                <span class="keyword">while</span>(pNode-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                    pNode = pNode-&gt;left;</span><br><span class="line">                nextNode = pNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//情况2.2.2</span></span><br><span class="line">                <span class="keyword">while</span>(pNode != <span class="literal">NULL</span> &amp;&amp; pNode-&gt;parent != <span class="literal">NULL</span> &amp;&amp; pNode-&gt;parent-&gt;right == pNode)</span><br><span class="line">                    pNode = pNode-&gt;parent;</span><br><span class="line">                <span class="keyword">if</span>(pNode == <span class="literal">NULL</span>)</span><br><span class="line">                    nextNode = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                nextNode = pNode-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_7</title>
      <link href="/2020/09/28/jzof-7/"/>
      <url>/2020/09/28/jzof-7/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h1><blockquote><p>例：</p><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]</p><p>观察前序遍历和中序遍历的序列关系，我们可知前序遍历序列的第一个元素是根，然后我们在中序遍历序列找到其位置，由中序遍历的特点可知，其左边的元素为当前节点的左子树的中序遍历序列，右边的元素为当前节点右子树的中序遍历序列。这样可以得出左右子树的元素个数，就可以再将中序序列与前序序列一一对应，递归调用生成整棵树。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=preorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTree_1(preorder,<span class="number">0</span>,len<span class="number">-1</span>,inorder,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree_1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,<span class="keyword">int</span> ps,<span class="keyword">int</span> pe ,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> is,<span class="keyword">int</span> ie)</span><span class="comment">//辅助函数（ps、pe指代前序序列范围，is、ie指代中序序列范围）</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode *root=<span class="keyword">new</span> TreeNode(preorder[ps]);</span><br><span class="line">        <span class="keyword">int</span> i=is;</span><br><span class="line">        <span class="keyword">while</span>(inorder[i]!=preorder[ps])<span class="comment">//查找根节点在中序序列的位置</span></span><br><span class="line">            ++i；</span><br><span class="line">        <span class="comment">//计算左右子树元素个数</span></span><br><span class="line">        <span class="keyword">int</span> leftsize=i-is;</span><br><span class="line">        <span class="keyword">int</span> rightsize=ie-i;</span><br><span class="line">        <span class="comment">//递归生成左右子树</span></span><br><span class="line">        <span class="keyword">if</span>(leftsize!=<span class="number">0</span>)root-&gt;left=buildTree_1(preorder,ps+<span class="number">1</span>,ps+leftsize,inorder,is,is+leftsize<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rightsize!=<span class="number">0</span>)root-&gt;right=buildTree_1(preorder,ps+leftsize+<span class="number">1</span>,pe,inorder,is+leftsize+<span class="number">1</span>,ie);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_6</title>
      <link href="/2020/09/28/jzof-6/"/>
      <url>/2020/09/28/jzof-6/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></h1><blockquote><p>直接用递归或者用栈来模拟递归实现倒序打印链表。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseTravelList</span><span class="params">(ListNode* head)</span></span>&#123;<span class="comment">//辅助函数</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line">        reverseTravelList(head-&gt;next);<span class="comment">//先访问下一节点</span></span><br><span class="line">        ans.push_back(head-&gt;val);<span class="comment">//再打印当前节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        reverseTravelList(head);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_5</title>
      <link href="/2020/09/28/jzof-5/"/>
      <url>/2020/09/28/jzof-5/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h1><blockquote><p>由于题目给出的参数类型是string，我们只能先遍历一次字符串统计空格个数，然后在新建一个字符串，其长度为原来字符串长度加上两倍的空格个数。然后设置两个指针分别指向两个字符串，根据原来字符串中的字符是否为空格做出不同的赋值。</p><p>如果题目给出的参数类型是char<em>或者char[]，则我们可以<em>*从字符串的尾部开始复制</em></em>，避免字符重复移动，增加复杂度。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfSpace = <span class="number">0</span>;<span class="comment">//空格数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s)<span class="comment">//统计空格个数</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                ++numOfSpace;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">ans</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">2</span>*numOfSpace , <span class="string">&#x27;a&#x27;</span>)</span></span>;<span class="comment">//新建字符串</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.<span class="built_in">size</span>() ; ++i)&#123;<span class="comment">//字符串复制</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                ans[j++] = s[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans[j++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                ans[j++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                ans[j++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_4</title>
      <link href="/2020/09/28/jzof-4/"/>
      <url>/2020/09/28/jzof-4/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h1><blockquote><p>矩阵特点：每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</p><p>我们一般都会从左上角开始搜寻，但是这样会出现错误，若当前元素比目标小，可知，比当前元素大的元素在其下方及右方，此时无法确定搜索的方向。</p><p>当我们从左下角开始搜寻则不一样，<strong>若当前元素比目标小</strong>，可知比当前元素大的元素只在其右方，而当前元素所在列的上方都比其小，所以可以跳过当前元素所在列；<strong>若当前元素比目标大</strong>，可知比当前元素小的元素只在其上方，而当前元素所在行的右方都比其大，所以可以跳过当前元素所在行。重复搜索直到找到元素或越界为止。</p><p>其实，我们从右上角搜也是可以的，但是从右下角开始搜索不行。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从左下角搜索</span></span><br><span class="line">        <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>() ;</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = row - <span class="number">1</span> , j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; row &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; col)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target)</span><br><span class="line">                --i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jzof_3</title>
      <link href="/2020/09/28/jzof-3/"/>
      <url>/2020/09/28/jzof-3/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></h1><p>题解：</p><ol><li><p>采用一个数组来标记数字出现次数，复杂度：时间：O(N)，空间：O(N)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">m</span><span class="params">(nums.<span class="built_in">size</span>() , <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(++m[num] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>排序，然后遍历数组，看前后是否有两个相同的元素，复杂度：时间：O(N*logN)，空间：O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>() , nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> ; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>重拍数组，从头到尾访问数组，访问到下标为i，大小为m的元素，若i等于m，则跳过该元素；若i不等于m，则与下标为m的元素比较，若m与下标为m的元素大小相等，则直接返回元素，否则交换两个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>() ; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[nums[i]])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                swap(nums[i] , nums[nums[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> jzof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis底层数据结构的实现</title>
      <link href="/2020/09/04/redis-basical-structure/"/>
      <url>/2020/09/04/redis-basical-structure/</url>
      
        <content type="html"><![CDATA[<h2 id="简单动态字符串（simple-dynamic-string，SDS）"><a href="#简单动态字符串（simple-dynamic-string，SDS）" class="headerlink" title="简单动态字符串（simple dynamic string，SDS）"></a>简单动态字符串（simple dynamic string，SDS）</h2><h3 id="SDS的定义："><a href="#SDS的定义：" class="headerlink" title="SDS的定义："></a>SDS的定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"><span class="comment">//记录SDS保存字符串的长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录buf数组中未使用的字节数量</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><blockquote><p>例如我们保存了一个“Redis”的字符串。结构内的属性值分别为：len：5，free：0，buf数组的前五个字节分别为‘R’，‘e’，‘d’，‘i’，‘s’，而最后一个字节保存了空字符‘\0’.（这个空字符添加操作是由SDS函数自动完成的，所以对用户来所是透明的）</p></blockquote><h3 id="SDS与C字符串的区别："><a href="#SDS与C字符串的区别：" class="headerlink" title="SDS与C字符串的区别："></a>SDS与C字符串的区别：</h3><ol><li>常数复杂度获取字符串长度：要获取C字符串的长度，就对整个字符串进行计数，直到遇到空字符,复杂度为O(N)；要获取SDS的长度，只需读取其len属性，复杂度为O(1).</li><li>可以避免缓冲区溢出：由于C字符串不记录长度，所以当使用strcat函数（char <em>strcat(char </em>dest,char *src)）时是默认dest是有足够的空间，否则就会出现缓冲区溢出现象。而SDS在进行字符串拼接，会先检查字符串长度，如果空间不够会先进行扩容，再拼接。</li><li>减少修改字符串时带来的内存重分配次数：对C字符串来说，每次修改字符串，都会引起数组的内存重分配操作，对SDS来说，每次修改字符串只是修改对应的<strong>len</strong>属性和<strong>free</strong>属性，采用<code>预分配</code>(每次会分配额外的空间)和<code>惰性空间释放</code>(不会立即释放多余的空间，而是用free记录)。</li><li>二进制安全：C字符串中的字符必须符合某种编码，且不能包含空字符，否则认为是字符串结尾；而对SDS来说，可以储存任何格式的数据，因为SDS是根据len来判断是否为字符串结尾。</li></ol><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="双向-链表和链表节点的定义："><a href="#双向-链表和链表节点的定义：" class="headerlink" title="(双向)链表和链表节点的定义："></a>(双向)链表和链表节点的定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line"><span class="comment">//前置节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"><span class="comment">//后置节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="comment">//节点的值</span></span><br><span class="line"><span class="keyword">void</span> *value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="comment">//表头节点</span></span><br><span class="line">listNode *headl;</span><br><span class="line"><span class="comment">//表尾节点</span></span><br><span class="line">listNode *tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"><span class="comment">//节点值复制函数</span></span><br><span class="line"><span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"><span class="comment">//节点值释放函数</span></span><br><span class="line"><span class="keyword">void</span> *(*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"><span class="comment">//节点值比较函数</span></span><br><span class="line"><span class="keyword">void</span> *(*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><p><img src="/2020/09/04/redis-basical-structure/list.jpg" alt="list"></p><h3 id="链表的特性："><a href="#链表的特性：" class="headerlink" title="链表的特性："></a>链表的特性：</h3><blockquote><p>双向、无环、带头尾指针、带长度计数器以及多态（使用void*来保存节点的值）</p></blockquote><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="字典的定义："><a href="#字典的定义：" class="headerlink" title="字典的定义："></a>字典的定义：</h3><blockquote><p>键值对：键和值进行关联，这些关联的键和值就是键值对<br>字典：又称符号表、关联数组、映射，是一种用于保存键值对的抽象数据结构.</p></blockquote><h3 id="哈希表节点的定义："><a href="#哈希表节点的定义：" class="headerlink" title="哈希表节点的定义："></a>哈希表节点的定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> *key;<span class="comment">//键</span></span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line"><span class="keyword">void</span> *val;</span><br><span class="line">uint64 _tu64;</span><br><span class="line">int64 _ts64;</span><br><span class="line">&#125;v;<span class="comment">//值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span><span class="comment">//指向下个哈希表节点，形成链表，将多个哈希值相同的键值对连接在一起，用于解决键冲突问题</span></span><br><span class="line">&#125;dictEntry;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="哈希表的定义："><a href="#哈希表的定义：" class="headerlink" title="哈希表的定义："></a>哈希表的定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">dictEntry **table;<span class="comment">//哈希表数组</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;<span class="comment">//哈希表大小</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;<span class="comment">//哈希表大小掩码，用于计算索引值，总是等于size-1</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> used;<span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">&#125;dictht;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字典的定义：-1"><a href="#字典的定义：-1" class="headerlink" title="字典的定义："></a>字典的定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型特定函数定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;<span class="comment">//计算哈希值函数（如 MurmurHash算法）</span></span><br><span class="line"><span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);<span class="comment">//复制键函数</span></span><br><span class="line"><span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span>  *obj);<span class="comment">//复制值函数</span></span><br><span class="line"><span class="keyword">void</span> *(*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key1);<span class="comment">//对比键函数</span></span><br><span class="line"><span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);<span class="comment">//销毁键函数</span></span><br><span class="line"><span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);<span class="comment">//销毁值函数</span></span><br><span class="line">&#125;dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字典定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">dictType *type;<span class="comment">//类型特定函数，为用途不同字典设置不同的类型特定函数</span></span><br><span class="line"><span class="keyword">void</span> *privdata;<span class="comment">//私有数据，传给那些类型特定函数的可选参数</span></span><br><span class="line">dictht ht[<span class="number">2</span>];<span class="comment">//哈希表 ht[1]用于rehash</span></span><br><span class="line"><span class="keyword">int</span> trehashidx;<span class="comment">//rehash索引，记录哈希进度，-1 未进行rehash中</span></span><br><span class="line">&#125;dict;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ol><li>type属性指向一个dictType指针，用来保存特定类型键值对的操作函数</li><li>privdata保存了需要传给那些类型特定函数的可选参数</li><li>我可以看见ht是一个包含两个哈希表的数组，一般情况下，字典只使用ht[0],ht[1]只会在对ht[0]进行rehas时才会使用。</li></ol></blockquote><p>示例：</p><p><img src="/2020/09/04/redis-basical-structure/dict.jpg" alt="dict"></p><h3 id="哈希算法："><a href="#哈希算法：" class="headerlink" title="哈希算法："></a>哈希算法：</h3><blockquote><p>每次有一个新的键值对插入字典，都会用哈希算法计算出索引值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br></pre></td></tr></table></figure><blockquote><p>具体的hashFunction的底层实现使用的是<strong>MurmurHash2</strong>算法。</p></blockquote><h3 id="解决键冲突问题："><a href="#解决键冲突问题：" class="headerlink" title="解决键冲突问题："></a>解决键冲突问题：</h3><blockquote><p>Redis是使用<strong>链地址法</strong>来解决键冲突，而且是<strong>头插法</strong>。</p></blockquote><h3 id="rehash（重新排列）："><a href="#rehash（重新排列）：" class="headerlink" title="rehash（重新排列）："></a>rehash（重新排列）：</h3><blockquote><p>随着键值对的个数增大或减少，我们要通过<strong>rehash操作</strong>让<strong>负载因子</strong>维持在一个合理范围</p><p>（负载因子计算公式：负载因子 = 哈希表节点数量 / 哈希表大小）</p></blockquote><h4 id="具体的操作："><a href="#具体的操作：" class="headerlink" title="具体的操作："></a>具体的操作：</h4><blockquote><ol><li>为字典ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作以及ht[0]当前包含的键值对数量（ht[0].used），如果执行的是<strong>扩展</strong>操作，那么ht[1]的大小为第一个大于等于ht[0].used<em>2的n次幂，如果执行的是<em>*收缩</em></em>操作，那么ht[1]的大小为第一个大于等于ht[0].used的2的n次幂。</li><li>将保存在ht[0]中的所有键值对rehash到ht[1]上面rehash指的是重新计算键的哈希值和索引值,然后将键值对放置到ht[1]哈希表的指定位置上。</li><li>当ht[0]包含的所有键值对都迁移到了ht[1]之后释放ht[0]将ht[1]设置为ht[0],并在ht[1]新创键一个空白哈希表为下一次rehash做准备。</li></ol><p>哈希表<strong>渐进式rehash</strong>采用分而置之的方式，避免了集中式rehash带来的庞大计算量，在进行期间，字典的<code>删除、查找、更新</code>等操作会在<strong>两个哈希表</strong>上进行，<code>新添加</code>到字典的键值对一律会保存到ht[1]里面，则ht[0]不再进行任何添加操作。</p></blockquote><h2 id="跳跃表（skipList）："><a href="#跳跃表（skipList）：" class="headerlink" title="跳跃表（skipList）："></a>跳跃表（skipList）：</h2><h4 id="跳表介绍"><a href="#跳表介绍" class="headerlink" title="跳表介绍"></a><a href="https://www.iteye.com/blog/kenby-1187303">跳表介绍</a></h4><blockquote><p>跳跃表是一种有序数据结构，它通过每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p></blockquote><h3 id="跳跃表节点的实现："><a href="#跳跃表节点的实现：" class="headerlink" title="跳跃表节点的实现："></a>跳跃表节点的实现：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    robj *obj;  <span class="comment">/*成员对象*/</span></span><br><span class="line">    <span class="keyword">double</span> score;   <span class="comment">/*分值*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">/*后退指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span> <span class="comment">/*层*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span>  <span class="comment">/*前进指针*/</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;  <span class="comment">/*跨度*/</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><h4 id="属性的解释："><a href="#属性的解释：" class="headerlink" title="属性的解释："></a>属性的解释：</h4><ul><li>成员对象：节点的成员对象(obj属性)是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。在同一个跳跃表中，各个节点保存的成员对象必须是唯一的。</li><li>分值：节点的分值(score属性)是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序</li><li>层：跳跃表节点的level数组可以包含多个元素，每个元素都包含一些指向其他节点的指针，一般来说，层越多，访问节点速度越快。每次创建一个新跳跃表节点时，根据<strong>幂次定律</strong>随机生成一个介于1~32的值作为level数组的大小，也就是层的“高度”。</li><li>前进指针：每个层都有一个指向表尾方向的前进指针(level[i].forward属性)，用于从表头向表尾方向访问节点</li><li>跨度：层的跨度(level[i].span属性)用于记录两个节点之间的距离，<strong>跨度实际上是用来计算排位(rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</strong></li><li>后退指针：节点的后退指针(backward属性)用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次<strong>只能后退至前一个节点</strong>。</li></ul><h3 id="跳跃表的实现："><a href="#跳跃表的实现：" class="headerlink" title="跳跃表的实现："></a>跳跃表的实现：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>    <span class="comment">//header指向跳跃表的表头节点，tail指向跳跃表的表尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;   <span class="comment">//记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</span></span><br><span class="line">    <span class="keyword">int</span> level;  <span class="comment">//记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><h4 id="属性的解释：-1"><a href="#属性的解释：-1" class="headerlink" title="属性的解释："></a>属性的解释：</h4><ul><li>header：指向跳跃表的表头节点</li><li>tail：指向跳跃表的表尾节点</li><li>level：记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</li><li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</li></ul><p>示例：</p><p><img src="/2020/09/04/redis-basical-structure/skiplist.jpg" alt="skiplist"></p><h2 id="整数集合："><a href="#整数集合：" class="headerlink" title="整数集合："></a>整数集合：</h2><blockquote><p>整数集合是集合键的底层实现之一，当一个集合只包含整数且数量不多时，就会使用整数集合作为集合键的底层实现。</p></blockquote><h3 id="整数集合的实现："><a href="#整数集合的实现：" class="headerlink" title="整数集合的实现："></a>整数集合的实现：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 编码方式 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">/* 集合包含的元素数量 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">/* 保存元素的数组 */</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><p><img src="/2020/09/04/redis-basical-structure/intset.jpg" alt="intset"></p><h4 id="属性的解释：-2"><a href="#属性的解释：-2" class="headerlink" title="属性的解释："></a>属性的解释：</h4><ul><li>encoding：其值表示为整数的编码方式，有INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64，对应的是整数类型：int16_t、int32_t、int64_t.</li><li>length：集合的元素个数</li><li>contents：该数组储存的是集合的元素，按从小到大的顺序排列。</li></ul><h3 id="升级：每当添加的元素的类型比整数集合中的所有元素的类型都长的时候，需要进行升级操作。"><a href="#升级：每当添加的元素的类型比整数集合中的所有元素的类型都长的时候，需要进行升级操作。" class="headerlink" title="升级：每当添加的元素的类型比整数集合中的所有元素的类型都长的时候，需要进行升级操作。"></a>升级：每当添加的元素的类型比整数集合中的所有元素的类型都长的时候，需要进行升级操作。</h3><h4 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h4><ol><li>根据新元素的类型扩展数组的空间</li><li>将其他的数据类型转化为与新元素的数据类型相同，并将转换后的元素放到正确位置上</li><li>将新元素插入到数据的合适位置，并更新<code>encoding</code>属性的值</li></ol><p>我们可以观察到每当出现升级操作时，新元素的摆放位置肯定是在最前面或最后面，因为其长度是大于整数集合中的所有元素。</p><h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><blockquote><p>压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量表项，并且每个列表项要么就是小整数，要么就是长度比较短的字符串，那么Redis就会使用压缩列表作为列表键的底层实现。</p></blockquote><h3 id="压缩列表的实现："><a href="#压缩列表的实现：" class="headerlink" title="压缩列表的实现："></a>压缩列表的实现：</h3><p><img src="/2020/09/04/redis-basical-structure/ziplist.png" alt="ziplist"></p><h3 id="压缩列表节点的构成："><a href="#压缩列表节点的构成：" class="headerlink" title="压缩列表节点的构成："></a>压缩列表节点的构成：</h3><p><img src="/2020/09/04/redis-basical-structure/ziplistnode.png" alt="ziplistnode"></p><h4 id="属性解释："><a href="#属性解释：" class="headerlink" title="属性解释："></a>属性解释：</h4><ul><li>previous_entry_length 属性以字节为单位,记录了压缩列表中前一个节点的长度,previous_entry_length属性的长度可以是1字节或者5字节（如果前一节点的长度小于254字节那么previous_entry_length属性的长度为1字节 ，如果前一节点的长度大于等于254字节）。根据当前节点的地址和previous_entry_length的值来计算出前一个节点的地址，压缩列表的从表尾向表头遍历操作就是使用这一原理实现的</li><li>encoding属性记录了字节数组的边码方式以及编码长度。</li><li>content属性负责保存节点的值，节点值可以是一个字节数组或者整数值的类型和长度由encoding决定</li></ul><h3 id="连锁更新："><a href="#连锁更新：" class="headerlink" title="连锁更新："></a>连锁更新：</h3><blockquote><p>当加入新节点的长度比后面节点的长度要大时，前面节点的更新会引起后面节点的连锁更新。例如：当前压缩列表里的节点长度都是一字节，新加入的节点的长度为五字节，所以后面节点的previous_entry_length无法记录前一节点的长度。需要重新分配内存。除了添加节点，还有删除节点也会引起连锁反应。</p></blockquote><p>下面是一些具体示例：</p><p>插入：</p><p><img src="/2020/09/04/redis-basical-structure/insert.jpg" alt="insert"></p><p>删除：</p><p><img src="/2020/09/04/redis-basical-structure/delete.jpg" alt="delete"></p><p>连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(n) 连锁更新最坏的时间复杂度O(n*n)</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis设计与实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc、g++、gdb常用参数</title>
      <link href="/2020/09/02/gcc-g-gdb/"/>
      <url>/2020/09/02/gcc-g-gdb/</url>
      
        <content type="html"><![CDATA[<h2 id="gcc、g-编译工作的流程"><a href="#gcc、g-编译工作的流程" class="headerlink" title="gcc、g++编译工作的流程"></a>gcc、g++编译工作的流程</h2><div class="table-container"><table><thead><tr><th>部件</th><th>负责工作</th></tr></thead><tbody><tr><td>预处理器（cpp）</td><td>预处理生成.i文件</td></tr><tr><td>编译器（egcs）</td><td>将预处理后的文件转换成汇编语言，生成.文件</td></tr><tr><td>汇编器（as）</td><td>将汇编语言文件变为目标机器代码，生成.o文件</td></tr><tr><td>链接器（ld）</td><td>连接目标代码，生成可执行程序</td></tr></tbody></table></div><a id="more"></a><h2 id="gcc、g-常用参数解释"><a href="#gcc、g-常用参数解释" class="headerlink" title="gcc、g++常用参数解释"></a>gcc、g++常用参数解释</h2><div class="table-container"><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c</td><td>只做预处理、编译、汇编部分工作，只生成目标文件（.o文件）</td></tr><tr><td>-S</td><td>只做预处理、编译部分工作，只生成汇编文件（.s文件）</td></tr><tr><td>-E</td><td>只做预处理部分工作，不生成文件，需要<strong>重定向</strong>到另一个文件 用法：gcc -E inputfile &gt; outputfile</td></tr><tr><td>-o</td><td>将输出文件重定向到指定文件 用法：gcc -o outputfile inputfile[1]…..inputfile[n]</td></tr><tr><td>-O0 \ -O1 \ -O3</td><td>优化选项，生成优化代码，其中O3优化级别最高</td></tr><tr><td>-w</td><td>不生成任何警告信息</td></tr><tr><td>-Wall</td><td>生成所有警告信息</td></tr><tr><td>-M</td><td>生成文件关联（依赖）信息</td></tr><tr><td>-MM</td><td>和“-M”一样，但是它忽略有#include<file>造成的依赖关系</file></td></tr></tbody></table></div><h2 id="gdb调试："><a href="#gdb调试：" class="headerlink" title="gdb调试："></a>gdb调试：</h2><blockquote><p>注意：如果需要gdb调试，在用gcc、g++进行编译时需要用“-g”参数</p></blockquote><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>gdb <program> : program为需要调试的执行文件    </program></p><p>gdb <program> <PID> : 指定这个程序运行时的进程ID（只有当程序是一个服务器程序时） </PID></program></p><h2 id><a href="#" class="headerlink" title=" "></a> </h2><h2 id="常见交互命令："><a href="#常见交互命令：" class="headerlink" title="常见交互命令："></a>常见交互命令：</h2><h3 id="运行命令："><a href="#运行命令：" class="headerlink" title="运行命令："></a>运行命令：</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>run，简写r</td><td>运行程序，直到遇到断点后，会在断点处停止运行等待用户输入命令</td></tr><tr><td>continue，简写c</td><td>继续执行直到下一断点处或执行结束</td></tr><tr><td>next，简写n</td><td>单步跟踪程序，在遇到自定义函数调用时，不进入函数体（即把函数当作整体的一步）</td></tr><tr><td>step，简写s</td><td>与next相同，不过在遇到自定义函数调用时，会进入函数体</td></tr><tr><td>until</td><td>运行程序直到退出循环体</td></tr><tr><td>until+行号</td><td>运行至某行，不仅仅用来跳出循环体</td></tr><tr><td>finish</td><td>运行程序，直到当前函数返回，并打印函数返回的堆栈地址和返回值及其参数信息</td></tr><tr><td>call+函数名（参数）</td><td>调用程序可见函数，并传递参数，如：call print（5）</td></tr><tr><td>quit</td><td>退出gdb</td></tr></tbody></table></div><h3 id="设置端点"><a href="#设置端点" class="headerlink" title="设置端点"></a>设置端点</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>break n，简写b n</td><td>在第n行设置断点（可以带上代码路径及代码文件名，如b main.cpp 14）</td></tr><tr><td>break func</td><td>在函数func的入口处设置断点</td></tr><tr><td>delete 断点号n</td><td>删除第n个断点</td></tr><tr><td>disable 断点号n</td><td>暂停第n个断点</td></tr><tr><td>enable 断点n</td><td>开启第n个断点</td></tr><tr><td>clear 行号n</td><td>删除第n行设置的断点</td></tr><tr><td>info breakpoins，简写info b</td><td>显示设置断点信息</td></tr><tr><td>delete breakpoints</td><td>清除所有设置的断点</td></tr></tbody></table></div><h3 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>list，简写l</td><td>列出源代码，默认显示出10行</td></tr><tr><td>list+行号n</td><td>显示以n为中心的10行代码</td></tr><tr><td>list+函数名</td><td>显示函数体</td></tr><tr><td>list</td><td>将接着上一次list命令输出如下内容</td></tr></tbody></table></div><h3 id="打印表达式"><a href="#打印表达式" class="headerlink" title="打印表达式"></a>打印表达式</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>print 表达式，简写p 表达式</td><td>打印表达式的值，表达式可以为当前调试程序的任何有效表达式</td></tr><tr><td>p a</td><td>显示整数a的值</td></tr><tr><td>p str</td><td>显示字符串str</td></tr><tr><td>p test(22)</td><td>打印以22为参数调用test函数的返回值</td></tr><tr><td>p test(a)</td><td>打印以a为参数调用test函数的返回值</td></tr><tr><td>display 表达式</td><td>在使用display设置表达式后，它将在<strong>每次</strong>单步调试（step、next）后，紧接着输出表达式的值</td></tr><tr><td>watch 表达式</td><td>设置一个监视点，一旦被监视的表达式的值发生改变，将强行终止正在被调试的程序</td></tr><tr><td>whatis 变量或函数</td><td>查询变量或函数</td></tr><tr><td>info locals</td><td>显示当前堆栈页的所有变量</td></tr></tbody></table></div><h3 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a>查询运行信息</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>where / bt</td><td>显示当前运行的堆栈列表</td></tr><tr><td>bt / backtrace</td><td>显示当前调用的堆栈列表</td></tr><tr><td>up / down</td><td>改变堆栈显示的深度</td></tr><tr><td>set args var</td><td>指定程序运行时的参数</td></tr><tr><td>show args</td><td>显示设置好的参数</td></tr><tr><td>info program</td><td>显示程序是否正在运行</td></tr></tbody></table></div><h3 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>layout</td><td>用于分割代码，边看代码边测试</td></tr><tr><td>layout src</td><td>显示源代码窗口</td></tr><tr><td>layout asm</td><td>显示反汇编代码窗口</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> gcc\g++\gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题---树</title>
      <link href="/2020/08/08/tree/"/>
      <url>/2020/08/08/tree/</url>
      
        <content type="html"><![CDATA[<h1 id="14-leetcode刷题—-树"><a href="#14-leetcode刷题—-树" class="headerlink" title="14.leetcode刷题—-树"></a>14.leetcode刷题—-树</h1><h2 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="相关题目："><a href="#相关题目：" class="headerlink" title="相关题目："></a>相关题目：</h2><h2 id="树的递归："><a href="#树的递归：" class="headerlink" title="树的递归："></a>树的递归：</h2><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>我们首先要注意到深度的定义：<strong>根节点到最远叶子节点的最长路径上的节点数</strong>。</p><p>可知当前节点的深度等于 <code>以其左孩子为根节点的深度</code> 或 <code>以其右孩子为根节点的深度</code> 两者中最大值加1.</p></blockquote><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root==<span class="literal">NULL</span>?<span class="number">0</span>:<span class="built_in">max</span>(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p>示例 1:</p><p>给定二叉树 [3,9,20,null,null,15,7] </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回 true 。</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>当前节点平衡的条件：1.左子树为平衡二叉树，2.右子树为平衡二叉树，3.左右孩子高度之差的绝对值小于2.定义一个辅助函数，其功能为：如果以当前节点为根节点的树为平衡二叉树就返回这棵树的高度，否则返回-1.</p></blockquote><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;<span class="comment">//返回节点的高度，若过当前节点不平衡就返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=helper(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right=helper(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">-1</span>||right==<span class="number">-1</span>||<span class="built_in">abs</span>(left-right)&gt;<span class="number">1</span>)<span class="comment">//如果左子树不平衡或者右子树不平衡或者左右子树高度之差大于1，返回-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root)!=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>示例 :<br>给定二叉树</p><pre><code>      1     / \    2   3   / \       4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><blockquote><p><code>一颗二叉树的直径长度的定义：任意两个结点路径长度中的最大值。</code></p><p>可知二叉树的直径长度为以根节点中转节点，其数值等于左右子树的高度之和。</p></blockquote><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;<span class="comment">//返回以root为根节点的二叉树的高度</span></span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=helper(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right=helper(root-&gt;right);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,left+right);<span class="comment">//更新最大直径长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h3><h4 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><pre><code>          5         / \        4   8       /   / \      11  13  4     /  \      \    7    2      1</code></pre><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>采用将sum递减的方法，如果当前节点为叶子节点且sum等于0，返回true</p><p>如果否则对其左右子树递归。</p></blockquote><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">        sum-=root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right&amp;&amp;sum==<span class="number">0</span>)<span class="comment">//叶子节点且路径和等于sum</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left,sum)||hasPathSum(root-&gt;right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h3><h4 id="题目描述：；"><a href="#题目描述：；" class="headerlink" title="题目描述：；"></a>题目描述：；</h4><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p><pre><code>          5         / \        4   8       /   / \      11  13  4     /  \    / \    7    2  5   1</code></pre><p>返回:</p><blockquote><p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p></blockquote><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>相当于dfs，只不过多了一个用vector记录路径的步骤。与上面的题目解法类似。</p></blockquote><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root,<span class="keyword">int</span> sum,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        sum-=root-&gt;val;</span><br><span class="line">        v.push_back(root-&gt;val);<span class="comment">//记录路径</span></span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right)&#123;<span class="comment">//如果当前节点为叶子节点且路径和等于sum</span></span><br><span class="line">            ans.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root-&gt;left,sum,v);</span><br><span class="line">        helper(root-&gt;right,sum,v);</span><br><span class="line">        v.pop_back();<span class="comment">//当左右子树都已访问，将其记录消除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        helper(root,sum,v);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></h3><h4 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p><p>示例：</p><p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p><pre><code>      10     /  \    5   -3   / \    \  3   2   11 / \   \3  -2   1返回 3。和等于 8 的路径有:1.  5 -&gt; 32.  5 -&gt; 2 -&gt; 13.  -3 -&gt; 11</code></pre><h4 id="题目描述：-5"><a href="#题目描述：-5" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote><p>对每个节点都有两种情况（注意：<strong>路径方向必须是向下的（只能从父节点到子节点）</strong>）</p><ol><li>取该节点的值，且连续取其子树的节点的值</li><li>不取该节点的值，以其孩子为路径起点</li></ol><p>对于情况1来说，我们需要一个辅助函数来完成其连续取值的累加和工作</p><p>对于情况2来说，用原函数递归完成</p></blockquote><h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSumWithRoot</span><span class="params">(TreeNode* root,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=root-&gt;val==sum?<span class="number">1</span>:<span class="number">0</span>;<span class="comment">//如果当前节点的值等于目标值sum，count置为1，否则置为0</span></span><br><span class="line">        <span class="comment">//递归调用左右子树计算路径和</span></span><br><span class="line">        count+=pathSumWithRoot(root-&gt;left,sum-root-&gt;val);</span><br><span class="line">        count+=pathSumWithRoot(root-&gt;right,sum-root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空树返回0</span></span><br><span class="line">        <span class="keyword">return</span> pathSumWithRoot(root,sum)+<span class="comment">//以当前节点为路径起点（加上root-&gt;val）</span></span><br><span class="line">            pathSum(root-&gt;left,sum)+pathSum(root-&gt;right,sum);<span class="comment">//或以当前节点左右孩子为根节点（没有加上root-&gt;val）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h3><h4 id="题目描述：-6"><a href="#题目描述：-6" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> \   \</span><br><span class="line"> <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure><p>进阶：</p><p>你可以运用递归和迭代两种方法解决这个问题吗？</p><h4 id="题解（递归）："><a href="#题解（递归）：" class="headerlink" title="题解（递归）："></a>题解（递归）：</h4><blockquote><p>如果以当前节点为根节点的二叉树为是镜像对称的。要满足以下条件：</p><ol><li>其左右子树的值相同，或者左右子树同时为空。</li><li>其左子树的左子树与其右子树的右子树是镜像兑成的。</li><li>其左子树的右子树与其右子树的左子树是镜像兑成的。</li></ol><p>（有点混淆）</p></blockquote><h4 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* r1,TreeNode* r2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!r1&amp;&amp;!r2)<span class="comment">//r1和r2都为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!r1||!r2)<span class="comment">//r1和r2不同</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(r1-&gt;val!=r2-&gt;val)<span class="comment">//r1和r2的值不对称 （不满足条件1）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//条件2和3</span></span><br><span class="line">        <span class="keyword">return</span> helper(r1-&gt;left,r2-&gt;right)&amp;&amp;helper(r1-&gt;right,r2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !root||helper(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解（迭代）：参考"><a href="#题解（迭代）：参考" class="headerlink" title="题解（迭代）：参考"></a>题解（迭代）：<a href="https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/">参考</a></h4><blockquote><p>层次遍历，不过入队的方式有所不同，首先将根节点入队两次。然后每次从队列中提取两节点来比较，若两值相同，入队顺序：节点1的左子树、节点2的右子树、节点1的右子树、节点2的左子树。与上面的<strong>条件2</strong>：<code>其左子树的左子树与其右子树的右子树是镜像兑成的</code>和<strong>条件3：</strong><code>其左子树的右子树与其右子树的左子树是镜像兑成的</code>相同。</p></blockquote><h4 id="代码：-7"><a href="#代码：-7" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* u,TreeNode* v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(u);q.push(v);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="comment">//提取队列中的两个节点</span></span><br><span class="line">            u=q.front();q.pop();</span><br><span class="line">            v=q.front();q.pop();</span><br><span class="line">            <span class="comment">//队列中每两个相邻节点值的情况肯定相同</span></span><br><span class="line">            <span class="keyword">if</span>(!u&amp;&amp;!v)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((!u||!v)||(u-&gt;val!=v-&gt;val))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            q.push(u-&gt;left);<span class="comment">//u的左子树与v的右子树比较</span></span><br><span class="line">            q.push(v-&gt;right);</span><br><span class="line">            </span><br><span class="line">            q.push(u-&gt;right);<span class="comment">//u的右子树和v的左子树比较</span></span><br><span class="line">            q.push(v-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1110-删点成林"><a href="#1110-删点成林" class="headerlink" title="1110. 删点成林"></a><a href="https://leetcode-cn.com/problems/delete-nodes-and-return-forest/">1110. 删点成林</a></h3><h4 id="题目描述：-7"><a href="#题目描述：-7" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给出二叉树的根节点 root，树上每个节点都有一个不同的值。</p><p>如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。</p><p>返回森林中的每棵树。你可以按任意顺序组织答案。</p><p>示例：</p><p><img src="/2020/08/08/tree/screen-shot-2019-07-01-at-53836-pm.png" alt="screen-shot-2019-07-01-at-53836-pm"></p><blockquote><p>输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]<br>输出：[[1,2,null,4],[6],[7]]</p></blockquote><p>提示：</p><ul><li>树中的节点数最大为 1000。</li><li>每个节点都有一个介于 1 到 1000 之间的值，且各不相同。</li><li>to_delete.length &lt;= 1000</li><li>to_delete 包含一些从 1 到 1000、各不相同的值。</li><li>通过次数4,146提交次数6,907</li></ul><h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>采用自底向上的方法。从底层开始，先对其左右子树递归调用。如果当前节点的值在删除节点的集合中，（左右子树不在删除集合中）则将其左右孩子加入到森林forest并将其置为NULL。</p></blockquote><h4 id="代码：-8"><a href="#代码：-8" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode*&amp; root,<span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; forest,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&amp; deleteN)</span> </span>&#123;<span class="comment">//自底向上</span></span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对应左右子树递归调用</span></span><br><span class="line">        root-&gt;left=helper(root-&gt;left,forest,deleteN);</span><br><span class="line">        root-&gt;right=helper(root-&gt;right,forest,deleteN);</span><br><span class="line">        <span class="keyword">if</span>(deleteN.count(root-&gt;val))&#123;<span class="comment">//如果当前节点的值在删除节点中，只有这种情况才会将节点加入到森林</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)<span class="comment">//如果左子树不为空，则加入到森林</span></span><br><span class="line">                forest.push_back(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)<span class="comment">//如果右子树不为空，则加入到森林</span></span><br><span class="line">                forest.push_back(root-&gt;right);</span><br><span class="line">            root=<span class="literal">NULL</span>;<span class="comment">//将当前节点置空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">deleteN</span><span class="params">(to_delete.<span class="built_in">begin</span>(),to_delete.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; forest;</span><br><span class="line">        root=helper(root,forest,deleteN);</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            forest.push_back(root);</span><br><span class="line">        <span class="keyword">return</span> forest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="遍历："><a href="#遍历：" class="headerlink" title="遍历："></a>遍历：</h2><h3 id="层次遍历："><a href="#层次遍历：" class="headerlink" title="层次遍历："></a>层次遍历：</h3><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h3><h4 id="题目描述：-8"><a href="#题目描述：-8" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><p>示例 1：</p><blockquote><p>输入：<br>     3<br>    / \<br>  9  20<br>      /  \<br>    15   7<br>输出：[3, 14.5, 11]<br>解释：<br>第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</p></blockquote><h4 id="题解：-6"><a href="#题解：-6" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>典型的层次遍历模板。</p></blockquote><h4 id="代码：-9"><a href="#代码：-9" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span>=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;++i)&#123;</span><br><span class="line">                TreeNode* t=q.front();q.pop();</span><br><span class="line">                sum+=t-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(sum/<span class="built_in">size</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="前序遍历：；"><a href="#前序遍历：；" class="headerlink" title="前序遍历：；"></a>前序遍历：；</h3><h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h3><p>给定一个二叉树，返回它的 前序 遍历。</p><p> 示例:</p><blockquote><p>输入: [1,null,2,3]<br>   1<br>    \<br>     2<br>    /<br>   3 </p><p>输出: [1,2,3]</p><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><h4 id="题解（递归）：-1"><a href="#题解（递归）：-1" class="headerlink" title="题解（递归）："></a>题解（递归）：</h4><blockquote><p>略</p></blockquote><h4 id="代码：-10"><a href="#代码：-10" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        preorder_route.push_back(root-&gt;val);</span><br><span class="line">        preorder(root-&gt;left,preorder_route);</span><br><span class="line">        preorder(root-&gt;right,preorder_route);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder_route;</span><br><span class="line">        preorder(root,preorder_route);</span><br><span class="line">        <span class="keyword">return</span> preorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解（迭代）："><a href="#题解（迭代）：" class="headerlink" title="题解（迭代）："></a>题解（迭代）：</h4><blockquote><p>用一个栈来模拟前序遍历时函数调用的过程。主要过程如下：我们每入栈一个节点就将其节点值加入到数组中，然后一直将其左边的节点入栈直到左边不存在节点。其后从取栈顶节点，取其右孩子，若不为空继续上述操作。这样重复执行直到栈空。</p></blockquote><h4 id="代码：-11"><a href="#代码：-11" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* t=root;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(t)&#123;</span><br><span class="line">                s.push(t);<span class="comment">//入栈时将节点值加入到队列中</span></span><br><span class="line">                preorder_route.push_back(t-&gt;val);</span><br><span class="line">                t=t-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            t=s.top();s.pop();t=t-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">while</span>(!s.empty()||t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder_route;</span><br><span class="line">        preorder(root,preorder_route);</span><br><span class="line">        <span class="keyword">return</span> preorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h3><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h3><h4 id="题目描述：-9"><a href="#题目描述：-9" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    <span class="string">\</span></span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    <span class="string">/</span></span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="string">输出:</span> [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h4 id="题解（递归）"><a href="#题解（递归）" class="headerlink" title="题解（递归）:"></a>题解（递归）:</h4><blockquote><p>略。</p></blockquote><h4 id="代码：-12"><a href="#代码：-12" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        inorder(root-&gt;left,inorder_route);</span><br><span class="line">        inorder_route.push_back(root-&gt;val);</span><br><span class="line">        inorder(root-&gt;right,inorder_route);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_route;</span><br><span class="line">        inorder(root,inorder_route);</span><br><span class="line">        <span class="keyword">return</span> inorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解（迭代）：-1"><a href="#题解（迭代）：-1" class="headerlink" title="题解（迭代）："></a>题解（迭代）：</h4><blockquote><p>和前序遍历的迭代代码类似，只是将节点值加入到数组的时机不同。</p></blockquote><h4 id="代码：-13"><a href="#代码：-13" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* t=root;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(t)&#123;</span><br><span class="line">                s.push(t);</span><br><span class="line">                t=t-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            t=s.top();s.pop();<span class="comment">//出栈时将节点值加入到数组</span></span><br><span class="line">            inorder_route.push_back(t-&gt;val);</span><br><span class="line">            t=t-&gt;right;</span><br><span class="line">        &#125;<span class="keyword">while</span>(!s.empty()||t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_route;</span><br><span class="line">        inorder(root,inorder_route);</span><br><span class="line">        <span class="keyword">return</span> inorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后序遍历："><a href="#后序遍历：" class="headerlink" title="后序遍历："></a>后序遍历：</h3><h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h3><h4 id="题目描述：-10"><a href="#题目描述：-10" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，返回它的 后序 遍历。</p><p>示例:</p><blockquote><p>输入: [1,null,2,3]<br>   1<br>    \<br>     2<br>    /<br>   3 </p><p>输出: [3,2,1]<br>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><h4 id="题解（递归）：-2"><a href="#题解（递归）：-2" class="headerlink" title="题解（递归）："></a>题解（递归）：</h4><blockquote><p>略。</p></blockquote><h4 id="代码：-14"><a href="#代码：-14" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        postorder(root-&gt;left,postorder_route);</span><br><span class="line">        postorder(root-&gt;right,postorder_route);</span><br><span class="line">        postorder_route.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder_route;</span><br><span class="line">        postorder(root,postorder_route);</span><br><span class="line">        <span class="keyword">return</span> postorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解（迭代）：-2"><a href="#题解（迭代）：-2" class="headerlink" title="题解（迭代）："></a>题解（迭代）：</h4><blockquote><p>同样用栈模拟遍历过程，先将根<code>I:</code>节点入栈，然后将其出栈，再入栈，同时紧跟一个NULL入栈，然后按照先右后左的顺序入栈。当我们从栈顶提取节点时，若栈顶元素为NULL则表示其下面的节点的左右子树已经遍历，将其值加入到数组中，否则，则表示该元素左右子树未遍历，需要重复进行<code>I</code>操作。</p></blockquote><h4 id="代码：-15"><a href="#代码：-15" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode* root , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* t=root;</span><br><span class="line">        s.push(t);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            t=s.top();s.pop();</span><br><span class="line">            <span class="keyword">if</span>(t)&#123;<span class="comment">//当t的左右子树未入栈时，将t再次入栈，使其在栈中位于左右子树下面，并用NULL标记表示其左右子树都已经遍历过</span></span><br><span class="line">                s.push(t);</span><br><span class="line">                s.push(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">//因为栈是先进后出，要想先遍历左子树，左子树要后入栈</span></span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)s.push(t-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left)s.push(t-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//在NULL下面的节点，已经访问过其左右子树了</span></span><br><span class="line">                postorder_route.push_back(s.top()-&gt;val);</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder_route;</span><br><span class="line">        postorder(root,postorder_route);</span><br><span class="line">        <span class="keyword">return</span> postorder_route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="根据遍历序列构造树："><a href="#根据遍历序列构造树：" class="headerlink" title="根据遍历序列构造树："></a>根据遍历序列构造树：</h3><blockquote><p>一共有三种组合：</p><ol><li>前序和中序</li><li>中序和后序</li><li>前序和后序</li></ol><p><strong>只有1和2可以唯一确定一颗二叉树，3不能<code>唯一</code>确定一颗二叉树</strong></p></blockquote><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><h4 id="题目描述：-11"><a href="#题目描述：-11" class="headerlink" title="题目描述："></a>题目描述：</h4><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><blockquote><p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]</p></blockquote><p>返回如下的二叉树：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><h4 id="题解：-7"><a href="#题解：-7" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>观察前序和中序遍历序列的关系。前序第一个为根节点的值，然后在中序找到这个值的位置，其左边的元素个数，就是左子树的节点个数，其右边的元素个数，就是右子树的节点个数。根据这个规律，可以用递归的方法实现。</p></blockquote><h4 id="代码：-16"><a href="#代码：-16" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,<span class="keyword">int</span> first1,<span class="keyword">int</span> last1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> first2,<span class="keyword">int</span> last2)</span> </span>&#123;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(preorder[first1]);</span><br><span class="line">        <span class="keyword">int</span> pos=first2;</span><br><span class="line">        <span class="keyword">while</span>(inorder[pos]!=preorder[first1])&#123;<span class="comment">//找到根节点的值在中序序列中的位置</span></span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftsize=pos-first2;<span class="comment">//计算左右子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> rightsize=last2-pos;</span><br><span class="line">        <span class="comment">//递归生成左右子树</span></span><br><span class="line">        <span class="keyword">if</span>(leftsize)root-&gt;left=helper(preorder,first1+<span class="number">1</span>,first1+leftsize,inorder,first2,pos<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rightsize)root-&gt;right=helper(preorder,first1+leftsize+<span class="number">1</span>,last1,inorder,pos+<span class="number">1</span>,last2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder,<span class="number">0</span>,preorder.<span class="built_in">size</span>()<span class="number">-1</span>,inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><h4 id="题目描述：-12"><a href="#题目描述：-12" class="headerlink" title="题目描述："></a>题目描述：</h4><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>注意:<br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><blockquote><p>中序遍历 inorder = [9,3,15,20,7]<br>后序遍历 postorder = [9,15,7,20,3]</p></blockquote><p>返回如下的二叉树：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><h4 id="题解：-8"><a href="#题解：-8" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>与上面前序和中序的想法类似。不具体介绍。</p></blockquote><h4 id="代码：-17"><a href="#代码：-17" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> first1,<span class="keyword">int</span> last1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder,<span class="keyword">int</span> first2,<span class="keyword">int</span> last2)</span> </span>&#123;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(postorder[last2]);</span><br><span class="line">        <span class="keyword">int</span> pos=first1;</span><br><span class="line">        <span class="keyword">while</span>(inorder[pos]!=postorder[last2])&#123;<span class="comment">//找出根节点在中序序列的位置</span></span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算左右子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> leftsize=pos-first1;</span><br><span class="line">        <span class="keyword">int</span> rightsize=last1-pos;</span><br><span class="line">        <span class="comment">//递归生成左右子树</span></span><br><span class="line">        <span class="keyword">if</span>(leftsize)root-&gt;left=helper(inorder,first1,pos<span class="number">-1</span>,postorder,first2,first2+leftsize<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rightsize)root-&gt;right=helper(inorder,pos+<span class="number">1</span>,last1,postorder,first2+leftsize,last2<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>,postorder,<span class="number">0</span>,postorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="889-根据前序和后序遍历构造二叉树"><a href="#889-根据前序和后序遍历构造二叉树" class="headerlink" title="889. 根据前序和后序遍历构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a></h3><h4 id="题目描述：-13"><a href="#题目描述：-13" class="headerlink" title="题目描述："></a>题目描述：</h4><p>返回与给定的前序和后序遍历匹配的任何二叉树。</p><p> pre 和 post 遍历中的值是不同的正整数。</p><p>示例：</p><blockquote><p>输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]<br>输出：[1,2,3,4,5,6,7]</p></blockquote><p>提示：</p><ul><li>1 &lt;= pre.length == post.length &lt;= 30</li><li>pre[] 和 post[] 都是 1, 2, …, pre.length 的排列</li><li>每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。</li></ul><h4 id="题解：-9"><a href="#题解：-9" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>与上面两题类似。不过这个特别一点，特别之处是找左右子树的节点个数不同。这里不是根据根节点来找，而是根据<strong>pre[first1+1]</strong>在后序遍历序列中的位置来确定。因为这个点是当前根节点的左孩子，其在左子树的后序遍历中是最后访问的，所以找出这个位置就相当于找出了左子树的节点个数，以及右子树的节点个数。需要注意的是：这里确定边界的方法有所不同。</p></blockquote><h4 id="代码：-18"><a href="#代码：-18" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre,<span class="keyword">int</span> first1,<span class="keyword">int</span> last1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post,<span class="keyword">int</span> first2,<span class="keyword">int</span> last2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前区间不存在节点</span></span><br><span class="line">        <span class="keyword">if</span>(first1&gt;last1||first2&gt;last2)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(pre[first1]);</span><br><span class="line">        <span class="comment">//当前区间只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(first1==last1)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">int</span> pos=first2;</span><br><span class="line">        <span class="keyword">while</span>(pre[first1+<span class="number">1</span>]!=post[pos])&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算左右子树节点个数</span></span><br><span class="line">        <span class="keyword">int</span> leftsize=pos-first2+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightsize=last2-pos<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//递归生成左右子树</span></span><br><span class="line">        root-&gt;left=helper(pre,first1+<span class="number">1</span>,first1+leftsize,post,first2,pos);</span><br><span class="line">        root-&gt;right=helper(pre,first1+leftsize+<span class="number">1</span>,last1,post,pos+<span class="number">1</span>,last2<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(pre,<span class="number">0</span>,pre.<span class="built_in">size</span>()<span class="number">-1</span>,post,<span class="number">0</span>,post.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/solution/kan-wo-jiu-gou-liao-san-chong-bian-li-fang-shi-gou/">总结</a></strong></p><h2 id="二叉搜索树："><a href="#二叉搜索树：" class="headerlink" title="二叉搜索树："></a>二叉搜索树：</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><blockquote><p>二叉搜索树的特点：对于树中的每个节点X，它的左子树中所有关键字值小于X的关键字值，而它的右子树中所有关键字值大于X的关键字值。</p><p>根据这个性质，<strong>对一个二叉树进行中序遍历，如果是单调递增的，则可以说明这个树是二叉搜索树</strong>。</p></blockquote><h3 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a></h3><h4 id="题目描述：-14"><a href="#题目描述：-14" class="headerlink" title="题目描述："></a>题目描述：</h4><p>二叉搜索树中的两个节点被错误地交换。</p><p>请在不改变其结构的情况下，恢复这棵树。</p><p>示例 1:</p><p>输入: [1,3,null,null,2]</p><blockquote><p>  1<br>  /<br> 3<br>  \<br>   2</p></blockquote><p>输出: [3,1,null,null,2]</p><blockquote><p>   3<br>  /<br> 1<br>  \<br>   2</p></blockquote><p><strong>进阶:</strong></p><ul><li>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。</li><li>你能想出一个只使用常数空间的解决方案吗？</li></ul><h4 id="题解1："><a href="#题解1：" class="headerlink" title="题解1："></a>题解1：</h4><blockquote><p>先中序遍历一遍获得中序遍历序列，然后再一次中序遍历，将树的节点一一赋值即可。时间复杂度O(N)，空间复杂度O(N).</p></blockquote><h4 id="代码：-19"><a href="#代码：-19" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_route;</span><br><span class="line">    <span class="comment">//获取中序遍历序列</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_inorder_route</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        get_inorder_route(root-&gt;left);</span><br><span class="line">        inorder_route.push_back(root-&gt;val);</span><br><span class="line">        get_inorder_route(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据中序遍历序列恢复BST</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Recover_BST</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp;pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Recover_BST(root-&gt;left,pos);</span><br><span class="line">        root-&gt;val=inorder_route[++pos];</span><br><span class="line">        Recover_BST(root-&gt;right,pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        get_inorder_route(root);</span><br><span class="line">        sort(inorder_route.<span class="built_in">begin</span>(),inorder_route.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">-1</span>;</span><br><span class="line">        Recover_BST(root,pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解2："><a href="#题解2：" class="headerlink" title="题解2："></a>题解2：</h4><h4 id="代码：-20"><a href="#代码：-20" class="headerlink" title="代码："></a>代码：</h4><h3 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h3><h4 id="题目描述：-15"><a href="#题目描述：-15" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><p>示例 1:</p><p>输入: </p><blockquote><p>   1<br>   / \<br>  0   2</p><p> L = 1</p><p>R = 2</p><p>输出:   </p><p>1</p><p>   \</p><p>​      2</p></blockquote><h4 id="题解：-10"><a href="#题解：-10" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>运用bst的特性用递归解决。如果当前节点的值小于L，就返回其右子树，因为其右子树的值都比这个节点的值大，如果当前节点的值大于R，就返回其左子树，因为其左子树的值都比这个节点的值小。</p></blockquote><h4 id="代码：-21"><a href="#代码：-21" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&lt;L)<span class="comment">//在范围外的左侧</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root-&gt;right,L,R);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&gt;R)<span class="comment">//在范围外的右侧</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root-&gt;left,L,R);</span><br><span class="line">        <span class="comment">//在范围内</span></span><br><span class="line">        root-&gt;left=trimBST(root-&gt;left,L,R);</span><br><span class="line">        root-&gt;right=trimBST(root-&gt;right,L,R);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="字典树：208-实现-Trie-前缀树"><a href="#字典树：208-实现-Trie-前缀树" class="headerlink" title="字典树：208. 实现 Trie (前缀树)"></a>字典树：<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h3><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><blockquote><p>又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。<br><strong>字典树与字典很相似,当你要查一个单词是不是在字典树中,首先看单词的第一个字母是不是在字典的第一层,如果不在,说明字典树里没有该单词,如果在就在该字母的孩子节点里找是不是有单词的第二个字母,没有说明没有该单词,有的话用同样的方法继续查找.字典树不仅可以用来储存字母,也可以储存数字等其它数据。</strong></p></blockquote><h4 id="题目描述：-16"><a href="#题目描述：-16" class="headerlink" title="题目描述："></a>题目描述：</h4><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p><p>示例:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = <span class="built_in">new</span> Trie();</span><br><span class="line">trie.<span class="keyword">insert</span>(&quot;apple&quot;);</span><br><span class="line">trie.<span class="keyword">search</span>(&quot;apple&quot;);   // 返回 <span class="keyword">true</span></span><br><span class="line">trie.<span class="keyword">search</span>(&quot;app&quot;);     // 返回 <span class="keyword">false</span></span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 <span class="keyword">true</span></span><br><span class="line">trie.<span class="keyword">insert</span>(&quot;app&quot;);   </span><br><span class="line">trie.<span class="keyword">search</span>(&quot;app&quot;);     // 返回 <span class="keyword">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>你可以假设所有的输入都是由小写字母 a-z 构成的。</li><li>保证所有输入均为非空字符串。</li></ul><h4 id="代码：-22"><a href="#代码：-22" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isval;</span><br><span class="line">    TrieNode()&#123;</span><br><span class="line">        isval=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">            child[i]=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    TrieNode* root;</span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root=<span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        TrieNode* t=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">word</span>.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!t-&gt;child[<span class="keyword">word</span>[i]-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                t-&gt;child[<span class="keyword">word</span>[i]-<span class="string">&#x27;a&#x27;</span>]=<span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[<span class="keyword">word</span>[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        t-&gt;isval=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        TrieNode* t=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">word</span>.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!t)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[<span class="keyword">word</span>[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !t?<span class="literal">false</span>:t-&gt;isval;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* t=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prefix.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!t)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t=t-&gt;child[prefix[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !t?<span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="基础练习："><a href="#基础练习：" class="headerlink" title="基础练习："></a>基础练习：</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h4><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="题解：-11"><a href="#题解：-11" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>递归应用。</p></blockquote><h4 id="代码：-23"><a href="#代码：-23" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* right=invertTree(root-&gt;left);</span><br><span class="line">        root-&gt;left=invertTree(root-&gt;right);</span><br><span class="line">        root-&gt;right=right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><h4 id="题目描述：-17"><a href="#题目描述：-17" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p>示例 1:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">Tree <span class="number">1</span>                     Tree <span class="number">2</span>                  </span><br><span class="line">          <span class="number">1</span>                         <span class="number">2</span>                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        <span class="number">3</span>   <span class="number">2</span>                     <span class="number">1</span>   <span class="number">3</span>                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      <span class="number">5</span>                             <span class="number">4</span>   <span class="number">7</span>                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">     <span class="number">3</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">  / \   \ </span><br><span class="line"> <span class="number">5</span>   <span class="number">4</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 合并必须从两个树的根节点开始。</p><h4 id="题解：-12"><a href="#题解：-12" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>同样是递归。每个位置一共有三种情况：</p><ol><li>r1和r2都为空：返回NULL</li><li>r1、r2一个空，一个不空，返回非空那个节点</li><li>r1和r2都不空：将r2节点的值加到r1节点1的值，然后返回r1</li></ol></blockquote><h4 id="代码：-24"><a href="#代码：-24" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//情况1、2</span></span><br><span class="line">        <span class="keyword">if</span>(!t1)</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(!t2)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">//情况3</span></span><br><span class="line">        t1-&gt;val+=t2-&gt;val;</span><br><span class="line">        t1-&gt;left=mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class="line">        t1-&gt;right=mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一个树的子树</a></h3><h4 id="题目描述：-18"><a href="#题目描述：-18" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p><p>示例 1:<br>给定的树 s:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure><p>给定的树 t：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">4</span> </span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure><p>返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p><h4 id="题解：-13"><a href="#题解：-13" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>辅助函数：判断分别以两个节点为根节点的两棵树是否相同。</p><p>主函数：如果当前值等于子树的根节点的值，调用辅助函数，否则继续递归调用。</p></blockquote><h4 id="代码：-25"><a href="#代码：-25" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//判断分别以s和t的两棵的树是否结构相同</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* s,TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s&amp;&amp;!t)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!s||!t||s-&gt;val!=t-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isSameTree(s-&gt;left,t-&gt;left)&amp;&amp;isSameTree(s-&gt;right,t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前节点值等于子树根节点t的值，调用辅助函数</span></span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val==t-&gt;val)</span><br><span class="line">            <span class="keyword">if</span>(isSameTree(s,t))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对左右子树递归调用</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(s-&gt;left,t)||isSubtree(s-&gt;right,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h3><h4 id="题目描述：-19"><a href="#题目描述：-19" class="headerlink" title="题目描述："></a>题目描述：</h4><p>计算给定二叉树的所有左叶子之和。</p><p>示例：</p><pre><code>    3   / \  9  20    /  \   15   7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</code></pre><h4 id="题解：-14"><a href="#题解：-14" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>采用一个变量lor来标记是否为左孩子。</p></blockquote><h4 id="代码：-26"><a href="#代码：-26" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">leftSum</span><span class="params">(TreeNode* root,<span class="keyword">int</span> lor,<span class="keyword">int</span>&amp; sum)</span> </span>&#123;<span class="comment">//先序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lor&amp;&amp;!root-&gt;left&amp;&amp;!root-&gt;right)&#123;<span class="comment">//当前节点为左叶子节点</span></span><br><span class="line">            sum+=root-&gt;val;<span class="comment">//更新sum</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        leftSum(root-&gt;left,<span class="number">1</span>,sum);</span><br><span class="line">        leftSum(root-&gt;right,<span class="number">0</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        leftSum(root-&gt;left,<span class="number">1</span>,sum);</span><br><span class="line">        leftSum(root-&gt;right,<span class="number">0</span>,sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h3><h4 id="题目描述：-20"><a href="#题目描述：-20" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉树，在树的最后一行找到最左边的值。</p><p><strong>示例 1:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="题解1：-1"><a href="#题解1：-1" class="headerlink" title="题解1："></a>题解1：</h4><blockquote><p>层次遍历，用一个变量记录二叉树每行的最左边的节点的值，每遍历一行更新一次。</p></blockquote><h4 id="代码：-27"><a href="#代码：-27" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span>=q.<span class="built_in">size</span>();</span><br><span class="line">            ans=q.front()-&gt;val;<span class="comment">//更新最左边节点的值</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">size</span>--)&#123;</span><br><span class="line">                TreeNode* t=q.front();q.pop();</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解2：-1"><a href="#题解2：-1" class="headerlink" title="题解2："></a>题解2：</h4><blockquote><p>上面的解法是从左到右的遍历每一行，我们可以反过来，从右到左的遍历每一行，那么最后一个节点的值就是答案了。</p></blockquote><h4 id="代码：-28"><a href="#代码：-28" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *t=root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(t);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            t=q.front();q.pop();</span><br><span class="line">            <span class="comment">//从右到左</span></span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解3："><a href="#题解3：" class="headerlink" title="题解3："></a>题解3：</h4><blockquote><p>上面两个解法都是bfs，其实也可以用dfs来解。我们用两个变量depth、maxdepth来记录当前节点的深度，maxdepth记录已经访问过节点的最大深度，ans记录最左节点的值。maxdepth要用<strong>引用传递</strong>。只有一种情况需要改变ans：当前节点深度大于maxdepth，此时同时修改ans和maxdepth。以上都是基于一个原理：<strong>当我们先序遍历一棵二叉树，最先改变maxdepth的肯定是下一层的最左节点</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> depth,<span class="keyword">int</span> &amp;maxdepth,<span class="keyword">int</span> &amp;ans)</span> </span>&#123;<span class="comment">//dfs或先序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(depth&gt;maxdepth)&#123;<span class="comment">//需要更改ans的情况</span></span><br><span class="line">            ans=root-&gt;val;</span><br><span class="line">            maxdepth=depth;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left,depth+<span class="number">1</span>,maxdepth,ans);</span><br><span class="line">        dfs(root-&gt;right,depth+<span class="number">1</span>,maxdepth,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxdepth=<span class="number">0</span>,ans=root-&gt;val;</span><br><span class="line">        dfs(root,<span class="number">0</span>,maxdepth,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h3><h4 id="题目描述：-21"><a href="#题目描述：-21" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p><p>例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: 原始二叉搜索树:</span><br><span class="line">              <span class="number">5</span></span><br><span class="line">            /   \</span><br><span class="line">           <span class="number">2</span>     <span class="number">13</span></span><br><span class="line"></span><br><span class="line">输出: 转换为累加树:</span><br><span class="line">             <span class="number">18</span></span><br><span class="line">            /   \</span><br><span class="line">          <span class="number">20</span>     <span class="number">13</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="题解：-15"><a href="#题解：-15" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>三种情况：</p><ol><li><p>当前节点为根节点：大于根节点的值，都在其右子树，所以需要先将右子树的所有节点的值累加，再加上自身的值就是累加树根节点的值。</p></li><li><p>当前节点为右节点：大于右节点的值，都在其右子树，所以需要先将右子树的所有节点的值累加，再加上自身的值就是累加树右节点的值。</p><p><strong>可见：1和2可以合并</strong></p></li><li><p>当前节点为左节点：可知大于左节点的节点在除了其左子树的任何位置，基于1和2的基础上，我们此时只需将其父节点的值加上即可。</p></li></ol><p>其实上面三种情况可以总结为一点：每个累加树节点的值等于除了其左子树外整颗树其他节点的累加和。要计算左节点的值，首先要计算夫节点的还有右节点节点的值，这提示我们要改变遍历树的顺序：<strong>右子树 → 根 → 左子树</strong>。</p></blockquote><h4 id="代码：-29"><a href="#代码：-29" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//sum记录的是包括除了当前节点左子树的所有节点的值的累加总和</span></span><br><span class="line">            convertBST(root-&gt;right);</span><br><span class="line">            sum+=root-&gt;val;</span><br><span class="line">            root-&gt;val=sum;</span><br><span class="line">            convertBST(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="进阶练习："><a href="#进阶练习：" class="headerlink" title="进阶练习："></a>进阶练习：</h2><h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><h4 id="题目描述：-22"><a href="#题目描述：-22" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p></blockquote><p>示例 1:</p><blockquote><p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p></blockquote><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><h4 id="题解：-16"><a href="#题解：-16" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>N中情况：</p><ol><li>当我们在当前节点的左右子树分别找到两个节点p、q，则p、q的最近公共祖先则是当前节点。</li><li>如果仅在当前节点的左子树找到p或q，则p、q最近公共祖先则是当前节点的左孩子。</li><li>如果仅在当前节点的右子树找到p或q，则p、q最近公共祖先则是当前节点的右孩子。</li><li>如果当前节点的左右子树都找不p和q，证明p和q不在树里。</li></ol><p>注意：上面的操作都是要自底向上，否则无法满足“最近”这个条件。同时，如果p和q有一个在树里，一个不在树里，这个方法行不通，但是由于题目说明p和q均在树里，所以。。。</p></blockquote><h4 id="代码：-30"><a href="#代码：-30" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root||root==p||root==q)<span class="comment">//如果当前节点就是要找的两个节点之一或者当前节点为空</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自底向上，先查找子树</span></span><br><span class="line">        TreeNode *left=lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">        TreeNode *right=lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!left)<span class="comment">//在右子树中找到p和q，又或者没找到</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(!right)<span class="comment">//在左子树中找到p和q，又或者没找到</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span>(left&amp;&amp;right)<span class="comment">//p和q分布在当前节点的左右子树</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h3><h4 id="题目描述：-23"><a href="#题目描述：-23" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p></blockquote><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例:</p><p>给定的有序链表： [-10, -3, 0, 5, 9],</p><p>一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</p><pre><code>     0    / \  -3   9  /   / -10  5</code></pre><h4 id="题解1：-2"><a href="#题解1：-2" class="headerlink" title="题解1："></a>题解1：</h4><blockquote><p>将链表转为数组，然后递归生成。由于要求树是高度平衡的，所以每次都已区间的中间点作为当前树的根节点，这样就可以确保生成的树是高度平衡的。典型的用空间换时间。</p></blockquote><h4 id="代码：-31"><a href="#代码：-31" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v,<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==r)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(v[l]);</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        TreeNode *root=<span class="keyword">new</span> TreeNode(v[mid]);</span><br><span class="line">        root-&gt;left=helper(v,l,mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=helper(v,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(;head;head=head-&gt;next)</span><br><span class="line">            v.push_back(head-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> helper(v,<span class="number">0</span>,v.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题解2：-2"><a href="#题解2：-2" class="headerlink" title="题解2："></a>题解2：</h4><blockquote><p>直接在链表上递归建树，不过由于链表不能随机定位，需要一步一步找出链表的中间节点，这也是这个方法的主要耗时步骤。其实方法类似于二分查查找1.</p></blockquote><h4 id="代码：-32"><a href="#代码：-32" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(ListNode* head,ListNode *tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==tail)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *fast,*slow;</span><br><span class="line">        slow=head;fast=head;</span><br><span class="line">        <span class="comment">//快慢指针找[head,tail)范围的中间节点</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=tail&amp;&amp;fast-&gt;next!=tail)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(slow-&gt;val);</span><br><span class="line">        <span class="comment">//递归生成左右子树</span></span><br><span class="line">        root-&gt;left=buildTree(head,slow);</span><br><span class="line">        root-&gt;right=buildTree(slow-&gt;next,tail);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(head,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="897-递增顺序查找树"><a href="#897-递增顺序查找树" class="headerlink" title="897. 递增顺序查找树"></a><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序查找树</a></h3><h4 id="题目描述：-24"><a href="#题目描述：-24" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个树，请你 <strong>按中序遍历</strong> 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p><p><strong>示例 ：</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">    <span class="number">3</span>    <span class="number">6</span></span><br><span class="line">   / \    \</span><br><span class="line">  <span class="number">2</span>   <span class="number">4</span>    <span class="number">8</span></span><br><span class="line"> /        / \ </span><br><span class="line"><span class="number">1</span>        <span class="number">7</span>   <span class="number">9</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="literal">null</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span></span><br><span class="line">  \</span><br><span class="line">   <span class="number">2</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">3</span></span><br><span class="line">      \</span><br><span class="line">       <span class="number">4</span></span><br><span class="line">        \</span><br><span class="line">         <span class="number">5</span></span><br><span class="line">          \</span><br><span class="line">           <span class="number">6</span></span><br><span class="line">            \</span><br><span class="line">             <span class="number">7</span></span><br><span class="line">              \</span><br><span class="line">               <span class="number">8</span></span><br><span class="line">                \</span><br><span class="line">                 <span class="number">9</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="题解：-17"><a href="#题解：-17" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>先中序遍历得到序列，然后根据序列逐个节点建树。</p></blockquote><h4 id="代码：-33"><a href="#代码：-33" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        inorder(root-&gt;left,inorder_route);</span><br><span class="line">        inorder_route.push_back(root-&gt;val);</span><br><span class="line">        inorder(root-&gt;right,inorder_route);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_route;</span><br><span class="line">        inorder(root,inorder_route);</span><br><span class="line">        TreeNode *ans=<span class="keyword">new</span> TreeNode;</span><br><span class="line">        TreeNode *finalroot=ans;</span><br><span class="line">        <span class="comment">//逐个节点建树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder_route.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            ans-&gt;right=<span class="keyword">new</span> TreeNode(inorder_route[i]);</span><br><span class="line">            ans=ans-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalroot-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="653-两数之和-IV-输入-BST"><a href="#653-两数之和-IV-输入-BST" class="headerlink" title="653. 两数之和 IV - 输入 BST"></a><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></h4><h4 id="题目描述：-25"><a href="#题目描述：-25" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p><p><strong>案例 1:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span> </span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">3</span>   <span class="number">6</span></span><br><span class="line"> <span class="string">/</span> <span class="string">\</span>   <span class="string">\</span></span><br><span class="line"><span class="number">2</span>   <span class="number">4</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="string">Target</span> <span class="string">=</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="string">输出:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="题解：-18"><a href="#题解：-18" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>利用bst的性质，其中序遍历序列是升序的。然后问题转化成在升序序列中查找是否存在两个值之和等于目标值的问题了。双指针解决。</p></blockquote><h4 id="代码：-34"><a href="#代码：-34" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder_route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            inorder(root-&gt;left,inorder_route);</span><br><span class="line">            inorder_route.push_back(root-&gt;val);</span><br><span class="line">            inorder(root-&gt;right,inorder_route);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_route;</span><br><span class="line">        inorder(root,inorder_route);</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=inorder_route.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;<span class="comment">//双指针部分</span></span><br><span class="line">            <span class="keyword">if</span>(inorder_route[l]+inorder_route[r]&lt;k)</span><br><span class="line">                ++l;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(inorder_route[l]+inorder_route[r]&gt;k)</span><br><span class="line">                --r;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3><h4 id="题目描述：-26"><a href="#题目描述：-26" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li><p>首先找到需要删除的节点</p></li><li><p>如果找到了，删除它。</p></li></ol><p>   说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p><p><strong>示例:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">root</span> <span class="string">=</span> [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>]</span><br><span class="line"><span class="string">key</span> <span class="string">=</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">3</span>   <span class="number">6</span></span><br><span class="line"> <span class="string">/</span> <span class="string">\</span>   <span class="string">\</span></span><br><span class="line"><span class="number">2</span>   <span class="number">4</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="string">给定需要删除的节点值是</span> <span class="number">3</span><span class="string">，所以我们首先找到</span> <span class="number">3</span> <span class="string">这个节点，然后删除它。</span></span><br><span class="line"></span><br><span class="line"><span class="string">一个正确的答案是</span> [<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>]<span class="string">,</span> <span class="string">如下图所示。</span></span><br><span class="line"></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">4</span>   <span class="number">6</span></span><br><span class="line"> <span class="string">/</span>     <span class="string">\</span></span><br><span class="line"><span class="number">2</span>       <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="string">另一个正确答案是</span> [<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>]<span class="string">。</span></span><br><span class="line"></span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">6</span></span><br><span class="line">   <span class="string">\</span>   <span class="string">\</span></span><br><span class="line">    <span class="number">4</span>   <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="题解：-19"><a href="#题解：-19" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>以下n种情况：</p><p>   0.当前节点为空返回NULL。</p><ol><li><p>当前节点小于目标值，对右子树递归调用。</p></li><li><p>当前节点大于目标值，对左子树递归调用。</p></li></ol><ol><li><p>当前节点等于目标值：</p><p>3.1.当前节点为叶子节点，直接删除当前节点，返回NULL</p><p>3.2.当前节点左子树为空，右子树不空，直接用当前节点的右孩子代替当前节点位置，返回root-&gt;right</p><p>3.3.当前节点右子树为空，左子树不空，直接用当前节点的左孩子代替当前节点位置，</p><p>返回root-&gt;left</p></li></ol><p>   3.4.当前节点左右不空，有两种选择办法：    </p><p>   ​    3.4.1.从左子树中找到值最大节点的位置，与交换当前节点交换值，然后对左子树                递归删除</p><p>   ​    3.4.2.从右子树中找到值最小节点的位置，与交换当前节点交换值，然后对右子树                递归删除</p></blockquote><h4 id="代码：-35"><a href="#代码：-35" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="comment">//情况0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;key)<span class="comment">//情况1</span></span><br><span class="line">            root-&gt;right=deleteNode(root-&gt;right,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&gt;key)<span class="comment">//情况2</span></span><br><span class="line">            root-&gt;left=deleteNode(root-&gt;left,key);</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//情况3</span></span><br><span class="line">            <span class="comment">//情况3.1</span></span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)&#123;<span class="comment">//root为叶子节点</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                root=<span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况3.3</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;right)&#123;<span class="comment">//如果root-&gt;left非空</span></span><br><span class="line">                TreeNode* t=root-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况3.2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left)&#123;</span><br><span class="line">                TreeNode* t=root-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//情况3.4</span></span><br><span class="line">                <span class="comment">//找到右子树的值最小的节点</span></span><br><span class="line">                TreeNode* temp=root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span>(temp-&gt;left)temp=temp-&gt;left；</span><br><span class="line">                swap(root-&gt;val,temp-&gt;val); <span class="comment">// 交换值</span></span><br><span class="line">                root-&gt;right=deleteNode(root-&gt;right,key); <span class="comment">// 进入遍历，删除key</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题---位运算</title>
      <link href="/2020/07/29/bit-operate/"/>
      <url>/2020/07/29/bit-operate/</url>
      
        <content type="html"><![CDATA[<h2 id="1-位运算符号"><a href="#1-位运算符号" class="headerlink" title="1.位运算符号"></a>1.位运算符号</h2><div class="table-container"><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>^</td><td>异或</td></tr><tr><td>&amp;</td><td>按位与</td></tr><tr><td>\</td><td>按位或</td></tr><tr><td>&gt;&gt;</td><td>算术右移</td></tr><tr><td>&lt;&lt;</td><td>算术左移</td></tr><tr><td>~</td><td>取反</td></tr></tbody></table></div><a id="more"></a><h2 id="2-位运算常见特性-1S代表全1的二进制数字，0S代表全0的二进制数字"><a href="#2-位运算常见特性-1S代表全1的二进制数字，0S代表全0的二进制数字" class="headerlink" title="2.位运算常见特性(1S代表全1的二进制数字，0S代表全0的二进制数字)"></a>2.位运算常见特性(1S代表全1的二进制数字，0S代表全0的二进制数字)</h2><div class="table-container"><table><thead><tr><th>X ^ 0S = X</th><th>X &amp; 0S = 0</th><th>X \</th><th>0S = X</th></tr></thead><tbody><tr><td>X ^ 1S = ~X</td><td>X &amp; 1S = X</td><td>X \</td><td>1S = 1S</td></tr><tr><td>X ^ X = 0</td><td>X &amp; X = X</td><td>X \</td><td>X =X</td></tr></tbody></table></div><p><code>另有</code>：</p><ul><li><strong>n&amp;(n-1)可以去除n中最低位的1（最右边的1）。例如对于二进制表示11110100<br>，减去 1 得到 11110011，这两个数按位与得到 11110000</strong></li><li><strong>n&amp;(-n)可以得出n中最低位的1（最右边的1）。例如对于二进制表示 11110100，取负得到 00001100，这两个数按位与得到 00000100</strong></li></ul><h2 id="基础题："><a href="#基础题：" class="headerlink" title="基础题："></a>基础题：</h2><h3 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a></h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p><p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p><p>注意：<br>0 ≤ x, y &lt; (2)^31</p><p>示例:</p><blockquote><p>输入: x = 1, y = 4</p><p>输出: 2</p><p>解释:<br>1   (0 0 0 1)<br>4   (0 1 0 0)<br>       ↑   ↑</p></blockquote><p>上面的箭头指出了对应二进制位不同的位置。</p><h4 id="题解：所谓“Hamming距离”就是两个数异或后1的个数。"><a href="#题解：所谓“Hamming距离”就是两个数异或后1的个数。" class="headerlink" title="题解：所谓“Hamming距离”就是两个数异或后1的个数。"></a>题解：所谓“Hamming距离”就是两个数异或后1的个数。</h4><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dif=x^y;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计x^y中1的个数</span></span><br><span class="line">        <span class="keyword">while</span>(dif)&#123;</span><br><span class="line">            ans+=dif&amp;<span class="number">1</span>;</span><br><span class="line">            dif&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a><a href="https://leetcode-cn.com/problems/reverse-bits/">190. 颠倒二进制位</a></h4><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p>颠倒给定的 32 位无符号整数的二进制位。</p><p>示例 1：</p><blockquote><p>输入: 00000010100101000001111010011100<br>输出: 00111001011110000010100101000000<br>解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</p></blockquote><p>题解：</p><blockquote><p><code>“逐位颠倒”</code>法：ans初始为0，每次用n&amp;1得出n的最低位，ans += n&amp;1,并且左移一位：ans &lt;&lt;= 1，这样n的最低位都是从ans的左边往右边加上的。</p></blockquote><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;++i)&#123;</span><br><span class="line">            ans&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            ans+=n&amp;<span class="number">1</span>;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></h3><h4 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><blockquote><p>输入: [2,2,1]<br>输出: 1</p></blockquote><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>由上面提到的位运算特性可知，<strong>X &amp; X = 0</strong>和<strong>X ^ 0 = X</strong>，因为其他数字都是成对出现，所以他们异或得到0，然后0在与那个只出现一次的数字异或运算得到这个只出现了一次的数字。</p></blockquote><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)&#123;</span><br><span class="line">            ans^=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a href="https://leetcode-cn.com/problems/single-number-ii/">137. 只出现一次的数字 II</a></h3><h4 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><blockquote><p>输入: [2,2,3,2]<br>输出: 3</p></blockquote><h4 id="题解：参考题解"><a href="#题解：参考题解" class="headerlink" title="题解：参考题解"></a>题解：<a href="https://leetcode-cn.com/problems/single-number-ii/solution/luo-ji-dian-lu-jiao-du-xiang-xi-fen-xi-gai-ti-si-l/">参考题解</a></h4><h3 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></h3><h4 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。</p><p><strong>示例 :</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>结果输出的顺序并不重要，对于上面的例子， <code>[5, 3]</code> 也是正确答案。</li><li>你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</li></ol><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>设两个只出现一次的元素为x和y，我们先得出整个数组异或的值mask，其实mask=x^y。</p><p>我们无法仅仅从mask分离出x和y。但是我们可以找出两者的区别。mask=mask^(-mask)来保留最右边的1，使其余位置置0，这个要么来自x，要么来自y。然后再遍历一次数组，找出x或者y，其中与mask中1的位置相同的都有可能，所以令x=0，如果<strong>num&amp;diff != 0</strong>,x^=num.因为其他元素都会出现两次，所以他们异或会得出0，最终x就会是x和y的其中一个。然后另一个可以用mask^x得出。</p></blockquote><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mask=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)</span><br><span class="line">            mask^=num;</span><br><span class="line">        <span class="keyword">int</span> diff=mask&amp;(-mask);</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)</span><br><span class="line">            <span class="keyword">if</span>(num&amp;diff)</span><br><span class="line">                x^=num;</span><br><span class="line">        <span class="keyword">return</span> &#123;x,mask^x&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="342-4的幂"><a href="#342-4的幂" class="headerlink" title="342. 4的幂"></a><a href="https://leetcode-cn.com/problems/power-of-four/">342. 4的幂</a></h3><h4 id="题目描述：-5"><a href="#题目描述：-5" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。</p><h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>观察4的幂次方的二进制形式，4^0=1,4^1=100,4^2=10000,4^3=1000000,4^4=100000000,…..</p><p>可见4的幂次方的二进制只有一个1，可以用n&amp;(n-1)去掉最低位的1后，检测是否为0，然后再观察1的位置，全部都是在奇数位的位置。所以可以用与二进制10101010101…..01进行按位与操作，看是否不为0，若为0代表奇数位上没有0，否则代表奇数位上有0，再加上前面的只有一个0的结论可以得出该数就是4的幂次方。</p></blockquote><h4 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num&gt;<span class="number">0</span> &amp;&amp; !(num&amp;(num<span class="number">-1</span>)) &amp;&amp; (num&amp;<span class="number">1431655765</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="318-最大单词长度乘积"><a href="#318-最大单词长度乘积" class="headerlink" title="318. 最大单词长度乘积"></a><a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></h3><h4 id="题目描述：-6"><a href="#题目描述：-6" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p><p>示例 1:</p><blockquote><p>输入: [“abcw”,”baz”,”foo”,”bar”,”xtfn”,”abcdef”]<br>输出: 16<br>解释: 这两个单词为 “abcw”, “xtfn”。</p></blockquote><h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>为每个单词建立一个记录其字符的存在情况的数组，这里用长度为26<strong>bitset</strong>记录，若存在某个字符，bitset对应位置置为1，否则为0。然后每次两个单词相乘时，先用bitset进行按位与运算看是否有相同字符。</p></blockquote><h4 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>=words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">bitset</span>&lt;26&gt;&gt; <span class="title">len</span><span class="params">(<span class="built_in">size</span>)</span></span>;<span class="comment">//每个单词的字符情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">size</span>;++i)&#123;<span class="comment">//建立每个单词对应的bitset</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> CHAR:words[i])&#123;</span><br><span class="line">                len[i].<span class="built_in">set</span>(CHAR-<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">size</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="comment">//若两者没有公共字符，且两者长度之积比现有的记录还大，则更新maxlen</span></span><br><span class="line">                <span class="keyword">if</span>(!(len[i]&amp;len[j]).any()&amp;&amp;maxlen&lt;words[i].<span class="built_in">size</span>()*words[j].<span class="built_in">size</span>())&#123;</span><br><span class="line">                    maxlen=words[i].<span class="built_in">size</span>()*words[j].<span class="built_in">size</span>();</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></h3><h4 id="题目描述：-7"><a href="#题目描述：-7" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><p>示例 1:</p><blockquote><p>输入: 2<br>输出: [0,1,1]</p></blockquote><p>示例 2:</p><blockquote><p>输入: 5<br>输出: [0,1,1,2,1,2]</p></blockquote><p>进阶:</p><ul><li>给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？</li><li>要求算法的空间复杂度为O(n)。</li><li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</li></ul><h4 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>经过观察，每一个数<strong>i</strong>比其一半<strong>i/2</strong>在最低位多了一位数，而这个数是0是1取决于i的奇偶，i为奇数，则多一个1，为偶数，则多一个0.</p><p>还有一种思路：</p><ol><li>如果当前数字i的最低位为1,则i为奇数，则前一位数i-1为偶数，i只比i-1多了一个1，所以<strong>dp[i]=dp[i-1]+1</strong>,</li><li>如果当前数字i的最低位为0,则i为偶数，则i只比i/2多了一个0，i与i-1中1的个数相同，所以<strong>dp[i]=dp[i/2]</strong>。</li></ol></blockquote><h4 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(num+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i)&#123;</span><br><span class="line">            ans[i]=ans[i&gt;&gt;<span class="number">1</span>]+(i%<span class="number">2</span>);</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a><a href="https://leetcode-cn.com/problems/missing-number/">268. 缺失数字</a></h3><h4 id="题目描述：-8"><a href="#题目描述：-8" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p><p>示例 1:</p><blockquote><p>输入: [3,0,1]<br>输出: 2</p></blockquote><p>示例 2:</p><blockquote><p>输入: [9,6,4,2,3,5,7,0,1]<br>输出: 8</p></blockquote><p><strong>说明</strong>:<br>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</p><h4 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h4><ul><li><h4 id="方法1：直接排序，在遍历一遍数组，如果该数与下标不匹配，则该数为缺失值。"><a href="#方法1：直接排序，在遍历一遍数组，如果该数与下标不匹配，则该数为缺失值。" class="headerlink" title="方法1：直接排序，在遍历一遍数组，如果该数与下标不匹配，则该数为缺失值。"></a>方法1：直接排序，在遍历一遍数组，如果该数与下标不匹配，则该数为缺失值。</h4></li><li><p>方法2：哈希表，遍历一次数组，将数置入哈希表中，第二次遍历[0..n]看是否在哈希表中，不在则为缺失值。</p></li><li><p>方法3：位运算，由位运算特性可知，一个数和自身进行异或运算等于0，一个数与0异或得出还是这个数自身。所以我们可以先求出[0..n]的异或值，再与数组中的数一一异或，最后得出的数组就是缺失值。</p></li><li><p>方法4：直接用高斯等差数列公式求[0..n]的总和，再减去数组总和，得出的差就是缺失值。</p></li></ul><div class="table-container"><table><thead><tr><th>方法</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>直接排序</td><td>N<em>logN+N     O(N </em> logN)</td><td>O(1)或O(N)  取决于使用的排序算法</td></tr><tr><td>哈希表</td><td>N次插入操作，最多N+1次查询 O(N) 查询和插入操作都是O(1)</td><td>O(N)</td></tr><tr><td>位运算</td><td>O(N)</td><td>O(1)</td></tr><tr><td>数列求和</td><td>O(N) ： 求数组总和</td><td>O(1)</td></tr></tbody></table></div><p><code>这里只给出位运算的解法：</code></p><h4 id="代码：-7"><a href="#代码：-7" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> miss=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            miss^=nums[i];</span><br><span class="line">            miss^=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> miss;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="693-交替位二进制数"><a href="#693-交替位二进制数" class="headerlink" title="693. 交替位二进制数"></a><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">693. 交替位二进制数</a></h3><h4 id="题目描述：-9"><a href="#题目描述：-9" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。</p><p>示例 1:</p><blockquote><p>输入: 5<br>输出: True<br>解释:<br>5的二进制数是: 101</p></blockquote><h4 id="题解：-6"><a href="#题解：-6" class="headerlink" title="题解："></a>题解：</h4><blockquote><p>如果n是交替位二进制数，则n=n&amp;(n&gt;&gt;1)得到全1的二进制数字，所以n+1得出最高位为1，其余位为0的二进制数字，那么n&amp;n+1就得出全0。要注意的是为防止溢出n+1要用长整数类型。其实执行n&amp;(n+1)为了验证n=n&amp;(n&gt;&gt;1)是否为全1.</p><p><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/solution/binary-number-with-alternating-bits-by-ikaruga/">参考题解</a></p></blockquote><h4 id="代码：-8"><a href="#代码：-8" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        n = (n ^ (n &gt;&gt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> (n &amp; ((<span class="keyword">long</span>)n + <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="476-数字的补数"><a href="#476-数字的补数" class="headerlink" title="476. 数字的补数"></a><a href="https://leetcode-cn.com/problems/number-complement/">476. 数字的补数</a></h3><h4 id="题目描述：-10"><a href="#题目描述：-10" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</p><p>示例 1:</p><blockquote><p>输入: 5<br>输出: 2<br>解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。</p></blockquote><h4 id="题解：-7"><a href="#题解：-7" class="headerlink" title="题解："></a>题解：</h4><blockquote><ol><li>当然也可以统计num除掉前导0后有多少位01，然后得出一个同样位数的全1串与num异或得出补数。</li><li>遍历数字num的每一位，若是0，就加上相应的权值，num每次右移一位直至为0.</li></ol></blockquote><h4 id="代码：-9"><a href="#代码：-9" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//第一种 </span></span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=num;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            num/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1&lt;&lt;cnt要取长整型防止溢出</span></span><br><span class="line">        <span class="keyword">return</span> n^(<span class="keyword">long</span>(<span class="number">1</span>&lt;&lt;cnt)<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二种</span></span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(num&amp;<span class="number">1</span>))</span><br><span class="line">                ans+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            ++i;</span><br><span class="line">            num/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcod刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题---二分查找</title>
      <link href="/2020/07/24/Binary-Search/"/>
      <url>/2020/07/24/Binary-Search/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode刷题—-二分查找"><a href="#leetcode刷题—-二分查找" class="headerlink" title="leetcode刷题—-二分查找"></a>leetcode刷题—-二分查找</h1><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h2><blockquote><p>二分查找也常被称为二分法或者折半查找，每次查找时通过将待查找区间分成两部分并只取一部分继续查找，将查找的复杂度大大减少。</p><p>二分查找也可以看作双指针的一种特殊情况，但我们一般会将二者区分。双指针类型的题，指针通常是一步一步移动的，而在二分查找里，指针每次移动半个区间长度。</p><p>具体到代码上，二分查找时区间的左右端取开区间还是闭区间在绝大多数时候都可以，因此，有时会容易搞不清楚如何定义区间开闭性。这里提供两个小诀窍，第一是尝试熟练使用一种写法，比如左闭右开（满足 C++、Python 等语言的习惯）或左闭右闭（便于处理边界条件），尽量只保持这一种写法；第二是在刷题时思考如果最后区间只剩下一个数或者两个数，自己的写法是否会陷入死循环，如果某种写法无法跳出死循环，则考虑尝试另一种写法。<br><a id="more"></a><br>例题：</p></blockquote><h4 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a><a href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a></h4><p>题目描述：</p><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1:</p><blockquote><p>输入: 4<br>输出: 2</p></blockquote><p>示例 2:</p><blockquote><p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。</p></blockquote><p>题解：</p><p>我们需要在区间[0,x]中查找一个数mid，使得<strong>mid=x/mid</strong>。这里采用左闭右闭区间。</p><p>设左右指针<strong>l</strong>和<strong>r</strong>，初始时，l=1，r=x；三种情况</p><p>​                    <strong><code>mid=(l+r)/2</code></strong></p><ol><li>如果<strong>x/mid = mid</strong>, 返回mid</li><li>如果<strong>x/mid &gt; mid ， r = mid - 1</strong></li><li>如果<strong>x/mid &lt; mid ， l = mid + 1</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> l=<span class="number">1</span>,r=x,mid,<span class="built_in">sqrt</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">sqrt</span>=x/mid;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">sqrt</span>==mid)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(mid&lt;<span class="built_in">sqrt</span>)</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另解（牛顿迭代法）：</p><p>牛顿迭代法，</p><script type="math/tex; mode=display">X_(n+1)=X_n - f(X_n)/f^、(X_n)</script><script type="math/tex; mode=display">定义f(x) = x^2 - a = 0</script><script type="math/tex; mode=display">迭代公式为X_(n+1) = (X_n + a/X_n)/2</script><blockquote><p>注意 : 这里为了防止 int 超上界，我们使用 long 来存储乘法结果。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x = a;</span><br><span class="line">    <span class="keyword">while</span> (x * x &gt; a) &#123;</span><br><span class="line">    x = (x + a / x) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h4><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><p>示例 1:</p><blockquote><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: [-1,-1]</p></blockquote><p>题解：</p><blockquote><p>这道题可以看作是自己实现 C++ 里的 lower_bound 和 upper_bound 函数。这里我们尝试<br>使用左闭右开的写法，当然左闭右闭也可以。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//查找target在数组中的最小索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//此处是左闭右开区间</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>(),mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找target在数组中的最大索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//此处是左闭右开区间</span></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>(),mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)</span><br><span class="line">                r=mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lower=lower_bound(nums,target);</span><br><span class="line">        <span class="keyword">int</span> upper=upper_bound(nums,target)<span class="number">-1</span>;<span class="comment">//由于此处是左闭右开区间，所以upper要减一</span></span><br><span class="line">        <span class="keyword">if</span>(lower==nums.<span class="built_in">size</span>()||nums[lower]!=target)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            <span class="keyword">return</span> &#123;lower,upper&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a></h4><p>题目描述：</p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p><p>示例 1:</p><blockquote><p>输入: nums = [2,5,6,0,0,1,2], target = 0<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: nums = [2,5,6,0,0,1,2], target = 3<br>输出: false<br>进阶:</p></blockquote><ul><li>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。</li><li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</li></ul><p>题解：</p><p>由于是升序数组的旋转数组，那么有可能一半的区间为升序的。</p><p>注意，因为数组存在重复数字，如果中点和左端的数字相同，我们并不能确定是左区间全部<br>相同，还是右区间完全相同。在这种情况下，我们可以简单地将左端点右移一位，然后继续进行<br>二分查找</p><ol><li>当<strong>nums[mid] == nums[l]</strong>时，无法判断哪个区间是升序的，将左指针右移</li><li>当<strong>nums[mid] &lt;= nums[r]</strong>时，右区间是升序的，若<strong>nums[mid]&lt;target&lt;=nums[r] ,  l=mid+1,否则，在左区间，r=mid-1</strong></li><li>当<strong>nums[mid] &gt; nums[l]</strong>时，左区间是升序的，若<strong>nums[l]&lt;=target&lt;nums[mid] ,  r=mid-1,否则，在右区间，l=mid+1</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//线性搜索</span></span><br><span class="line">    <span class="comment">/*bool search(vector&lt;int&gt;&amp; nums, int target) &#123;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;nums.size();++i)</span></span><br><span class="line"><span class="comment">            if(nums[i]==target)</span></span><br><span class="line"><span class="comment">                return true;</span></span><br><span class="line"><span class="comment">        return false;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>,mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//无法区分哪个区间是升序的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[l]==nums[mid])</span><br><span class="line">                ++l;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//代表左边区间是升序的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;nums[l])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;=nums[l]&amp;&amp;target&lt;nums[mid])<span class="comment">//target落在[l,mid)区间</span></span><br><span class="line">                    r=mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//代表右边区间是升序的</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&lt;=nums[r])<span class="comment">//target落在(mid,r]区间</span></span><br><span class="line">                    l=mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a></h4><p>题目描述：</p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>请找出其中最小的元素。</p><p>注意数组中可能存在重复的元素。</p><p>示例 1：</p><blockquote><p>输入: [1,3,5]<br>输出: 1</p></blockquote><p>示例 2：</p><blockquote><p>输入: [2,2,2,0,1]<br>输出: 0</p></blockquote><p>题解：</p><p><img src="/2020/07/24/Binary-Search/1.png" alt="1"></p><p>观察图可得，设数组最右端的值为x，最小值为min，可知min右边的数一定小于等于x，左边的数一定大于等于x。左右指针l和r，中间指针mid。nums[mid]与nums[r]比较有三种情况。</p><ol><li><strong>nums[mid] &gt; nums[r]</strong>，表明nums[mid]为最小值min左边的数，此时，最小值在<strong>(mid,r]</strong>区间内，即右区间，左区间可以忽略，移动左指针<strong>l = mid + 1</strong>。</li><li><strong>nums[mid] &lt; nums[r]</strong>，表明nums[mid]为最小值min右边的数，此时，最小值在<strong>[l,mid]</strong>区间内，左区间，右区间可以忽略，移动右指针<strong>r = mid </strong>。</li><li><strong>nums[mid] = nums[r]</strong>，无法确定nums[mid]在min的左边还是右边，由于nums[mid]=nums[r]，所以可以移动右指针<strong>r=r-1</strong>来缩小范围。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//线性查找 O(n)</span></span><br><span class="line">    <span class="comment">/*int findMin(vector&lt;int&gt;&amp; nums) &#123;</span></span><br><span class="line"><span class="comment">        int Min=INT_MAX;</span></span><br><span class="line"><span class="comment">        for(int num:nums)</span></span><br><span class="line"><span class="comment">            Min=min(Min,num);</span></span><br><span class="line"><span class="comment">        return Min;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序 O(log N)</span></span><br><span class="line">    <span class="comment">/*int findMin(vector&lt;int&gt;&amp; nums) &#123;</span></span><br><span class="line"><span class="comment">        sort(nums.begin(),nums.end());</span></span><br><span class="line"><span class="comment">        return nums[0];</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>,mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;nums[r])</span><br><span class="line">                r=mid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;nums[r])</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                --r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a></p><p>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</p><p>示例 1:</p><blockquote><p>输入: [1,1,2,3,3,4,4,8,8]<br>输出: 2</p></blockquote><p>示例 2:</p><blockquote><p>输入: [3,3,7,7,10,11,11]<br>输出: 10<br>注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。</p></blockquote><p>题解：</p><p>注意索引的奇偶与独立数出现前后的关系。</p><ol><li>独立数出现之<strong>前</strong>，奇数索引与其<strong>前一位</strong>偶数索引的值相同或者偶数索引于其<strong>后一位</strong>奇数索引的值相同</li><li>独立数出现之<strong>后</strong>，奇数索引与其<strong>后一位</strong>偶数索引的值相同或者偶数索引于其<strong>前一位</strong>奇数索引的值相同</li></ol><p>此时，通过设左右指针和中间指针l、r、mid</p><ul><li>若mid指针满足<strong>情况1</strong>，则独立数出现在mid的右边，将左指针l根据mid的奇偶来移动</li><li>若mid指针满足<strong>情况2</strong>，则独立数出现在mid的左边，将右指针r根据mid的奇偶来移动</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>=nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="built_in">size</span><span class="number">-1</span>,mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mid%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]==nums[mid<span class="number">-1</span>])<span class="comment">//left</span></span><br><span class="line">                    r=mid<span class="number">-2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]==nums[mid+<span class="number">1</span>])<span class="comment">//right</span></span><br><span class="line">                    l=mid+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid]==nums[mid<span class="number">-1</span>])<span class="comment">//right</span></span><br><span class="line">                    l=mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]==nums[mid+<span class="number">1</span>])<span class="comment">//left</span></span><br><span class="line">                    r=mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></p><p>题目描述：</p><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p>示例 1:</p><blockquote><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>则中位数是 2.0</p></blockquote><p>示例 2:</p><blockquote><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>则中位数是 (2 + 3)/2 = 2.5</p></blockquote><p>题解：</p><h4 id="方法1：直观的可以想到，开辟一个新数组，直接将两个数组归并，并根据长度的奇偶来返回结果"><a href="#方法1：直观的可以想到，开辟一个新数组，直接将两个数组归并，并根据长度的奇偶来返回结果" class="headerlink" title="方法1：直观的可以想到，开辟一个新数组，直接将两个数组归并，并根据长度的奇偶来返回结果"></a>方法1：直观的可以想到，开辟一个新数组，直接将两个数组归并，并根据长度的奇偶来返回结果</h4><p>假设两个数组长度分别为n和m</p><script type="math/tex; mode=display">时间复杂度=O(n+m)</script><script type="math/tex; mode=display">空间复杂度=O(n+m)</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> size1=nums1.<span class="built_in">size</span>(),size2=nums2.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">int</span> i,j,k;</span><br><span class="line">       i=j=k=<span class="number">0</span>;</span><br><span class="line">       <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(size1+size2,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(i&lt;size1&amp;&amp;j&lt;size2)</span><br><span class="line">           nums[k++]=nums1[i]&lt;=nums2[j]?nums1[i++]:nums2[j++];   </span><br><span class="line">       <span class="keyword">while</span>(i&lt;size1)</span><br><span class="line">           nums[k++]=nums1[i++];</span><br><span class="line">       <span class="keyword">while</span>(j&lt;size2)</span><br><span class="line">           nums[k++]=nums2[j++];</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>((size1+size2)%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> nums[(size1+size2)/<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">else</span>    </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">double</span>(nums[(size1+size2)/<span class="number">2</span><span class="number">-1</span>]+nums[(size1+size2)/<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="方法2：并不需要申请数组，并且合并两个数组，只需找到中位数位置即可（其实就是归并，但是不需要存储整个数组）"><a href="#方法2：并不需要申请数组，并且合并两个数组，只需找到中位数位置即可（其实就是归并，但是不需要存储整个数组）" class="headerlink" title="方法2：并不需要申请数组，并且合并两个数组，只需找到中位数位置即可（其实就是归并，但是不需要存储整个数组）"></a>方法2：并不需要申请数组，并且合并两个数组，只需找到中位数位置即可（其实就是归并，但是不需要存储整个数组）</h4><script type="math/tex; mode=display">时间复杂度=O(n+m)</script><script type="math/tex; mode=display">空间复杂度=O(1)</script><blockquote><p>当长度的奇偶性不同时，对应的代码也不同，将其分为两种情况。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,k,median_index;</span><br><span class="line">        <span class="keyword">double</span> median_value;</span><br><span class="line">        <span class="keyword">int</span> size1=nums1.<span class="built_in">size</span>(),size2=nums2.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((size1+size2)%<span class="number">2</span>==<span class="number">1</span>)<span class="comment">//两个数组总长度为奇数，中位数为第(size1+size2)/2+1个数</span></span><br><span class="line">        &#123;</span><br><span class="line">            median_index=(size1+size2)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            i=j=<span class="number">0</span>;k=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;size1&amp;&amp;j&lt;size2&amp;&amp;k&lt;=median_index)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i]&lt;nums2[j])</span><br><span class="line">                    median_value=nums1[i++];</span><br><span class="line">                <span class="keyword">else</span>    </span><br><span class="line">                    median_value=nums2[j++];</span><br><span class="line">                ++k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=median_index&amp;&amp;i&lt;size1)</span><br><span class="line">                <span class="keyword">for</span>(;k&lt;=median_index;)</span><br><span class="line">                    median_value=nums1[i++],++k;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=median_index&amp;&amp;j&lt;size2)</span><br><span class="line">                <span class="keyword">for</span>(;k&lt;=median_index;)</span><br><span class="line">                    median_value=nums2[j++],++k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span><span class="comment">//总长度为偶数，中位数为中间两数之和的一半</span></span><br><span class="line">        &#123;</span><br><span class="line">            median_index=(size1+size2)/<span class="number">2</span>;</span><br><span class="line">            i=j=<span class="number">0</span>;k=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;size1&amp;&amp;j&lt;size2&amp;&amp;k&lt;=median_index)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i]&lt;nums2[j])</span><br><span class="line">                    median_value=nums1[i++];</span><br><span class="line">                <span class="keyword">else</span>    </span><br><span class="line">                    median_value=nums2[j++];</span><br><span class="line">                ++k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=median_index&amp;&amp;i&lt;size1)</span><br><span class="line">                <span class="keyword">for</span>(;k&lt;=median_index;)</span><br><span class="line">                    median_value=nums1[i++],++k;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;=median_index&amp;&amp;j&lt;size2)</span><br><span class="line">                <span class="keyword">for</span>(;k&lt;=median_index;)</span><br><span class="line">                    median_value=nums2[j++],++k;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i&lt;size1&amp;&amp;(j&lt;size2&amp;&amp;nums1[i]&lt;=nums2[j]||j&gt;=size2))</span><br><span class="line">                median_value=<span class="keyword">double</span>(median_value+nums1[i])/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j&lt;size2&amp;&amp;(i&lt;size1&amp;&amp;nums2[j]&lt;=nums1[i]||i&gt;=size1))</span><br><span class="line">                median_value=<span class="keyword">double</span>(median_value+nums2[j])/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> median_value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>将以上奇偶情况合并为一种情况</p><p>1.当长度为奇数时，需要找到第<strong>(n+m)/2</strong>位元素（从0开始）</p><p>2.当长度为偶数时，需要找到第<strong>(n+m)/2-1和(n+m)/2</strong>位元素（从0开始）</p><p>所以奇偶情况都要找到第<strong>(n+m)/2</strong>位元素（从0开始），所以可以用两个变量now、past记录当前找的元素以及上次找的元素</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m=nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> index1=<span class="number">0</span>,index2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> past=<span class="number">0</span>,now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=(n+m)/<span class="number">2</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            past=now;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(index2&gt;=m||index1&lt;n&amp;&amp;nums1[index1]&lt;=nums2[index2])<span class="comment">//nums2数组遍历完，或则nums1数组当前元素比nums2当前元素要小</span></span><br><span class="line">                now=nums1[index1++];</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//其他情况</span></span><br><span class="line">                now=nums2[index2++];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据长度奇偶性返回结果</span></span><br><span class="line">        <span class="keyword">if</span>((n+m)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">double</span>(past+now)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">double</span>(now);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="方法三：二分查找"><a href="#方法三：二分查找" class="headerlink" title="方法三：二分查找"></a>方法三：二分查找</h4><p>根据中位数定义：</p><ul><li><p>n+m为奇数时，中位数为第<strong>(n+m)/2</strong>位数（从0开始）</p></li><li><p>n+m为偶数时，中位数为第<strong>(n+m)/2-1和(n+m)/2</strong>位数（从0开始）</p><blockquote><p>因此问题可以转化为在两个数组中找第k小的数，其中k为<strong>(n+m)/2或者(n+m)/2+1</strong></p></blockquote></li></ul><blockquote><p>假设两个有序数组分别是 A 和 B。要找到第k个元素，我们可以比较 A[k/2-1]和 B[k/2−1]，其中/表示整数除法。由于 A[k/2−1] 和 B[k/2−1] 的前面分别有 A[0..k/2−2] 和 B[0..k/2−2]，即 k/2-1个元素，对于A[k/2−1] 和 B[k/2−1] 中的较小值，最多只会有 k/2-2(k/2−1)+(k/2−1)≤k/2−2 个元素比它小，那么它就不能是第 k 小的数了。</p></blockquote><p>A[k/2-1]与B[k/2-1]的三种比较情况</p><ul><li>当<strong>A[k/2-1] &lt; B[k/2-1]</strong>时，则比<strong>A[k/2-1]</strong>最多有A的前k/2-1个数和B的前k/2-1个数，最多只有k-2个数，因此A[k/2-1]不可能是第k个数，所以A[0]到A[k/2-1]也不可能是第k个数，可以全部排除</li><li>当<strong>A[k/2-1] &gt; B[k/2-1]</strong>时，则比<strong>B[k/2-1]</strong>最多有A的前k/2-1个数和B的前k/2-1个数，最多只有k-2个数，因此B[k/2-1]不可能是第k个数，所以B[0]到B[k/2-1]也不可能是第k个数，可以全部排除。</li><li>当<strong>A[k/2-1] = B[k/2-1]</strong>时，可以归为第一种情况</li></ul><p>三种特殊情况：</p><ul><li>当<strong>k=1</strong>时，只需找出两数组开头元素的最小值。</li><li>当其中一个数组为空时，只需找出另一个数组的第k个元素</li><li>当我们排除了一些元素时，k要减去被除元素的个数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助函数，查找两个数组中的第k小元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getKthElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m=nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//越界情况</span></span><br><span class="line">            <span class="keyword">if</span>(i==n)<span class="comment">//nums1数组为空</span></span><br><span class="line">                <span class="keyword">return</span> nums2[j+k<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(j==m)<span class="comment">//nums2数组为空</span></span><br><span class="line">                <span class="keyword">return</span> nums1[i+k<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)<span class="comment">//k=1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[i],nums2[j]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//避免索引越界，若剩下的元素不够k/2-1个，则将索引置为数组最后一个索引</span></span><br><span class="line">            <span class="keyword">int</span> index1=<span class="built_in">min</span>(i+k/<span class="number">2</span><span class="number">-1</span>,n<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">int</span> index2=<span class="built_in">min</span>(j+k/<span class="number">2</span><span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums1[index1]&lt;=nums2[index2])<span class="comment">//情况1和3</span></span><br><span class="line">            &#123;</span><br><span class="line">                k-=index1-i+<span class="number">1</span>;<span class="comment">//k减去排除元素个数</span></span><br><span class="line">                i=index1+<span class="number">1</span>;<span class="comment">//排除nums1数组中index1左边的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span><span class="comment">//情况2</span></span><br><span class="line">            &#123;</span><br><span class="line">                k-=index2-j+<span class="number">1</span>;<span class="comment">//k减去排除元素个数</span></span><br><span class="line">                j=index2+<span class="number">1</span>;<span class="comment">//排除nums1数组中index2左边的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据长度奇偶性返回结果</span></span><br><span class="line">        <span class="keyword">int</span> size1=nums1.<span class="built_in">size</span>(),size2=nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>((size1+size2)%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> getKthElement(nums1,nums2,(size1+size2)/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">double</span>( getKthElement(nums1,nums2,(size1+size2)/<span class="number">2</span>) + getKthElement(nums1,nums2,(size1+size2)/<span class="number">2</span>+<span class="number">1</span>) )/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题---双指针</title>
      <link href="/2020/07/23/double-pointer/"/>
      <url>/2020/07/23/double-pointer/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcod刷题—-双指针"><a href="#leetcod刷题—-双指针" class="headerlink" title="leetcod刷题—-双指针"></a>leetcod刷题—-双指针</h1><h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h3><blockquote><p><code>双指针</code>有可能用于遍历数组（或者链表），通常有两种形式：</p><ol><li>两个指针指向同一个数组中不同的元素（两指针遍历方向可能相同也可能不同）</li><li>两个指针指向不同的数组<a id="more"></a><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2></li></ol></blockquote><h3 id="指向同一数组不同元素："><a href="#指向同一数组不同元素：" class="headerlink" title="指向同一数组不同元素："></a>指向同一数组不同元素：</h3><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167.两数之和</a></p><p>题目描述：</p><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><ol><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ol><p>示例:</p><blockquote><p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><p>题解：</p><p>因为数组已经排序，可以用两个指针l、r分别从数组两边出发，遍历搜索，</p><ol><li>若两数之和大于目标值，则可以将<code>r</code>指针左移；</li><li>若两数之和小于目标值，则可以将<code>l</code>指针右移；</li><li>若两数之和等目标值，返回两元素结束函数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=numbers.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[l]+numbers[r]&gt;target)</span><br><span class="line">                --r;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[l]+numbers[r]&lt;target)</span><br><span class="line">                ++l;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;l+<span class="number">1</span>,r+<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="指向不同数组："><a href="#指向不同数组：" class="headerlink" title="指向不同数组："></a>指向不同数组：</h3><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></p><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><p>说明:</p><ul><li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。</li><li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</li></ul><p>示例:</p><blockquote><p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p></blockquote><p>输出: [1,2,2,3,5,6]</p><p>题解：</p><p>两个数组已经排好序，只需要将两个指针指向两个数组，按顺序放入对应元素即可。有两中方法：</p><ol><li>从两个数组左边开始（需要额外空间，因为不能直接放入nums1数组，可能会覆盖原来的元素）</li><li>从两个数组右边开始</li></ol><p>这里采取第二中方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = m-- + n-- - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) </span><br><span class="line">            nums1[pos--] = nums1[m] &gt; nums2[n]? nums1[m--]: nums2[n--];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) </span><br><span class="line">            nums1[pos--] = nums2[n--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>指向链表：</p><h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><p>题目描述：</p><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p>示例 1：</p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p><img src="/2020/07/23/double-pointer/circularlinkedlist.png" alt="circularlinkedlist"></p><p>题解：</p><p><code>快慢指针</code>两个指针<code>fast</code>,<code>slow</code>,从链表头出发，每次<code>fast</code>指针走两步，<code>slow</code>走一步，若<code>fast</code>指针能走到链表尾，则说明链表无环，否则fast可以无限走下去，会在某时刻与<code>slow</code>相遇，代表有环。我们将<code>slow</code>指针重新指向链表头，让<code>fast</code>和<code>slow</code>指针每次都走一步。当<code>fast</code>和<code>slow</code>第二次相遇时，此时这个节点为环的起点。具体代码如下：</p><p>链表结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow,*fast;</span><br><span class="line">        slow=fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;<span class="comment">//fast走两步</span></span><br><span class="line">            slow=slow-&gt;next; <span class="comment">//slow走一步</span></span><br><span class="line">            <span class="keyword">if</span>(slow==fast)<span class="comment">//第一次相遇</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!fast||!fast-&gt;next)<span class="comment">//fast走到链表尾</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        slow=head;<span class="comment">//将slow重新移到链表头</span></span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)<span class="comment">//slow和fast每次都走一步</span></span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次相遇</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="指向同一数组，且两指针移动方向相同"><a href="#指向同一数组，且两指针移动方向相同" class="headerlink" title="指向同一数组，且两指针移动方向相同"></a>指向同一数组，且两指针移动方向相同</h3><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><p>题目描述：</p><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p><p>示例：</p><blockquote><p>输入: S = “ADOBECODEBANC”, T = “ABC”<br>输出: “BANC”<br>说明：</p></blockquote><ul><li>如果 S 中不存这样的子串，则返回空字符串 “”。</li><li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p>题解：</p><p><strong>滑动窗口求解</strong> ，两个指针<strong>l</strong>和<strong>r</strong>都是从最左端向最右端移动</p><p>用数组chars和flag记录字符串t的字符情况</p><ol><li>移动右指针，根据字符来处理chars和flag数组，cnt记录已经包含字符串t的字符个数</li><li>当cnt等于t.size(),尝试移动左指针<strong>l</strong>，缩小范围，min_size, min_l 用于记录最优解</li><li>若min_size &gt; s.size()返回空串，否则返回s.substr(min_l , min_size)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> chars[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> flag[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计字符串t中的字符情况        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();++i)</span><br><span class="line">            flag[t[i]]=<span class="number">1</span>,++chars[t[i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,cnt=<span class="number">0</span>,min_l,min_size=s.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(;r&lt;s.<span class="built_in">size</span>();++r)<span class="comment">//遍历字符串s</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[s[r]])</span><br><span class="line">                <span class="keyword">if</span>(--chars[s[r]]&gt;=<span class="number">0</span>)</span><br><span class="line">                    ++cnt;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//仅当字符串t中所有字符被包含时</span></span><br><span class="line">            <span class="comment">//才尝试移动左指针l</span></span><br><span class="line">            <span class="keyword">while</span>(cnt==t.<span class="built_in">size</span>())<span class="comment">//如果字符串t中所有字符已包含</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//尝试移动左指针</span></span><br><span class="line">                <span class="keyword">if</span>(r-l+<span class="number">1</span>&lt;min_size)</span><br><span class="line">                &#123;</span><br><span class="line">                    min_l=l;</span><br><span class="line">                    min_size=r-l+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//因为左指针移动，导致t中字符缺失</span></span><br><span class="line">                <span class="keyword">if</span>(flag[s[l]]&amp;&amp;++chars[s[l]]&gt;<span class="number">0</span>)</span><br><span class="line">                    --cnt;</span><br><span class="line">                <span class="comment">//移动左指针</span></span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不存在就返回空字符串</span></span><br><span class="line">        <span class="comment">//否则返回</span></span><br><span class="line">        <span class="keyword">return</span> min_size&gt;s.<span class="built_in">size</span>()?<span class="string">&quot;&quot;</span>:s.substr(min_l,min_size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="巩固练习："><a href="#巩固练习：" class="headerlink" title="巩固练习："></a>巩固练习：</h2><h4 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633. 平方数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/">633. 平方数之和</a></h4><p>题目描述：</p><p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。</p><p>示例1:</p><blockquote><p>输入: 5<br>输出: True<br>解释: 1 <em> 1 + 2 </em> 2 = 5</p></blockquote><p>示例2:</p><blockquote><p>输入: 3<br>输出: False</p></blockquote><p>题解：</p><p>双指针，<strong>l</strong>和<strong>r</strong>分别指向0和sqrt(c)从两边向中间移动（细节：需要用long存l和r，否则会溢出）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l=<span class="number">0</span>,r=<span class="built_in">sqrt</span>(c),total;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            total=l*l+r*r;</span><br><span class="line">            <span class="keyword">if</span>(total&gt;c)</span><br><span class="line">                --r;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(total&lt;c)</span><br><span class="line">                ++l;</span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l&lt;=r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">680. 验证回文字符串 Ⅱ</a></h4><p>题目描述：</p><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><p>示例 1:</p><blockquote><p>输入: “aba”<br>输出: True</p></blockquote><p>示例 2:</p><blockquote><p>输入: “abca”<br>输出: True<br>解释: 你可以删除c字符。</p></blockquote><p>题解：</p><p><strong>双指针</strong>，左右指针l和r，如果两个指针所指字符相同，则两指针往中间移动，否则，只能移动其中一侧的指针，此时对应两种情况，移动l和移动r（借助辅助函数实现）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//检测去掉其中一个字符后，剩下的字符串是否为回文串</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l]!=s[r])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ++l;--r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>=s.<span class="built_in">size</span>(),l=<span class="number">0</span>,r=<span class="built_in">size</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[l]==s[r])<span class="comment">//左右两个字符相同</span></span><br><span class="line">                ++l,--r;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//去掉左指针所指字符或者去掉右指针所指字符</span></span><br><span class="line">                <span class="keyword">return</span> helper(s,l+<span class="number">1</span>,r)||helper(s,l,r<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a></h4><p>题目描述：</p><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p><p>示例 1:</p><blockquote><p>输入:<br>s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]</p><p>输出:<br>“apple”</p></blockquote><p>题解：</p><p>遍历vector<string> d,每次调用辅助函数，检测s是否可以通过删除字符得到对应字符串，若可以则用ans记录，辅助函数，简单的双指针应用，类似于合并数组。</string></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s1,<span class="built_in">string</span> s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s1.<span class="built_in">size</span>()&amp;&amp;j&lt;s2.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==s2[j])</span><br><span class="line">                ++i,++j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j==s2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findLongestWord</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:d)</span><br><span class="line">            <span class="keyword">if</span>(helper(s,str)&amp;&amp;(str.<span class="built_in">size</span>()&gt;ans.<span class="built_in">size</span>()||str.<span class="built_in">size</span>()==ans.<span class="built_in">size</span>()&amp;&amp;str&lt;ans))</span><br><span class="line">                ans=str;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h4><p>题目描述：</p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p>示例：</p><blockquote><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p><p>返回链表 4-&gt;5.</p></blockquote><p>题解：</p><p>倒数第k个，也就是第n-k个（n为链表长度），问题是如何得到这个n，可以先遍历一次链表，得到n，再走n-k步，第二种方法是，先让first走k步，然后second从链表头开始和first一起走到first为链表尾为止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *first=head;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//first先走k步</span></span><br><span class="line">        <span class="keyword">while</span>(++i&lt;=k&amp;&amp;first)</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果链表没有k个节点，返回NULL</span></span><br><span class="line">        <span class="keyword">if</span>(!first&amp;&amp;i&lt;k)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *second=head;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">//接下来first和second一起走n-k步（n为链表长度）</span></span><br><span class="line">        <span class="keyword">while</span>(first)</span><br><span class="line">        &#123;</span><br><span class="line">            first=first-&gt;next;</span><br><span class="line">            second=second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0-1背包及其扩展</title>
      <link href="/2020/07/14/0-1-knapsack/"/>
      <url>/2020/07/14/0-1-knapsack/</url>
      
        <content type="html"><![CDATA[<h1 id="0-1背包及其扩展"><a href="#0-1背包及其扩展" class="headerlink" title="0-1背包及其扩展"></a>0-1背包及其扩展</h1><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><blockquote><p>现有n件物品和一个容量为c的背包。第i件物品的重量是重量为w[i]，价值是v[i]。已知对于一件物品必须选择取（用1表示）或者不取（用0表示），且每件物品只能被取一次（这就是“0-1”的含义）。求放置哪些物品进背包，可使这些物品的重量总和不超过背包容量，且价值总和最大。<br><a id="more"></a></p><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h3></blockquote><p>动态规划。用一个矩阵L来保存结果。L[ i ] [ j ] 代表用序号不大于i的物品，背包容量最大为j，所能存储的物品的最大价值。L[ n ] [ c ]就是问题所求的最大值。</p><h3 id="递推公式"><a href="#递推公式" class="headerlink" title="递推公式"></a>递推公式</h3><script type="math/tex; mode=display">L[i][j]=\begin{cases}0,& \text{i=0 or j=0} \\L[i-1][j],& \text{w[i]>j(第i个物品放不下)}\\\max(L[i-1][j],L[i-1][j-w[i]]+v[i]),&\text{w[i]<=j(放与不放选取价值最大者)} \end{cases}</script><h3 id="主要代码："><a href="#主要代码：" class="headerlink" title="主要代码："></a>主要代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Knapsack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c + <span class="number">1</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">L[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (weight[i - <span class="number">1</span>] &lt;= j)</span><br><span class="line">L[i][j] = <span class="built_in">max</span>(value[i - <span class="number">1</span>] + L[i - <span class="number">1</span>][j - weight[i - <span class="number">1</span>]], L[i - <span class="number">1</span>][j]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">L[i][j] = L[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;max value:&quot;</span>&lt;&lt;L[n][c]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;how to choose:&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">Print(n,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0-1背包 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">int</span> L[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> weight[maxn];</span><br><span class="line"><span class="keyword">int</span> value[maxn];</span><br><span class="line"><span class="keyword">int</span> n,c; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><span class="comment">//输出选择物品的方案 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(L[i][j]==L[i<span class="number">-1</span>][j])</span><br><span class="line">Print(i<span class="number">-1</span>,j);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Print(i<span class="number">-1</span>,j-weight[i]);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No.&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;,weight:&quot;</span>&lt;&lt;weight[i]&lt;&lt;<span class="string">&quot;,value:&quot;</span>&lt;&lt;value[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Knapsack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c + <span class="number">1</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">L[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (weight[i - <span class="number">1</span>] &lt;= j)</span><br><span class="line">L[i][j] = <span class="built_in">max</span>(value[i - <span class="number">1</span>] + L[i - <span class="number">1</span>][j - weight[i - <span class="number">1</span>]], L[i - <span class="number">1</span>][j]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">L[i][j] = L[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;max value:&quot;</span>&lt;&lt;L[n][c]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;how to choose:&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">Print(n,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter number of items: &quot;</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter weights: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; weight[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter values: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; value[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Enter capacity: &quot;</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">Knapsack();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展1：0-x背包（x为整数）"><a href="#扩展1：0-x背包（x为整数）" class="headerlink" title="扩展1：0-x背包（x为整数）"></a>扩展1：0-x背包（x为整数）</h2><h3 id="问题描述：-1"><a href="#问题描述：-1" class="headerlink" title="问题描述："></a>问题描述：</h3><blockquote><p>与上面0-1背包问题类似，不过每个物品可以放的数量不受限制，从0到x个（只要放得下），通要求所放物品的最大价值。</p></blockquote><h3 id="算法思路：-1"><a href="#算法思路：-1" class="headerlink" title="算法思路："></a>算法思路：</h3><blockquote><p>同样是动态规划，同样的算法，只不过递推公式有点不一样。</p></blockquote><h3 id="递归公式："><a href="#递归公式：" class="headerlink" title="递归公式："></a>递归公式：</h3><script type="math/tex; mode=display">L[i][j]=\begin{cases}0,& \text{i=0 or j=0} \\max_{0\leq k \leq \lfloor \frac{j}{weight[i]} \rfloor }(L[i-1][j],L[i-1][j-k*w[i]]+k*v[i]),&\text{others} \end{cases}</script><h3 id="主要代码：-1"><a href="#主要代码：-1" class="headerlink" title="主要代码："></a>主要代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Knapsack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c + <span class="number">1</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">L[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> MAX=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=j/weight[i<span class="number">-1</span>];++k)</span><br><span class="line">MAX=<span class="built_in">max</span>(MAX,L[i<span class="number">-1</span>][j-k*weight[i<span class="number">-1</span>]]+k*value[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L[i][j]=MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;max value:&quot;</span>&lt;&lt;L[n][c]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;how to choose:&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">Print(n,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><span class="comment">//输出选择物品的方案 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;=j/weight[i<span class="number">-1</span>];++k)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(L[i][j]==L[i<span class="number">-1</span>][j-k*weight[i<span class="number">-1</span>]]+k*value[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">Print(i<span class="number">-1</span>,j-k*weight[i<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">if</span>(k!=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No.&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;,how many:&quot;</span>&lt;&lt;k&lt;&lt;<span class="string">&quot;,weight:&quot;</span>&lt;&lt;weight[i<span class="number">-1</span>]&lt;&lt;<span class="string">&quot;,value:&quot;</span>&lt;&lt;value[i<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展2：背包问题"><a href="#扩展2：背包问题" class="headerlink" title="扩展2：背包问题"></a>扩展2：背包问题</h2><h3 id="问题描述：-2"><a href="#问题描述：-2" class="headerlink" title="问题描述："></a>问题描述：</h3><blockquote><p>同样是n个物品，c容量，不过物品可以选择放一部分，用分数k表示（0&lt;=k&lt;=1）,求所有存储物品的最大值。</p></blockquote><h3 id="算法思路：-2"><a href="#算法思路：-2" class="headerlink" title="算法思路："></a>算法思路：</h3><p>贪心法，计算每个物品的value与weight的比值，先把比值高的放完，再放比值次高的，直到背包放满。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求树的高度（不限于二叉树）——动态规划</title>
      <link href="/2020/07/14/tree-height/"/>
      <url>/2020/07/14/tree-height/</url>
      
        <content type="html"><![CDATA[<h1 id="求树的高度（不限于二叉树）——动态规划"><a href="#求树的高度（不限于二叉树）——动态规划" class="headerlink" title="求树的高度（不限于二叉树）——动态规划"></a>求树的高度（不限于二叉树）——动态规划</h1><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>每个节点的高度都是其所有子节点中最大的高度加一。所以，我们可以用动态规划，自底向上求高度。</p><h3 id="递推公式："><a href="#递推公式：" class="headerlink" title="递推公式："></a>递推公式：</h3><script type="math/tex; mode=display">height[u]=max(height[v])+1;(v为所有与u的邻接点)</script><a id="more"></a><h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_depth</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//求以u为根结点的树高</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> child_height=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v:adj[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])<span class="comment">//选取子节点中高度最高的 </span></span><br><span class="line">&#123;</span><br><span class="line">get_depth(v);</span><br><span class="line">child_height=<span class="built_in">max</span>(child_height,dp[v]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[u]=child_height; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划求树高</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>;<span class="comment">//最大节点数 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; adj[MAXN];<span class="comment">//邻接表存树 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_depth</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//求以u为根结点的树高</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> child_height=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v:adj[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])<span class="comment">//选取子节点中高度最高的 </span></span><br><span class="line">&#123;</span><br><span class="line">get_depth(v);</span><br><span class="line">child_height=<span class="built_in">max</span>(child_height,dp[v]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[u]=child_height; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num_of_nodes;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入节点个数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;num_of_nodes;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入树边：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num_of_nodes;++i)<span class="comment">//输入num_of_nodes-1条边 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//无向边（u,v） </span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">adj[u].push_back(v);</span><br><span class="line">adj[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化dp和访问标志数组 </span></span><br><span class="line">vis.assign(num_of_nodes+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">dp.assign(num_of_nodes+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">get_depth(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;树高：&quot;</span>&lt;&lt;dp[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共子序列（LCS)</title>
      <link href="/2020/07/14/longest-common-subsquence/"/>
      <url>/2020/07/14/longest-common-subsquence/</url>
      
        <content type="html"><![CDATA[<h1 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h1><p>参考：<a href="https://blog.csdn.net/v_july_v/article/details/6695482#">最长公共子序列（LCS）</a></p><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>  什么是最长公共子序列呢?好比一个数列 S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则S 称为已知序列的最长公共子序列。</p><pre><code>举个例子，如：有两条随机序列，如 1 3 4 5 5 ，and 2 4 5 5 7 6，则它们的最长公共子序列便是：4 5 5。注意最长公共子串（Longest CommonSubstring）和最长公共子序列（LongestCommon Subsequence, LCS）的区别：子串（Substring）是串的一个连续的部分，子序列（Subsequence）则是从不改变序列的顺序，而从序列中去掉任意的元素而获得的新序列；更简略地说，前者（子串）的字符的位置必须连续，后者（子序列LCS）则不必。比如字符串acdfg同akdfc的最长公共子串为df，而他们的最长公共子序列是adf。LCS可以使用动态规划法解决。下文具体描述。</code></pre><a id="more"></a><h3 id="递推公式："><a href="#递推公式：" class="headerlink" title="递推公式："></a>递推公式：</h3><script type="math/tex; mode=display">L(i,j)= \begin{cases} 0, & \text {i=0 or j=0} \\ max(L(i-1,j),L(i,j-1)), & \text{str1[i]}\neq\text{str2[j]} \\L[i-1,j-1]+1, &\text{str1[i]=str2[j]} \end{cases}</script><h3 id="主要代码："><a href="#主要代码：" class="headerlink" title="主要代码："></a>主要代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longest_common_subsquence</span><span class="params">(<span class="built_in">string</span> str1,<span class="built_in">string</span> str2)</span><span class="comment">//最长公共子序列 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=str1.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> c=str2.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">L[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str1[i<span class="number">-1</span>]==str2[j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">direct[i][j]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(L[i<span class="number">-1</span>][j]&gt;L[i][j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i<span class="number">-1</span>][j];</span><br><span class="line">direct[i][j]=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(L[i<span class="number">-1</span>][j]&lt;L[i][j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i][j<span class="number">-1</span>];</span><br><span class="line">direct[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i][j<span class="number">-1</span>];</span><br><span class="line">direct[i][j]=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="string">&quot;和&quot;</span>&lt;&lt;str2&lt;&lt;<span class="string">&quot;最长公共子序列长度：&quot;</span>&lt;&lt;L[r<span class="number">-1</span>][c<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;所有最长公共子序列为：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">get_lcs(r<span class="number">-1</span>,c<span class="number">-1</span>,str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出所有公共子序列 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p:s)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="但是只借助上面这个函数只能得到最优值，为了得到最优解，我们还需要一个direct数组和函数"><a href="#但是只借助上面这个函数只能得到最优值，为了得到最优解，我们还需要一个direct数组和函数" class="headerlink" title="但是只借助上面这个函数只能得到最优值，为了得到最优解，我们还需要一个direct数组和函数"></a>但是只借助上面这个函数只能得到最优值，为了得到最优解，我们还需要一个direct数组和函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_lcs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="built_in">string</span> &amp;str)</span><span class="comment">//根据direct数组得到所有最长公共子序列 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str.<span class="built_in">size</span>()==L[str1.<span class="built_in">size</span>()][str2.<span class="built_in">size</span>()])</span><br><span class="line">s.insert(str);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(direct[i][j]==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">str=str1[i<span class="number">-1</span>]+str;</span><br><span class="line">get_lcs(i<span class="number">-1</span>,j<span class="number">-1</span>,str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(direct[i][j]==<span class="number">1</span>)</span><br><span class="line">get_lcs(i,j<span class="number">-1</span>,str);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(direct[i][j]==<span class="number">3</span>) </span><br><span class="line">get_lcs(i<span class="number">-1</span>,j,str);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span>  s1,s2;</span><br><span class="line">s1=s2=str;</span><br><span class="line">get_lcs(i,j<span class="number">-1</span>,s1);</span><br><span class="line">get_lcs(i<span class="number">-1</span>,j,s2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下面是完整代码："><a href="#下面是完整代码：" class="headerlink" title="下面是完整代码："></a>下面是完整代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">子串（Substring）是串的一个连续的部分</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">子序列（Subsequence）则是从不改变序列的顺序，</span></span><br><span class="line"><span class="comment">而从序列中去掉任意的元素而获得的新序列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>;<span class="comment">//字符串最大长度 </span></span><br><span class="line"><span class="keyword">int</span> L[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> direct[maxn][maxn];<span class="comment">/*direct[i][j]=1代表L[i][j]=L[i][j-1];</span></span><br><span class="line"><span class="comment">direct[i][j]=2代表L[i][j]=L[i-1][j-1]+1;</span></span><br><span class="line"><span class="comment">direct[i][j]=3代表L[i][j]=L[i-1][j];</span></span><br><span class="line"><span class="comment">direct[i][j]=4代表L[i][j]=L[i][j-1]=L[i-1][j];*/</span> </span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s;<span class="comment">//存储所有最长公共子序列 </span></span><br><span class="line"><span class="built_in">string</span> str1,str2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_lcs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="built_in">string</span> &amp;str)</span><span class="comment">//根据direct数组得到所有最长公共子序列 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str.<span class="built_in">size</span>()==L[str1.<span class="built_in">size</span>()][str2.<span class="built_in">size</span>()])</span><br><span class="line">s.insert(str);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(direct[i][j]==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">str=str1[i<span class="number">-1</span>]+str;</span><br><span class="line">get_lcs(i<span class="number">-1</span>,j<span class="number">-1</span>,str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(direct[i][j]==<span class="number">1</span>)</span><br><span class="line">get_lcs(i,j<span class="number">-1</span>,str);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(direct[i][j]==<span class="number">3</span>) </span><br><span class="line">get_lcs(i<span class="number">-1</span>,j,str);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span>  s1,s2;</span><br><span class="line">s1=s2=str;</span><br><span class="line">get_lcs(i,j<span class="number">-1</span>,s1);</span><br><span class="line">get_lcs(i<span class="number">-1</span>,j,s2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longest_common_subsquence</span><span class="params">(<span class="built_in">string</span> str1,<span class="built_in">string</span> str2)</span><span class="comment">//最长公共子序列 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=str1.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> c=str2.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">L[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str1[i<span class="number">-1</span>]==str2[j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">direct[i][j]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(L[i<span class="number">-1</span>][j]&gt;L[i][j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i<span class="number">-1</span>][j];</span><br><span class="line">direct[i][j]=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(L[i<span class="number">-1</span>][j]&lt;L[i][j<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i][j<span class="number">-1</span>];</span><br><span class="line">direct[i][j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">L[i][j]=L[i][j<span class="number">-1</span>];</span><br><span class="line">direct[i][j]=<span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="string">&quot;和&quot;</span>&lt;&lt;str2&lt;&lt;<span class="string">&quot;最长公共子序列长度：&quot;</span>&lt;&lt;L[r<span class="number">-1</span>][c<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;所有最长公共子序列为：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">get_lcs(r<span class="number">-1</span>,c<span class="number">-1</span>,str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出所有公共子序列 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p:s)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入字符串st1:&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str1;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入字符串str2:&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str2;</span><br><span class="line"></span><br><span class="line">longest_common_subsquence(str1,str2); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于图的有关算法</title>
      <link href="/2020/05/19/graph/"/>
      <url>/2020/05/19/graph/</url>
      
        <content type="html"><![CDATA[<h1 id="关于图的有关算法"><a href="#关于图的有关算法" class="headerlink" title="关于图的有关算法"></a>关于图的有关算法</h1><blockquote><p>前言：本文所指的图皆以一个全局二维数组存储，即邻接矩阵，且为<code>有向带权图</code><br>    设int G[maxn][maxn]为邻接矩阵，其中maxn为图能存储的最大顶点数<br>    <code>n：顶点数</code><br>    <code>m：边数</code><br>    <code>借助于一个全局数组visited[maxn]标记顶点是否已经访问</code></p></blockquote><a id="more"></a><h2 id="本文对顶点的访问操作"><a href="#本文对顶点的访问操作" class="headerlink" title="本文对顶点的访问操作"></a>本文对顶点的访问操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问顶点，为了方便简单的输出 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">visited[n]=<span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="图的输入"><a href="#图的输入" class="headerlink" title="图的输入"></a>图的输入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入图 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入图的顶点数和边数</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依次为边的起点，终点，边长</span></span><br><span class="line"><span class="keyword">int</span> start,<span class="built_in">end</span>,len;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依次输入m条边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;start&gt;&gt;<span class="built_in">end</span>&gt;&gt;len;</span><br><span class="line">G[start][<span class="built_in">end</span>]=len;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若为无向图加上下面一句，因为无向图的对称性</span></span><br><span class="line"><span class="comment">//G[end][start]=len; </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常见的算法"><a href="#常见的算法" class="headerlink" title="常见的算法"></a>常见的算法</h1><h2 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以顶点start为起点，广度优先搜索 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(start);</span><br><span class="line">visit(start);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t=q.front();q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[i]&amp;&amp;G[t][i]!=INF)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">visit(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以start顶点为起点，深度优先搜索 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visit(start);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[i]&amp;&amp;G[start][i]!=INF)</span><br><span class="line">&#123;</span><br><span class="line">DFS(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑遍历"><a href="#拓扑遍历" class="headerlink" title="拓扑遍历"></a>拓扑遍历</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓扑搜索</span></span><br><span class="line"><span class="built_in">void</span> Topo()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//统计已经访问的顶点</span></span><br><span class="line"><span class="built_in">int</span> num=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">queue&lt;<span class="built_in">int</span>&gt; q; </span><br><span class="line"></span><br><span class="line"><span class="comment">//各个顶点的入度数 </span></span><br><span class="line"><span class="built_in">int</span> index[maxn]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计各个顶点的入度数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(G[i][j]!=INF)</span><br><span class="line">&#123;</span><br><span class="line">++index[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//入度数为0，放入队列 </span></span><br><span class="line"><span class="keyword">if</span>(index[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> t=q.front();q.pop();</span><br><span class="line"></span><br><span class="line">visit(t);++num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(G[t][i]!=INF&amp;&amp;index[i]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//删除边t-&gt;i</span></span><br><span class="line">--index[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//若i入度为0，将i置于队列中</span></span><br><span class="line"><span class="keyword">if</span>(index[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="最小生成树（Prim）"><a href="#最小生成树（Prim）" class="headerlink" title="最小生成树（Prim）"></a>最小生成树（Prim）</h2><blockquote><p>算法思想：贪心法<br>设图的顶点集为V，已组成连通图的顶点集为X，通过一系列放缩直到<br>当X==V时，算法结束，或者当X！=V时，仍然存在dist【i】==INF，即顶点i无法连接到X，同样结束算法，此时图为非连通图<br>算法中三个数组的作用<br>vis【i】:标志顶点i是否在X中，1：是 0：否<br>prev【i】：X中离顶点i最近的顶点，其中prev【0】=-1（因为初始时，X={0}）<br>dist【i】：顶点i连接prev【i】的最短距离 </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//最小生成树的耗费 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> prev[maxn];</span><br><span class="line"><span class="keyword">int</span> dist[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化三个数组 </span></span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(prev,<span class="number">-1</span>,<span class="keyword">sizeof</span>(prev));</span><br><span class="line"><span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(G[<span class="number">0</span>][i]!=INF)</span><br><span class="line">&#123;</span><br><span class="line">prev[i]=<span class="number">0</span>;</span><br><span class="line">dist[i]=G[<span class="number">0</span>][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prev[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">vis[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行n-1轮放缩，因为顶点0一开始就加入到X了 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t=INF,u=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找V-X中的一点u，其中dist【u】最小， </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j]&amp;&amp;dist[j]&lt;t)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">t=dist[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若无法找到上述u点，即V-X中的所有dist【i】都为INF，提前结束算法，返回-1代表该图不是连通图 </span></span><br><span class="line"><span class="keyword">if</span>(u==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将u加入到X </span></span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line">ans+=dist[u];</span><br><span class="line"></span><br><span class="line"><span class="comment">//对每个和顶点u邻接的顶点j </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果j不属于X且边（u，j）小于dist【j】，更新dist【j】 </span></span><br><span class="line"><span class="keyword">if</span>(!vis[j]&amp;&amp;G[u][j]&lt;dist[j])</span><br><span class="line">&#123;</span><br><span class="line">dist[j]=G[u][j];</span><br><span class="line">prev[j]=u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回最小生成树的耗费 </span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路径（Dijkstra）"><a href="#最短路径（Dijkstra）" class="headerlink" title="最短路径（Dijkstra）"></a>最短路径（Dijkstra）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traceback</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> prev[],<span class="keyword">int</span> dist[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==start)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t=i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">t=prev[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;distance:&quot;</span>&lt;&lt;dist[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> prev[maxn];</span><br><span class="line"><span class="keyword">int</span> dist[maxn];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(prev,<span class="number">-1</span>,<span class="keyword">sizeof</span>(prev));</span><br><span class="line"><span class="built_in">memset</span>(dist,INF,<span class="keyword">sizeof</span>(dist));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(G[start][i]!=INF)</span><br><span class="line">&#123;</span><br><span class="line">dist[i]=G[start][i];</span><br><span class="line">prev[i]=start;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prev[start]=<span class="number">-1</span>;</span><br><span class="line">dist[start]=<span class="number">0</span>;</span><br><span class="line">vis[start]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==start)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t=INF,u=start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j]&amp;&amp;dist[j]&lt;t)</span><br><span class="line">&#123;</span><br><span class="line">u=j;</span><br><span class="line">t=dist[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j]&amp;&amp;G[u][j]+dist[u]&lt;dist[j])</span><br><span class="line">&#123;</span><br><span class="line">dist[j]=G[u][j]+dist[u];</span><br><span class="line">prev[j]=u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">traceback(start,prev,dist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡二叉树</title>
      <link href="/2020/05/19/AVL/"/>
      <url>/2020/05/19/AVL/</url>
      
        <content type="html"><![CDATA[<h1 id="AVL-平衡二叉树"><a href="#AVL-平衡二叉树" class="headerlink" title="AVL(平衡二叉树)"></a>AVL(平衡二叉树)</h1><blockquote><p>AVL树的定义<br>平衡因子 : 树中某结点其左子树的高度和右子树的高度之差<br>AVL树中的任意一个结点, 其平衡因子的绝对值小于2<br>AVL树是一种特殊的二叉搜索树 (BST树), 相对于数据极端情况下, 二叉搜索树会退化成为单链表,<br> AVL树定义了旋转操作, 在平衡因子大于等于2时, AVL树会旋转来调整树的结构, 来重新满足平衡因子小于2<br><a id="more"></a></p><h2 id="单右旋"><a href="#单右旋" class="headerlink" title="单右旋"></a>单右旋</h2><p>若初始A的平衡因子为1，左子树的平衡因子为0，此时插入若导致A左子树的左子树变高，此时就需要单右旋，通过单右旋会使这棵树重新平衡，平衡后的树高度会恢复为原来的高度。<br><img src="/2020/05/19/AVL/RR.jpg" alt="RR"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入右子树的右子树（RR）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RR</span><span class="params">(TreeNode *&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">TreeNode *temp=t-&gt;right;</span><br><span class="line">t-&gt;right=temp-&gt;left;</span><br><span class="line">temp-&gt;left=t;</span><br><span class="line">t=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="单左旋"><a href="#单左旋" class="headerlink" title="单左旋"></a>单左旋</h2><blockquote><p>若初始A的平衡因子为-1，A的右子树平衡因子为0，若此时插入导致A的右子树的右子树高度增加，此时就需要单左旋。旋转之后A的高度恢复为原来的高度。<br><img src="/2020/05/19/AVL/LL.jpg" alt="LL"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//插入左子树的左子树（LL）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LL</span><span class="params">(TreeNode *&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">TreeNode *temp=t-&gt;left;</span><br><span class="line">t-&gt;left=temp-&gt;right;</span><br><span class="line">temp-&gt;right=t;</span><br><span class="line">t=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="先左后右旋转"><a href="#先左后右旋转" class="headerlink" title="先左后右旋转"></a>先左后右旋转</h2><blockquote><p>若初始A的平衡因子为1，左子树的平衡因子为0，此时插入若导致A左子树的右子树变高，此时就需要先左后右双旋转，通过双旋转会使这棵树重新平衡，平衡后的树高度会恢复为原来的高度。<br><img src="/2020/05/19/AVL/LR.jpg" alt="LR"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入左子树的右子树（LR）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LR</span><span class="params">(TreeNode *&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">RR(t-&gt;left);</span><br><span class="line">LL(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p><h2 id="先右后左双旋转"><a href="#先右后左双旋转" class="headerlink" title="先右后左双旋转"></a>先右后左双旋转</h2><p>若初始A的平衡因子为-1，A的右子树平衡因子为0，若此时插入导致A的右子树的左子树高度增加，此时就需要做先右后左旋转。旋转之后A的高度恢复为原来的高度。<br><img src="/2020/05/19/AVL/RL.jpg" alt="RL"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入右子树的左子树（RL）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RL</span><span class="params">(TreeNode *&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">LL(t-&gt;right);</span><br><span class="line">RR(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p></blockquote><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树的删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_AVL</span><span class="params">(TreeNode *&amp;root,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x&gt;root-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">delete_AVL(root-&gt;right,x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否失衡,删了右子树一个结点,所以判断左子树高度是否过高</span></span><br><span class="line"><span class="keyword">if</span>(getHeight(root-&gt;left)-getHeight(root-&gt;right))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(getHeight(root-&gt;left-&gt;right)&lt;getHeight(root-&gt;left-&gt;left))</span><br><span class="line">LL(root);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LR(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">delete_AVL(root-&gt;left,x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> leftHeight=getHeight(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> rightHeight=getHeight(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否失衡,删了左子树一个结点,所以判断右子树高度是否过高</span></span><br><span class="line"><span class="keyword">if</span>(rightHeight-leftHeight&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(getHeight(root-&gt;right-&gt;left)&gt;getHeight(root-&gt;right-&gt;right))</span><br><span class="line">RL(root);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">RR(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x==root-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//删除左右子树都为空 </span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line">root=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点的左子树为空，右子树不为空 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right!=<span class="literal">NULL</span>) </span><br><span class="line">root=root-&gt;right;</span><br><span class="line"><span class="comment">//删除结点的左子树不为空，右子树为空</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">root=root-&gt;left;</span><br><span class="line"><span class="comment">//删除结点左右子树都不为空</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TreeNode *prev=root;</span><br><span class="line">TreeNode *t=root-&gt;left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">prev=t;</span><br><span class="line">t=t-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(prev!=root)</span><br><span class="line">&#123;</span><br><span class="line">TreeNode *delete_node=prev-&gt;right;</span><br><span class="line">root-&gt;val=t-&gt;val;</span><br><span class="line">prev-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span> delete_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TreeNode *delete_node=root;</span><br><span class="line">root=t;</span><br><span class="line">root-&gt;right=prev-&gt;right;</span><br><span class="line"><span class="keyword">delete</span> delete_node;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树的插入 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_AVL</span><span class="params">(TreeNode *&amp;root,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">root=<span class="keyword">new</span> TreeNode(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x&gt;root-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">insert_AVL(root-&gt;right,x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> leftHeight=getHeight(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> rightHeight=getHeight(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果右节点与左节点高度的差大于1，root失衡 </span></span><br><span class="line"><span class="keyword">if</span>(rightHeight-leftHeight&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;root-&gt;right-&gt;val)</span><br><span class="line">RR(root);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">RL(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;val)</span><br><span class="line">&#123;</span><br><span class="line">insert_AVL(root-&gt;left,x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> leftHeight=getHeight(root-&gt;left);</span><br><span class="line"><span class="keyword">int</span> rightHeight=getHeight(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果左节点与右节点高度的差大于1，root失衡 </span></span><br><span class="line"><span class="keyword">if</span>(leftHeight-rightHeight&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;root-&gt;left-&gt;val)</span><br><span class="line">LL(root);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">LR(root); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BST</title>
      <link href="/2020/05/19/BST/"/>
      <url>/2020/05/19/BST/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树搜索树"><a href="#二叉树搜索树" class="headerlink" title="二叉树搜索树"></a>二叉树搜索树</h1><p>即BST：binary searching tree 或者 binary sort tree</p><h2 id="树结点定义"><a href="#树结点定义" class="headerlink" title="树结点定义"></a>树结点定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">TreeNode *left,*right;</span><br><span class="line"></span><br><span class="line">TreeNode(<span class="keyword">int</span> x):val(x),left(<span class="literal">NULL</span>),right(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索二叉树的插入 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_BST</span><span class="params">(TreeNode *&amp;root,<span class="keyword">int</span> x)</span><span class="comment">//引用很重要，不能去掉 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//插入当前结点 </span></span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">root=<span class="keyword">new</span> TreeNode(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//插入的值比当前结点的值大，递归调用插入当前结点的右子树 </span></span><br><span class="line"><span class="keyword">if</span>(x&gt;root-&gt;val)insert_BST(root-&gt;right,x);</span><br><span class="line"><span class="comment">//插入的值比当前结点的值小，递归调用插入当前结点的左子树</span></span><br><span class="line"><span class="keyword">if</span>(x&lt;root-&gt;val)insert_BST(root-&gt;left,x);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索二叉树的删除 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_BST</span><span class="params">(TreeNode *&amp;root,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//删除的值比当前结点的值大，递归调用插入当前结点的右子树  </span></span><br><span class="line"><span class="keyword">if</span>(x&gt;root-&gt;val)delete_BST(root-&gt;right,x); </span><br><span class="line"><span class="comment">//删除的值比当前结点的值小，递归调用插入当前结点的左子树</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x&lt;root-&gt;val)delete_BST(root-&gt;left,x);</span><br><span class="line"><span class="comment">//删除的值等于当前的结点</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TreeNode *delete_node=root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点左右子树都为空 ，将当前结点置空 </span></span><br><span class="line"><span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">root=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点左子树为空，右子树不为空</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">root=root-&gt;right;</span><br><span class="line"><span class="comment">//删除结点 </span></span><br><span class="line"><span class="keyword">delete</span> delete_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点左子树不为空，右子树为空</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left!=<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">root=root-&gt;left;</span><br><span class="line"><span class="comment">//删除结点 </span></span><br><span class="line"><span class="keyword">delete</span> delete_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点左右都不为空</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TreeNode *prev=root;</span><br><span class="line">TreeNode *t=root-&gt;left;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到左子树中最大的结点 </span></span><br><span class="line"><span class="keyword">while</span>(t-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">prev=t; </span><br><span class="line">t=t-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">swap(t-&gt;val,root-&gt;val);</span><br><span class="line">delete_BST(root-&gt;left,root-&gt;val);</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断是否为BST"><a href="#判断是否为BST" class="headerlink" title="判断是否为BST"></a>判断是否为BST</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_BST</span><span class="params">(TreeNode *root,<span class="keyword">long</span> <span class="keyword">long</span> <span class="built_in">min</span>,<span class="keyword">long</span> <span class="keyword">long</span> <span class="built_in">max</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)<span class="comment">//当前结点为空结点 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(root-&gt;val&lt;=<span class="built_in">min</span>||root-&gt;val&gt;=<span class="built_in">max</span>)<span class="comment">//当前结点不在范围内 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归调用1 </span></span><br><span class="line"><span class="keyword">return</span> is_BST(root-&gt;left,<span class="built_in">min</span>,root-&gt;val)&amp;&amp;is_BST(root-&gt;right,root-&gt;val,<span class="built_in">max</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/2020/05/19/travel-binaryTree/"/>
      <url>/2020/05/19/travel-binaryTree/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><blockquote><p>前言：本文将所有对节点的访问操作简化为简单的输出</p></blockquote><a id="more"></a><h2 id="树结点定义"><a href="#树结点定义" class="headerlink" title="树结点定义"></a>树结点定义</h2><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct TreeNode</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> val;</span><br><span class="line"></span><br><span class="line">TreeNode *<span class="built_in">left</span>,*<span class="built_in">right</span>;</span><br><span class="line"></span><br><span class="line">TreeNode(<span class="built_in">int</span> x):val(x),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="前序遍历-（根-左-右）"><a href="#前序遍历-（根-左-右）" class="headerlink" title="[前序遍历]（根-左-右）"></a>[前序遍历]（根-左-右）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历（递归）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_recursion</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//访问结点 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">pre_order_recursion(root-&gt;left);</span><br><span class="line"></span><br><span class="line">pre_order_recursion(root-&gt;right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历（迭代） </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_iteration</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//空树 </span></span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line"></span><br><span class="line">TreeNode *t=root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t||!s.empty())</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">s.push(t);</span><br><span class="line"></span><br><span class="line">t=t-&gt;left; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t=s.top();s.pop();t=t-&gt;right; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历-（左-根-右）"><a href="#中序遍历-（左-根-右）" class="headerlink" title="[中序遍历]（左-根-右）"></a>[中序遍历]（左-根-右）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历（递归）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_recursion</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root)</span><br><span class="line">&#123;</span><br><span class="line">in_order_recursion(root-&gt;left);</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">in_order_recursion(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历（迭代）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_iteration</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//空树 </span></span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">TreeNode *t=root;</span><br><span class="line"><span class="keyword">while</span>(!s.empty()||t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(t)</span><br><span class="line">&#123;</span><br><span class="line">s.push(t);</span><br><span class="line">t=t-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">t=s.top();s.pop();<span class="built_in">cout</span>&lt;&lt;t-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">t=t-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历-（左-右-根）"><a href="#后序遍历-（左-右-根）" class="headerlink" title="[后序遍历]（左-右-根）"></a>[后序遍历]（左-右-根）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历（递归）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">last_order_recursion</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root)</span><br><span class="line">&#123;</span><br><span class="line">last_order_recursion(root-&gt;left);</span><br><span class="line"></span><br><span class="line">last_order_recursion(root-&gt;right);</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历（迭代） </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 后续遍历关键在于，当节点的  右子树存在且被访问后  或者是  右子树为空  才能访问自身。</span></span><br><span class="line"><span class="comment"> 在遍历过程中，先将节点从的左孩子到最左节点压栈， 设置标志变量 flag 来判断是否访问过左孩子， pre指针来指向先前访问过的节点。</span></span><br><span class="line"><span class="comment"> 所有左孩子压栈后， 最后一个节点的左孩子为空，已被访问p = NULL ， 令flag=1</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 当左孩子被访问时，进入循环，取栈顶节点。</span></span><br><span class="line"><span class="comment"> 1. 当栈顶节点的右孩子 等于 空  或  前一个被访问的节点  时， 访问该节点， 令pre 等于当前节点，pre = p， 当前节点出栈。</span></span><br><span class="line"><span class="comment"> 2. 当栈顶节点的右孩子不为空时， 继续遍历以右孩子为根节点的右子树。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">last_order_iteration</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//空树 </span></span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">TreeNode *pre=<span class="literal">NULL</span>,*p=root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.push(p);</span><br><span class="line">p=p-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!s.empty()&amp;&amp;flag==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">p=s.top();</span><br><span class="line"></span><br><span class="line"><span class="comment">//当栈中结点的右结点访问了或者为空时，访问结点 </span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;right==<span class="literal">NULL</span>||p-&gt;right==pre)</span><br><span class="line">&#123;</span><br><span class="line">s.pop();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">pre=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则访问当前结点的右子树 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;right;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(!s.empty()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="[层次遍历]"></a>[层次遍历]</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">level_order</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//空树</span></span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line"></span><br><span class="line">q.push(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">TreeNode *t=q.front();q.pop();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;t-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t-&gt;left)q.push(t-&gt;left);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t-&gt;right)q.push(t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆的相关算法</title>
      <link href="/2020/05/19/heap/"/>
      <url>/2020/05/19/heap/</url>
      
        <content type="html"><![CDATA[<h1 id="堆的存储结构"><a href="#堆的存储结构" class="headerlink" title="堆的存储结构"></a>堆的存储结构</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Heap(<span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">10</span>);</span><br><span class="line">~Heap();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift_down</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift_up</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">int</span> *heap;<span class="comment">//用于存放数据，索引从1开始到size</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;<span class="comment">//堆的大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*无关紧要的函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 </span></span><br><span class="line">Heap::Heap(<span class="keyword">int</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">heap=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*<span class="built_in">size</span>];</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">size</span>=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数 </span></span><br><span class="line">Heap::~Heap()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> [] heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示heap数组 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Heap:&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">size</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;heap[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="堆的相关算法"><a href="#堆的相关算法" class="headerlink" title="堆的相关算法"></a>堆的相关算法</h1><h2 id="上溯"><a href="#上溯" class="headerlink" title="上溯"></a>上溯</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从第i个点下沉 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::sift_up</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> done=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i!=<span class="number">1</span>&amp;&amp;done==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果i的父节点比i大，交换，否则sift_up完成 </span></span><br><span class="line"><span class="keyword">if</span>(heap[i/<span class="number">2</span>]&gt;heap[i])</span><br><span class="line">swap(heap[i/<span class="number">2</span>],heap[i]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">done=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向上迭代 </span></span><br><span class="line">i=i/<span class="number">2</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下沉"><a href="#下沉" class="headerlink" title="下沉"></a>下沉</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从第i个点上溯 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::sift_down</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> done=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(done==<span class="literal">false</span>&amp;&amp;<span class="number">2</span>*i&lt;=<span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//向下迭代 </span></span><br><span class="line">i=<span class="number">2</span>*i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选i子节点中最小的节点 </span></span><br><span class="line"><span class="keyword">if</span>(i+<span class="number">1</span>&lt;=<span class="built_in">size</span>&amp;&amp;heap[i+<span class="number">1</span>]&lt;heap[i])</span><br><span class="line">i=i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果i比其子节点的最大值还大，交换节点，否则完成sift_down </span></span><br><span class="line"><span class="keyword">if</span>(heap[i/<span class="number">2</span>]&gt;heap[i])</span><br><span class="line">swap(heap[i/<span class="number">2</span>],heap[i]); </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">done=<span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">++<span class="built_in">size</span>;</span><br><span class="line">heap[<span class="built_in">size</span>]=x;</span><br><span class="line">sift_up(<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除第i个点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::Delete</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=heap[i],y=heap[<span class="built_in">size</span>];</span><br><span class="line"></span><br><span class="line">--<span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">heap[i]=y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(y&lt;x)</span><br><span class="line">sift_up(i);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sift_down(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote><p>因为heap[1]是最小的，所以swap(heap[1],heap[size])可以将最小的元素放到数组最后，然后sift_down(1)对heap[1…size-1]维持最小堆，直到size为1<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将heap按降序排序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap::heapsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Size=<span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">size</span>!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">swap(heap[<span class="number">1</span>],heap[<span class="built_in">size</span>]);</span><br><span class="line">--<span class="built_in">size</span>;</span><br><span class="line">sift_down(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>=Size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于测试 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Heap h;</span><br><span class="line"><span class="keyword">int</span> op;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;1:insert 2:delete 3:heapsort 4:quit&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;op&amp;&amp;op!=<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;the element you want to insert:&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">h.Insert(x);</span><br><span class="line">h.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;the index of the elemnet you want to delete:&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">h.Delete(x);</span><br><span class="line">h.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">h.heapsort();</span><br><span class="line">h.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统概念</title>
      <link href="/2020/04/29/concept-of-database/"/>
      <url>/2020/04/29/concept-of-database/</url>
      
        <content type="html"><![CDATA[<h1 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h1><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><blockquote><p>设R（U）是属性U上的一个关系模式，X和Y均为U={A1，A2，…，An}的子集，r为R的任一关系，<br>如果对于r中的任意两个元组u，v，只要有u[X]=v[X]，就有u[Y]=v[Y]，<br>则称X函数决定Y，或称Y函数依赖于X，记为X→Y<br><a id="more"></a><br><strong>例如：</strong><br><em>(sno-学生ID，tno-教师ID，cno-课程ID，sname-学生姓名，tname-教师姓名，cname-课程名称,grade-成绩）</em><br>1、sno→sname, cno→cname,(sno,cno)→grade √<br>2、sname→sno, tno→cno, sno→tname ×</p></blockquote><h2 id="函数依赖分为完全函数依赖和部分函数依赖"><a href="#函数依赖分为完全函数依赖和部分函数依赖" class="headerlink" title="函数依赖分为完全函数依赖和部分函数依赖"></a>函数依赖分为完全函数依赖和部分函数依赖</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><blockquote><p> 在R(U)中，如果X→Y，并且对于X的任何真子集X’都有X’Y’，则称Y完全依赖于X，记作X→Y；否则，如果X→Y，且X中存在一个真子集X’，使得X’→Y成立，则称Y部分依赖于X。</p></blockquote><p><strong>例如：</strong><br><code>学生ID，学生姓名，所修课程ID，课程名称成绩</code><br>（学生ID，所修课程ID）→成绩 <br>成绩不能单独依赖与学生ID，也不能单独依赖于课程ID，因此成绩完全函数依赖于关键字。<br>（学生ID，所修课程ID）→学生姓名<br>学生姓名能单独依赖于关键字的一个属性学生ID，因此学生姓名部分函数依赖于（学生ID，所修课程ID）</p><h2 id="平凡函数依赖和非平凡函数依赖"><a href="#平凡函数依赖和非平凡函数依赖" class="headerlink" title="平凡函数依赖和非平凡函数依赖"></a>平凡函数依赖和非平凡函数依赖</h2><p>设X，Y均为某关系上的属性集，且X→Y</p><ol><li>Y是X的子集，则称X→Y为：平凡函数依赖</li><li>Y不是X的子集，则称X→Y为：非平凡函数依赖</li></ol><h1 id="六个范式"><a href="#六个范式" class="headerlink" title="六个范式"></a>六个范式</h1><h2 id="一些基础概念"><a href="#一些基础概念" class="headerlink" title="一些基础概念"></a>一些基础概念</h2><blockquote><ul><li><p><strong>超码（superkey）</strong>：是一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地标识一个元组。</p></li><li><p><strong>候选码（candidate key）</strong>：超码中可能包含无关紧要的属性。当一些超码的任意真子集不能成为超码，我们称这些最小超码为<code>候选码</code>。</p></li><li><p><strong>主码（primary key）</strong>：被我们选中的主要用来在一个关系中区分不同元组的候选码</p></li><li><p><strong>外码（foreign key）</strong>：一个关系模式（r1）可能在它的属性中包括另一个关系模式（r2）的<code>主码</code>。这个属性在r1上称作参照r2的<code>外码</code>。关系r1也称为外码依赖的<code>参照关系（referencing relation）</code>，r2叫做外码的<code>被参照关系（referenced relation）</code></p></li></ul></blockquote><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="第一范式（1NF）：关系模式中所有属性都是不可分的。"><a href="#第一范式（1NF）：关系模式中所有属性都是不可分的。" class="headerlink" title="第一范式（1NF）：关系模式中所有属性都是不可分的。"></a>第一范式（1NF）：<strong>关系模式中<code>所有属性</code>都是<code>不可分的</code>。</strong></h3><h3 id="第二范式（2NF）：符合1NF，并且每一个非主属性完全依赖于候选码。"><a href="#第二范式（2NF）：符合1NF，并且每一个非主属性完全依赖于候选码。" class="headerlink" title="第二范式（2NF）：符合1NF，并且每一个非主属性完全依赖于候选码。"></a>第二范式（2NF）：<strong>符合1NF，并且<code>每一个非主</code>属性<code>完全</code>依赖于候选码</strong>。</h3><h3 id="第三范式（3NF）：符合2NF，且消除依赖传递。"><a href="#第三范式（3NF）：符合2NF，且消除依赖传递。" class="headerlink" title="第三范式（3NF）：符合2NF，且消除依赖传递。"></a>第三范式（3NF）：<strong>符合2NF，且消除依赖传递。</strong></h3><blockquote><p>若R∈3NF，则R的每一个非主属性既不部分函数依赖于候选码也不传递函数依赖于候选码。——若R∈3NF，则R的每一个<code>非主属性</code>既不部分函数依赖于候选码也不传递函数依赖于候选码。</p></blockquote><h3 id="BC范式（BCNF）：符合3NF，且主属性不依赖于主属性。"><a href="#BC范式（BCNF）：符合3NF，且主属性不依赖于主属性。" class="headerlink" title="BC范式（BCNF）：符合3NF，且主属性不依赖于主属性。"></a>BC范式（BCNF）：符合3NF，且主属性不依赖于主属性。</h3><blockquote><p>设关系模式R<U，F>∈1NF，如果对于R的每个函数依赖X→Y，若Y不属于X，则X必含有候选码，那么R∈BCNF。</U，F></p></blockquote><p>若R∈BCNF </p><blockquote><ul><li>每一个决定属性集（因素）都包含（候选）码</li><li>R中的所有属性（主，非主属性）都完全函数依赖于码</li><li>R∈3NF</li></ul></blockquote><h3 id="第四范式（4NF）：要求把同一表内多对多的关系删除"><a href="#第四范式（4NF）：要求把同一表内多对多的关系删除" class="headerlink" title="第四范式（4NF）：要求把同一表内多对多的关系删除"></a>第四范式（4NF）：<strong>要求把同一表内多对多的关系删除</strong></h3><h3 id="第五范式（5NF）：从最终结构重新建立原始结构"><a href="#第五范式（5NF）：从最终结构重新建立原始结构" class="headerlink" title="第五范式（5NF）：从最终结构重新建立原始结构"></a>第五范式（5NF）：<strong>从最终结构重新建立原始结构</strong></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大基础排序</title>
      <link href="/2020/04/26/sort/"/>
      <url>/2020/04/26/sort/</url>
      
        <content type="html"><![CDATA[<h1 id="八大基础排序"><a href="#八大基础排序" class="headerlink" title="八大基础排序"></a>八大基础排序</h1><p>[TOC]</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><strong>思路：俩俩交换，大的放在后面，第一次排序后最大值已在数组末尾。因为俩俩交换，需要<code>n-1</code>趟排序（比如10个数，需要9趟排序）</strong></p><p><strong>代码实现要点：两个for循环，外层循环控制排序的趟数，内层循环控制比较的次数。每趟过后，比较的次数都应该要减1</strong><br><a id="more"></a><br>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//记录是否发生了置换，0表示没有发生置换，反之为1</span></span><br><span class="line"><span class="keyword">int</span> ischange;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每次比较一趟就重新初始化为0</span></span><br><span class="line">isChange=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a.<span class="built_in">size</span>()-i<span class="number">-1</span>;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//前一位与后一位比较，如果前一位比后一位大，就交换</span></span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">swap(a[j],a[j+<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//标志发生置换</span></span><br><span class="line">isChange=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//这趟比较没有置换，说明数组已经排好序，不需要在执行下去 </span></span><br><span class="line"><span class="keyword">if</span>(isChange==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>思路：找到数组中最大的元素，与数组最后一位元素交换。当只有一个数时，则不需要选择了，因此需要<code>n-1</code>趟排序</strong></p><p><strong>代码实现要点：两个for循环，外层循环控制排序的趟数，内层循环找到当前趟数的最大值，随后与当前趟数组最后的一位元素交换</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//记录当前趟最大数的坐标 </span></span><br><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>()<span class="number">-1</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//每次比较一趟就重新初始化为0</span></span><br><span class="line">pos=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内层循环找到当前趟的最大值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a.<span class="built_in">size</span>()-i;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;a[pos])</span><br><span class="line">&#123;</span><br><span class="line">pos=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果最大值坐标不在当前位置，交换 </span></span><br><span class="line">swap(a[pos],a[a.<span class="built_in">size</span>()-i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><strong>思路：将一个元素插入到已有序的数组中，在初始时未知是否存在有序的数据，因此将元素第一个元素看成是有序的。与有序的数组进行比较，比它大则直接放入，比它小则移动数组元素的位置，找到个合适的位置插入。当只有一个数时，则不需要插入了，因此需要<code>n-1</code>趟排序</strong></p><p><strong>代码实现：一个for循环内嵌一个while循环实现，外层for循环控制需要排序的趟数，while循环找到合适的插入位置(并且插入的位置不能小于0)</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//临时变量 </span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.<span class="built_in">size</span>();++i)</span><br><span class="line">&#123;</span><br><span class="line">temp=a[i]; </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果前一位比当前数据大，就进入while循环进行移动 </span></span><br><span class="line"><span class="keyword">int</span> j=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;a[j]&gt;temp)</span><br><span class="line">&#123;</span><br><span class="line">a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">--j;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//退出循环时，插入位置为j+1(因为a[j]&lt;=temp)</span></span><br><span class="line">a[j+<span class="number">1</span>]=temp; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>思路：在数组中找一个元素(节点)，比它小的放在节点的左边，比它大的放在节点右边。一趟下来，比节点小的在左边，比节点大的在右边。不断执行这个操作….</strong></p><p><strong>代码实现：支点取中间，使用L和R表示数组的最小和最大位置。不断进行比较，直到找到比支点小(大)的数，随后交换，不断减小范围。递归L到支点前一个元素(j)。递归支点后一个元素(i)到R元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//L指向数组当前区间的第一个元素，R为最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//临时变量，用来当划分数组的界点 </span></span><br><span class="line"><span class="keyword">int</span> temp=a[L];</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(j=L+<span class="number">1</span>;j&lt;=R;++j)<span class="comment">//将所有小于等于a[i]的放在数组左边，大于的放在数组右边</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;=temp)</span><br><span class="line">&#123;</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span>(i!=j)</span><br><span class="line">swap(a[i],a[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(a[L],a[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//当前范围无需再排序 </span></span><br><span class="line"><span class="keyword">if</span>(L&gt;=R)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数组划分 </span></span><br><span class="line"><span class="keyword">int</span> w=split(a,L,R); </span><br><span class="line"></span><br><span class="line"><span class="comment">//递归调用，将a[i]两边排序 </span></span><br><span class="line">quick_sort(a,L,w<span class="number">-1</span>); </span><br><span class="line">quick_sort(a,w+<span class="number">1</span>,R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>思路：将两个已排好序的数组合并成一个有序的数组。将元素分隔开来，看成是有序的数组，进行比较合并。不断拆分和合并，直到只有一个元素</strong></p><p><strong>代码实现：在第一趟排序时实质是两个元素(看成是两个已有序的数组)来进行合并，不断执行这样的操作，最终数组有序，拆分左边，右边，合并…</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> L,<span class="keyword">int</span> mid,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(mid-L)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(R-mid+<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往两个数组填充数据 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=L;i&lt;mid;++i)</span><br><span class="line">v1[i-L]=a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=mid;i&lt;=R;++i)</span><br><span class="line">v2[i-mid]=a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a数组的第一个元素 </span></span><br><span class="line"><span class="keyword">int</span> K=L;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并数组 </span></span><br><span class="line"><span class="keyword">while</span>(i&lt;v1.<span class="built_in">size</span>()&amp;&amp;j&lt;v2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(v1[i]&lt;v2[i])</span><br><span class="line">a[k++]=v1[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">a[k++]=v2[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;v1.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">a[k++]=v1[i++];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(j&lt;v2.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">a[k++]=v2[j++];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//当前范围无需再排序 </span></span><br><span class="line"><span class="keyword">if</span>(L&gt;=R)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取中间的数进行拆分 </span></span><br><span class="line"><span class="keyword">int</span> mid=(L+R)/<span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//将左右数组不断拆分 </span></span><br><span class="line">merge_sort(a,L,mid<span class="number">-1</span>); </span><br><span class="line">merge_sort(a,mid,R);</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并左右数组 </span></span><br><span class="line">merge(a,L,mid,R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>思路：堆排序使用到了完全二叉树的一个特性，根节点比左孩子和右孩子都要大，完成一次建堆的操作实质上是比较根节点和左孩子、右孩子的大小，大的交换到根节点上，直至最大的节点在树顶。随后与数组最后一位元素进行交换</strong></p><p><strong>代码实现：只要左子树或右子树大于当前根节点，则替换。替换后会导致下面的子树发生了变化，因此同样需要进行比较，直至各个节点实现父&gt;子这么一个条件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift_down</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">int</span> cur,<span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cur&lt;<span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当前结点左右子树的位置</span></span><br><span class="line"><span class="keyword">int</span> left=<span class="number">2</span>*cur+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right=<span class="number">2</span>*cur+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把当前结点位置看成是最大的 </span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span>=cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(left&lt;<span class="built_in">size</span>&amp;&amp;a[<span class="built_in">max</span>]&lt;a[left])</span><br><span class="line"><span class="built_in">max</span>=left;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(right&lt;<span class="built_in">size</span>&amp;&amp;a[<span class="built_in">max</span>]&lt;a[right])</span><br><span class="line"><span class="built_in">max</span>=right;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果最大的不是cur，就交换</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">max</span>!=cur)</span><br><span class="line">&#123;</span><br><span class="line">swap(a[<span class="built_in">max</span>],a[cur]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续比较，直到完成一次建堆 </span></span><br><span class="line">sift_down(a,<span class="built_in">max</span>,<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//完成一次建堆 </span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>=a.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=(<span class="built_in">size</span><span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i)<span class="comment">//从最后一个非叶子结点建堆 </span></span><br><span class="line">sift_down(a,i,<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="built_in">size</span><span class="number">-1</span>;j&gt;<span class="number">0</span>;--j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//a[0]为最大值，与最后一个元素交换，缩小调整范围 </span></span><br><span class="line">swap(a[<span class="number">0</span>],a[j]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整位置 </span></span><br><span class="line">sift_down(a,<span class="number">0</span>,j);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><strong>思路：希尔排序实质上就是插入排序的增强版，希尔排序将数组分隔成n组来进行插入排序，直至该数组宏观上有序，最后再进行插入排序时就不用移动那么多次位置了～</strong></p><p><strong>代码思路：希尔增量一般是gap = gap / 2，只是比普通版插入排序多了这么一个for循环而已。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>=a.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//增量每次都除以二 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">step</span>=<span class="built_in">size</span>/<span class="number">2</span>;<span class="built_in">step</span>&gt;<span class="number">0</span>;<span class="built_in">step</span>/=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">step</span>;i&lt;<span class="built_in">size</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j=i;</span><br><span class="line"><span class="keyword">int</span> temp=a[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//j-step就是代表与j同组的前一位元素 </span></span><br><span class="line"><span class="keyword">while</span>(j-<span class="built_in">step</span>&gt;=<span class="number">0</span>&amp;&amp;a[j-<span class="built_in">step</span>]&gt;temp)&#123;</span><br><span class="line">a[j]=a[j-<span class="built_in">step</span>];</span><br><span class="line">j-=<span class="built_in">step</span>;</span><br><span class="line">&#125;</span><br><span class="line">a[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序（桶排序）"><a href="#基数排序（桶排序）" class="headerlink" title="基数排序（桶排序）"></a>基数排序（桶排序）</h2><p><strong>思路：基数排序(桶排序)：将数字切割成个、十、百、千位放入到不同的桶子里，放一次就按桶子顺序回收一次，直至最大位数的数字放完～那么该数组就有序了</strong></p><p><strong>代码实现：先找到数组的最大值，然后根据最大值/10来作为循环的条件(只要&gt;0，那么就说明还有位数)。将个位、十位、…分配到桶子上，每分配一次就回收一次</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*求数据的最大位数,决定排序次数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxbit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1</span>; <span class="comment">//保存最大的位数</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;=p)</span><br><span class="line">        &#123;</span><br><span class="line">            p *= <span class="number">10</span>;</span><br><span class="line">            ++d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span> <span class="comment">//基数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = maxbit(a);</span><br><span class="line">    <span class="keyword">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> tmp[n];</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">10</span>]; <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= d; i++) <span class="comment">//进行d次排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = <span class="number">0</span>; <span class="comment">//每次分配前清空计数器</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k = (a[j] / radix) % <span class="number">10</span>; <span class="comment">//统计每个桶中的记录数</span></span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j]; <span class="comment">//将tmp中的位置依次分配给每个桶</span></span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) <span class="comment">//将所有桶中记录依次收集到tmp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = (a[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = a[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) <span class="comment">//将临时数组的内容复制到data中</span></span><br><span class="line">            a[j] = tmp[j];</span><br><span class="line">        radix = radix * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
